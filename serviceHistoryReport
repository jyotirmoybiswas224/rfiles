import { useEffect, useMemo, useRef, useState, useTransition } from "react";
import { Link, useNavigate } from "react-router-dom";
import * as dateFnsTz from "date-fns-tz";
import ReportCheckbox from "./ReportCheckBox";
import CustomDatePicker from "../../../../../components/UI/CustomDatePicker";
import Loader from "../../../../../components/UI/loaders/Loader";
import {
	arrayRemove,
	arrayUnion,
	collection,
	doc,
	documentId,
	getDoc,
	getDocs,
	limit,
	onSnapshot,
	orderBy,
	query,
	setDoc,
	startAfter,
	Timestamp,
	updateDoc,
	where,
	writeBatch,
} from "firebase/firestore";
import { auth, COLLECTIONS, db, getDeliveryUrl, getManifestUrl } from "../../../../../config/firebase";
import {
	itemsMap,
	SERVICE_STATUS,
	serviceTypes,
	serviceTypesMap,
	subWasteTypesMap,
	TRANSFER_STATUS,
	transferStatusMap,
	transferStatusType,
} from "../../../../../utils/constants";
import DropdownReport from "./ReportDropDown";
import {
	capitalizeFirstLetter,
	dateFormatter,
	formattedDate,
	formattedDateTime,
	formatUtcDateString,
	octoFormatter,
	showErrorToastMessage,
	showInternalServerErrorToastMessage,
	showSuccessToastMessage,
} from "../../../../../utils/helpers";
import MultiselectDropdown from "../../../../../components/UI/dropdowns/MultiselectDropdown";
import { FiSearch } from "react-icons/fi";
import {
	getAllDrivers,
	getAllRoutes,
	getAllTreatmentOptions,
	getAllServiceVehicleOptions,
} from "../../../../../utils/firebaseOperations";
import { useAuthState } from "react-firebase-hooks/auth";
import Button from "../../../../../components/UI/Button";
import useTUserContext from "../../../../../context/TransporterUserContext";
import { toast } from "react-toastify";
import { BiTrash } from "react-icons/bi";
import { log } from "handlebars";
import OptionsContainer from "./OptionsContainer";

const transStatusOptions = [
	{
		label: "All",
		value: "all",
	},
	{
		label: "In Transit",
		value: transferStatusType.ON_TRUCK,
	},
	{
		label: "Transferred",
		value: transferStatusType.COMPLETE,
	},
];

const serviceStatusOptions = [
	{ label: "All", value: "all" },
	{ label: "Unlogged", value: "UNLOGGED" },
	{ label: "Completed", value: "COMPLETE" },
	{ label: "Canceled", value: "CANCELLED" },
	{ label: "Unavailable", value: "UNAVAILABLE" },
];

const getStringOfServiceTypes = (scheduleData) => {
	if (!scheduleData || !scheduleData.serviceType || !serviceTypes) {
		return "N/A";
	}
	return Array.isArray(scheduleData.serviceType)
		? scheduleData.serviceType.reduce((accumulator, serviceType) => {
				const matchingService = serviceTypes.find((service) => service.value === serviceType);
				return accumulator.concat(matchingService ? matchingService.label : "N/A");
		  }, [])
		: scheduleData.serviceType;
};

const getFormattedAddress = (add) => {
	const addressParts = [add.serviceAddress?.street, add.serviceAddress?.city, add.serviceAddress?.state].filter(
		Boolean
	);

	const address = addressParts.length
		? addressParts.join(", ") + (add.serviceAddress?.zipCode ? ` ${add.serviceAddress.zipCode}` : "")
		: "--";

	return address;
};

const handleDeliveryView = async (id, url) => {
	console.log("id,url", { id, url });

	if (url && url?.length > 0) {
		window.open(url, "_blank");
	} else {
		const fetchUrl = getDeliveryUrl(id);
		console.log("fetchUrl", fetchUrl);
		window.open(fetchUrl, "_blank");
	}
};

const sortedServiceSummary = (summary) =>
	summary.sort((a, b) => {
		const aType = a.subWasteType?.toLowerCase() || "";
		const bType = b.subWasteType?.toLowerCase() || "";
		return aType.localeCompare(bType);
	});

const handleManifestView = async (id, url) => {
	console.log({ id, url });

	if (url && url?.length > 0) {
		window.open(url, "_blank");
	} else {
		const fetchUrl = getManifestUrl(id);
		console.log("fetchUrl", fetchUrl);
		window.open(fetchUrl, "_blank");
	}
};

const getTransferredContainers = async (allContainerEntries = [], serviceId = "") => {
	if (allContainerEntries.length === 0) {
		return {
			transferStatus: "PENDING",
			transferredContainers: [],
		};
	}

	const containerRefs = allContainerEntries
		.map((item) => (item.id ? doc(db, COLLECTIONS.servicedContainers, item.id) : null))
		.filter(Boolean);

	const containerDocs = await Promise.all(containerRefs.map((ref) => getDoc(ref)));
	const allContainersExist = containerDocs.every((doc) => doc.exists());

	let allDocs = containerDocs.map((item) => ({
		id: item.id,
		...item.data(),
	}));

	const allComplete = containerDocs.every((doc) => doc.exists() && doc.data()?.transferStatus === "COMPLETE");

	const transferStatus = allContainersExist && allComplete ? "COMPLETE" : "INPROGRESS";

	if (transferStatus === "COMPLETE") {
		const treatmentIds = allDocs.map((doc) => doc.treatmentId).filter(Boolean);
		const treatmentRefs = treatmentIds.map((id) => doc(db, COLLECTIONS.treatments, id));
		const treatmentDocs = await Promise.all(treatmentRefs.map((ref) => getDoc(ref)));

		const treatmentMap = {};
		treatmentDocs.forEach((tDoc) => {
			if (tDoc.exists()) {
				treatmentMap[tDoc.id] = { id: tDoc.id, ...tDoc.data() };
			}
		});

		allDocs = allDocs.map((container) => {
			const treatmentData = container.treatmentId ? treatmentMap[container.treatmentId]?.wasteProcessingFees : null;

			let wasteProcessingFees = {};

			if (treatmentData && typeof treatmentData === "object") {
				Object.entries(treatmentData).forEach(([key, value]) => {
					if (value && value.checked && value.fee?.isActive) {
						if (key == "biohazard") {
							wasteProcessingFees["Bio/Sharps"] = value.fee.price;
						} else if (key == "pharmaceutical") {
							wasteProcessingFees["RCRA Pharmaceutical"] = value.fee.price;
							wasteProcessingFees["Non-RCRA Pharmaceutical"] = value.fee.price;
						} else if (key == "pathology") {
							wasteProcessingFees["Chemotherapy"] = value.fee.price;
						} else if (key == "paperShredding") {
							wasteProcessingFees["Paper Shredding"] = value.fee.price;
						}
					}
				});
			}

			return {
				...container,
				treatmentData,
				wasteProcessingFees,
			};
		});
	}

	return {
		transferStatus,
		transferredContainers: transferStatus === "COMPLETE" ? allDocs : [],
	};
};

const ServiceReporting = () => {
	const [isLoading, setIsLoading] = useState(true);
	const [selectAll, setSelectAll] = useState(false);
	const [indeterminate, setIndeterminate] = useState(false);
	const [completeServices, setCompleteServices] = useState([]);
	const [searchQuery, setSearchQuery] = useState("");
	const [from, setFrom] = useState(new Date());
	const [to, setTo] = useState(() => new Date());
	const [pickupOptions, setPickupOptions] = useState([]);
	const [serviceTypeOptions, setServiceTypeOptions] = useState([]);
	const [routeOptions, setRouteOptions] = useState([]);
	const [driverOptions, setDriverOptions] = useState([]);
	const [serviceVehicleOptions, setServiceVehicleOptions] = useState([]);
	const [allDrivers, setAllDrivers] = useState([]);
	const [contractorOptions, setContractorOptions] = useState([]);
	const [subContractorOptions, setSubContractorOptions] = useState([]);
	const [showDropdowns, setShowDropdowns] = useState(false);
	const [selectedVehicle, setSelectedVehicle] = useState("");
	const [selectedDriver, setSelectedDriver] = useState("");
	const [selectedTransStatusOptions, setSelectedTransStatusOptions] = useState(
		transStatusOptions.map((item) => item.value)
	);
	const [selectedPickupOptions, setSelectedPickupOptions] = useState([]);
	const [selectedServices, setSelectedServices] = useState([]);
	const [selectedDrivers, setSelectedDrivers] = useState([]);
	const [genIds, setGenIds] = useState([]);
	const [filteredData, setFilteredData] = useState([]);
	const [selectedRoutes, setSelectedRoutes] = useState([]);
	const [isFiltering, startTransition] = useTransition();
	const [genIdsLoading, setIsGenIdsLoading] = useState(true);
	const [containersMap, setContainersMap] = useState({});
	const [delContainersMap, setDelContainersMap] = useState({});
	const [transporterData, setTransporterData] = useState(null);
	const [newContainers, setNewContainers] = useState([]);
	const [newDelContainers, setNewDelContainers] = useState([]);
	const [selectedRows, setSelectedRows] = useState([]);
	const [isDeleting, setIsDeleting] = useState(null);
	const [editing, setEditing] = useState({
		serviceId: null,
		section: null,
		consentAcceptance: false,
	});
	const [editedData, setEditedData] = useState({});
	const { user, loading } = useTUserContext();
	const selectAllRef = useRef();
	const [containerPriceBook, setContainerPriceBook] = useState({});
	const [showAddContainerModal, setShowAddContainerModal] = useState(false);
	const [selectedServiceStatusOptions, setSelectedServiceStatusOptions] = useState(
		serviceStatusOptions.map((item) => item.value)
	);
	const [newContainerData, setNewContainerData] = useState({
		subWasteType: "",
		containerType: "",
		quantity: 1,
		weight: 0,
		rate: 0,
		total: 0,
		serviceType: "CONSOLIDATED",
	});
	const [pageSize] = useState(100);
	const [lastVisibleDoc, setLastVisibleDoc] = useState(null);
	const [hasMore, setHasMore] = useState(false);
	const [unsubscribeServices, setUnsubscribeServices] = useState(null);

	// Load once during component mount or on page load
	const loadContainerPriceBook = async () => {
		const containersRef = collection(db, COLLECTIONS.defaultPriceBook, "services", "containers");
		const snapshot = await getDocs(containersRef);

		const containerMap = {};
		snapshot.forEach((doc) => {
			containerMap[doc.id] = doc.data();
		});

		return containerMap;
	};

	useEffect(() => {
		loadContainerPriceBook().then(setContainerPriceBook);
	}, []);

	const urlParams = new URLSearchParams(window.location.search);
	const genOctoNumber = urlParams.get("id");

	useEffect(() => {
		if (genOctoNumber) {
			console.log("genOctonumber", genOctoNumber);
			setSearchQuery(genOctoNumber);
			// viewButtonHandler(gen);
		}
	}, [genOctoNumber]);

	const fetchAllDriverOptions = async () => {
		try {
			const resp = await getAllDrivers(user?.uid);
			const options = [];
			resp.map((item) => {
				let label = item.firstName + " " + item.lastName;
				options.push({
					label,
					value: label,
				});
			});
			setAllDrivers(resp.map((item) => ({ label: item.firstName + " " + item.lastName, value: item.id })));
			setDriverOptions([{ label: "All", value: "all" }, ...options]);
			setSelectedDrivers(["all", ...options.map((item) => item.value)]);
			fetchDocuments();
		} catch (error) {
			console.log("Error fetching drivers", error);
		}
	};

	const fetchDocuments = async () => {
		if (!user) return;

		try {
			const q = query(collection(db, COLLECTIONS.generators), where("transporterId", "==", user?.uid));
			const querySnapshot = await getDocs(q);

			const ids = querySnapshot.docs.map((doc) => doc.id);
			setGenIds(ids);
		} catch (error) {
			console.error("Error fetching documents:", error);
		} finally {
			setIsGenIdsLoading(false);
		}
	};

	const fetchAllTransferOptions = async () => {
		try {
			const resp = await getAllTreatmentOptions(user?.uid);
			const options = [];
			let map = {};
			resp.map((item) => {
				options.push({
					label: item.name,
					value: item.id,
				});
				map[item.id] = item.name;
			});
			setPickupOptions([{ label: "All", value: "all" }, ...options]);
			setSelectedPickupOptions(["all", ...options.map((item) => item.value)]);
		} catch (error) {
			console.log("Error fetching routes", error);
		}
	};

	const fetchAllServiceVehicleOptions = async () => {
		try {
			const resp = await getAllServiceVehicleOptions(user?.uid);
			const options = [];
			let map = {};
			resp.map((item) => {
				options.push({
					label: item.name,
					value: item.id,
				});
				map[item.id] = item.name;
			});
			setServiceVehicleOptions(options);
		} catch (error) {
			console.log("Error fetching routes", error);
		}
	};

	useEffect(() => {
		const fetchTransporterData = async () => {
			if (!user?.uid) return;
			let docSnapshot = await getDoc(doc(db, COLLECTIONS.transporters, user.uid));
			if (docSnapshot.exists()) {
				let data = { ...docSnapshot.data(), id: docSnapshot.id };
				setTransporterData(data);
			}
		};

		fetchTransporterData();
	}, [user]);

	useEffect(() => {
		if (user && !genIdsLoading) viewButtonHandler();
	}, [to, from, user, genIdsLoading]);

	useEffect(() => {
		const fetchContainers = async () => {
			try {
				const containersRef = collection(db, COLLECTIONS.defaultPriceBook, "services", "containers");
				const snapshot = await getDocs(containersRef);

				const containersData = {};
				snapshot.forEach((doc) => {
					containersData[doc.id] = doc.data().labelOCTOFieldApp;
				});

				setContainersMap(containersData);
				console.log({ containersData });
			} catch (error) {
				console.error("Error fetching containers:", error);
			}
		};

		fetchContainers();
	}, []);

	useEffect(() => {
		const currentSelected = selectedRows.length;
		const total = filteredData.length;
		const allSelected = currentSelected === total && total > 0;
		const isIndeterminate = currentSelected > 0 && currentSelected < total;

		setSelectAll(allSelected);
		setIndeterminate(isIndeterminate);

		if (selectAllRef.current) {
			selectAllRef.current.indeterminate = isIndeterminate;
		}
	}, [selectedRows, filteredData]);

	useEffect(() => {
		const fetchDelContainers = async () => {
			try {
				const containersRef = collection(db, COLLECTIONS.defaultPriceBook, "products", "containers");
				const snapshot = await getDocs(containersRef);

				const containersData = {};
				snapshot.forEach((doc) => {
					containersData[doc.id] = doc.data().labelOCTOFieldApp;
				});

				setDelContainersMap(containersData);
			} catch (error) {
				console.error("Error fetching containers:", error);
			}
		};

		fetchDelContainers();
	}, []);

	const getSummaryData = (containers, transferredContainers = []) => {
		const summary = [];

		console.log({ sentContainers: containers });

		containers?.forEach((el, index) => {
			let container = transferredContainers.find((item) => item.containerType == el.containerType);
			console.log({ el, containerPriceBook, containers: transferredContainers });

			summary.push({
				...el,
				priceBookData: containerPriceBook[el.containerType] || null,
				cost: container?.wasteProcessingFees?.[el.subWasteType] || "",
			});
		});
		return summary;
	};

	const processDoc = async (serviceData) => {
		console.log("Before status", serviceData.status);

		const manifestDataRef = collection(db, COLLECTIONS.manifests);
		const manifestQuery = query(manifestDataRef, where("serviceId", "==", serviceData.id));
		const manifestRes = await getDocs(manifestQuery);
		let manifestData = manifestRes.docs.map((item) => ({ id: item.id, ...item.data() }));

		const containers = manifestData
			.map((item) => item.containers)
			.flat()
			.filter(Boolean);

		const containerDataRef = containers.map((id) => doc(db, COLLECTIONS.servicedContainers, id));
		const servicedContainerDocs = await Promise.all(containerDataRef.map((ref) => getDoc(ref)));
		const allServicedContainersData = servicedContainerDocs.map((doc) => ({ id: doc.id, ...doc.data() }));

		console.log({ allServicedContainersData, manifestData, serviceId: serviceData.id });

		const { transferStatus, transferredContainers } = await getTransferredContainers(
			allServicedContainersData,
			serviceData.id
		);

		serviceData.transferStatus = transferStatus;
		serviceData.transferredContainers = transferredContainers;

		const scheduleDataRef = doc(db, `${COLLECTIONS.serviceSchedules}/${serviceData.serviceScheduleId}`);
		const scheduleRes = await getDoc(scheduleDataRef);
		if (!scheduleRes.exists()) return;
		const scheduleData = scheduleRes.data();

		const serviceTypeString = getStringOfServiceTypes(scheduleData);
		const generatorDataRef = doc(db, `${COLLECTIONS.generators}/${serviceData.generatorId}`);
		const generatorRes = await getDoc(generatorDataRef);
		if (!generatorRes.exists()) return;
		const generatorData = generatorRes.data();

		const routeDataRef = doc(db, `${COLLECTIONS.routes}/${serviceData.routeId}`);
		const routeRes = await getDoc(routeDataRef);
		if (!routeRes.exists()) return;
		const routeData = routeRes.data();

		const transDataRef = collection(db, COLLECTIONS.deliveries);
		const transQuery = query(transDataRef, where("serviceId", "==", serviceData.id));
		const transRes = await getDocs(transQuery);
		let transData = transRes.docs.map((item) => ({ id: item.id, ...item.data() }));
		let deliverySummary = [];
		let deliveryReceipt = null;

		if (transData.length > 0) {
			deliveryReceipt = {
				deliveryId: transData?.[0]?.id,
				deliveryOctoId: transData?.[0]?.deliveryOctoId,
				url: transData?.[0]?.url,
			};
			let allDeliveredContainers = transData?.[0]?.containers;
			const delContainerRefs = allDeliveredContainers.map((item) => doc(db, COLLECTIONS.deliveredContainers, item));
			const delContainerDocs = await Promise.all(delContainerRefs.map((ref) => getDoc(ref)));
			deliverySummary = delContainerDocs.map((doc) => ({ id: doc.id, ...doc.data() }));
		}
		console.log({ serviceData });
		let serviceSummary = await getSummaryData(
			allServicedContainersData,
			serviceData.transferStatus === "COMPLETE" ? serviceData.transferredContainers : []
		);

		console.log("Service Status", serviceData, serviceSummary);

		return {
			id: serviceData.id,
			date: serviceData.date,
			completedAt: serviceData.completedAt,
			time: serviceData.date.toDate().toLocaleTimeString(),
			driverNote: serviceData?.driverNote?.length > 0 ? serviceData?.driverNote : "--",
			tempServiceIns: serviceData?.tempServiceIns,
			customerId: generatorDataRef.id,
			generatorId: generatorData.id,
			serviceId: serviceData.id,
			scheduleId: serviceData.serviceScheduleId,
			generatorName: `${generatorData?.generatorName ?? "--"} `,
			email: generatorData.serviceAddress?.email?.length ? generatorData.serviceAddress?.email : "--",
			phone: generatorData.serviceAddress?.phone?.length ? generatorData.serviceAddress?.phone : "",
			internalAccountNumber: generatorData.internalAccountNumber?.length ? generatorData.internalAccountNumber : "--",
			genId: generatorData.id,
			driverId: serviceData.assignedDriverId,
			deliveryId: transData.length > 0 ? transData?.[0].id : null,
			octoNumber: octoFormatter(generatorData.octoNumber) ?? "--",
			address: getFormattedAddress(generatorData?.serviceAddress),
			billed: Boolean(serviceData?.billed),
			billingMethod: serviceData?.billingMethod,
			billingNote: serviceData?.billingNote,
			billedDate: serviceData?.billedDate?.toDate()?.toLocaleDateString() ?? null,
			paidDate: serviceData?.paidDate?.toDate()?.toLocaleDateString() ?? null,
			approvedDate: serviceData?.approvedDate?.toDate()?.toLocaleDateString() ?? null,
			approvedNote: serviceData?.approvedNote,
			approved: serviceData?.approved ? true : false,
			paid: serviceData?.paid ?? false,
			adminNote: serviceData?.adminNote ?? "",
			paidAmount: serviceData?.paidAmount ?? "--",
			picture: Array.isArray(serviceData?.serviceImages) ? serviceData?.serviceImages : [],
			optionChecked: false,
			driverName: `${serviceData?.assignedDriverName ?? "--"}`,
			pickUpTruck: `${serviceData?.assignedServiceVehicleName ?? "--"}`,
			serviceType: serviceTypeString ?? "--",
			routeName: routeData?.routeLabel ?? "--",
			routeId: routeRes.id ?? "--",
			quantity: "--",
			totalWeight: "--",
			serviceVehicleId: serviceData.assignedServiceVehicleId,
			transporterId: user.uid,
			serviceStatus:
				serviceData?.status === SERVICE_STATUS.PENDING || serviceData?.status === SERVICE_STATUS.INPROGRESS
					? "UNLOGGED"
					: serviceData?.status === SERVICE_STATUS.COMPLETE
					? "COMPLETE"
					: serviceData?.status === SERVICE_STATUS.CLOSED || serviceData?.status === SERVICE_STATUS.CANCELLED
					? "Unavailable"
					: "",
			transferStatus: serviceData?.transferStatus,
			transferredContainers: serviceData.transferredContainers ?? [],
			serviceSummary,
			deliverySummary,
			deliveryReceipt,
			noWaste: serviceData?.noWaste,
			manifestData: manifestData?.filter(
				(manifest, index, self) => index === self.findIndex((m) => m.manifestOctoId === manifest.manifestOctoId)
			),
		};
	};

	const viewButtonHandler = async () => {
		if (!from) {
			showErrorToastMessage("Please select from date.");
			return;
		}
		if (!to) {
			showErrorToastMessage("Please select to date.");
			return;
		}

		setIsLoading(true);

		let today = new Date();
		let isFromToday =
			today.getDate() == from.getDate() &&
			today.getMonth() == from.getMonth() &&
			today.getFullYear() == from.getFullYear();
		let isToToday =
			today.getDate() == to.getDate() && today.getMonth() == to.getMonth() && today.getFullYear() == to.getFullYear();

		const utcFromDate = new Date(Date.UTC(from.getFullYear(), from.getMonth(), from.getDate(), 0, 0, 0, 0));
		const utcToDate = new Date(Date.UTC(to.getFullYear(), to.getMonth(), to.getDate(), 23, 59, 59, 999));

		console.log({ from, to, utcFromDate, utcToDate });

		try {
			const q = query(
				collection(db, COLLECTIONS.scheduledServices),
				where("date", ">=", utcFromDate),
				where("date", "<=", utcToDate),
				where("status", "!=", SERVICE_STATUS.DELETED),
				orderBy("date", "desc"),
				limit(pageSize)
			);

			if (unsubscribeServices) unsubscribeServices();

			const snapshotRes = await getDocs(q);
			const docs = snapshotRes.docs
				.map((doc) => ({ id: doc.id, ...doc.data() }))
				.filter((doc) => genIds.includes(doc.generatorId));

			// Process initial data immediately
			const processedDocs = await Promise.all(docs.map((doc) => processDoc(doc)));
			setCompleteServices(processedDocs);

			// Set up real-time subscriptions
			const unsubscribers = [];
			for (const docData of docs) {
				const docRef = doc(db, COLLECTIONS.scheduledServices, docData.id);
				const unsubscribe = onSnapshot(docRef, async (snap) => {
					if (!snap.exists()) return;
					const updatedDoc = { id: snap.id, ...snap.data() };
					if (!genIds.includes(updatedDoc.generatorId)) return;
					const processed = await processDoc(updatedDoc);
					setCompleteServices((prev) => {
						const existing = prev.find((s) => s.id === processed.id);
						return existing ? prev : [...prev, processed];
					});
				});
				unsubscribers.push(unsubscribe);
			}

			setUnsubscribeServices(() => () => unsubscribers.forEach((unsub) => unsub()));
			setLastVisibleDoc(snapshotRes.docs[snapshotRes.docs.length - 1]);
			setHasMore(snapshotRes.docs.length >= pageSize);
		} catch (error) {
			console.error("Error fetching services:", error);
			toast.error("Failed to load services.");
		} finally {
			setIsLoading(false);
			setSelectedRows([]);
		}
	};

	const loadMore = async () => {
		// Don't execute if there's no pagination marker or more data
		if (!lastVisibleDoc || !hasMore) return;

		// Set loading state
		setIsLoading(true);

		try {
			// Convert local dates to UTC for Firestore query
			const utcFromDate = new Date(Date.UTC(from.getFullYear(), from.getMonth(), from.getDate(), 0, 0, 0, 0));
			const utcToDate = new Date(Date.UTC(to.getFullYear(), to.getMonth(), to.getDate(), 23, 59, 59, 999));

			// Create paginated query
			const q = query(
				collection(db, COLLECTIONS.scheduledServices),
				where("date", ">=", utcFromDate),
				where("date", "<=", utcToDate),
				where("status", "!=", SERVICE_STATUS.DELETED),
				orderBy("date", "desc"),
				startAfter(lastVisibleDoc),
				limit(pageSize)
			);

			// Execute query
			const snap = await getDocs(q);

			// Filter documents based on generator IDs
			const newDocs = snap.docs
				.map((doc) => ({ id: doc.id, ...doc.data() }))
				.filter((doc) => genIds.includes(doc.generatorId));

			// Process documents in parallel
			const processedNewDocs = await Promise.all(
				newDocs.map(async (doc) => {
					// Add real-time listener for each document
					const docRef = doc(db, COLLECTIONS.scheduledServices, doc.id);
					const unsubscribe = onSnapshot(docRef, async (snap) => {
						if (!snap.exists()) return;
						const updatedDoc = { id: snap.id, ...snap.data() };
						if (!genIds.includes(updatedDoc.generatorId)) return;

						const processed = await processDoc(updatedDoc);
						setCompleteServices((prev) => {
							const existing = prev.find((s) => s.id === processed.id);
							return existing ? prev : [...prev, processed];
						});
					});

					// Store unsubscribe function
					setUnsubscribeServices((prev) => {
						const newSubs = [...(prev?.current || []), unsubscribe];
						return { current: newSubs };
					});

					// Return initial processed document
					return processDoc(doc);
				})
			);

			// Update state with new documents
			setCompleteServices((prev) => [...prev, ...processedNewDocs]);

			// Update pagination markers
			setLastVisibleDoc(snap.docs[snap.docs.length - 1]);
			setHasMore(snap.docs.length >= pageSize);
		} catch (error) {
			console.error("Error loading more services:", error);
			toast.error("Failed to load more services. Please try again.");
		} finally {
			// Always reset loading state
			setIsLoading(false);
		}
	};

	useEffect(() => {
		return () => {
			if (unsubscribeServices) unsubscribeServices();
		};
	}, [unsubscribeServices]);

	const normalizedSearchQuery = searchQuery.toLowerCase().replace(/\s+/g, "");
	const getSortDate = (item) => {
		const d = item.completedAt ?? item.date;
		return d instanceof Date ? d.getTime() : d?.toDate?.()?.getTime?.() ?? 0;
	};

	useEffect(() => {
		startTransition(() => {
			let matchedServices = completeServices.filter((data) =>
				[data.generatorName, data.phone, data.email, data.address, data.octoNumber, data.internalAccountNumber].some(
					(field) => field?.toString()?.toLowerCase().replace(/\s+/g, "").includes(normalizedSearchQuery)
				)
			);
			matchedServices = matchedServices.filter((item) =>
				selectedServices.includes("all") ? true : selectedServices.includes(item.serviceType)
			);
			console.log({ matchedServices, selectedServices });
			matchedServices = matchedServices.filter((item) =>
				selectedDrivers.includes("all") ? true : selectedDrivers.includes(item.driverName)
			);
			console.log({ matchedServices, selectedDrivers });
			matchedServices = matchedServices.filter((item) =>
				selectedRoutes.includes("all") ? true : selectedRoutes.includes(item.routeId)
			);
			console.log({ matchedServices, selectedRoutes });
			matchedServices = selectedTransStatusOptions.includes("all")
				? matchedServices
				: matchedServices.filter((item) =>
						selectedTransStatusOptions.includes(
							item.transferStatus == transferStatusType.COMPLETE
								? transferStatusType.COMPLETE
								: transferStatusType.ON_TRUCK
						)
				  );
			matchedServices = selectedServiceStatusOptions.includes("all")
				? matchedServices
				: matchedServices.filter((item) => selectedServiceStatusOptions.includes(item.serviceStatus));
			console.log({ matchedServices, selectedTransStatusOptions });

			matchedServices = matchedServices
				.sort((a, b) => {
					const aDate = getSortDate(a);
					const bDate = getSortDate(b);
					return bDate - aDate;
				})
				.filter((item) => processDateWise(item));

			setFilteredData(matchedServices);
			setNewContainers([]);
			setNewDelContainers([]);
			setIsLoading(false);
		});
	}, [
		completeServices,
		selectedDrivers,
		selectedPickupOptions,
		selectedServices,
		selectedRoutes,
		selectedTransStatusOptions,
		searchQuery,
		selectedServiceStatusOptions,
	]);

	const processDateWise = (item) => {
		let date = item.date?.toDate();
		let today = new Date();
		let todayD = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);
		let dateF = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);

		console.log({ todayD, dateF });

		if (dateF >= todayD) {
			if (item.completedAt) return true;
			else return false;
		} else {
			return true;
		}
	};

	const fetchAllRoutesOptions = async () => {
		try {
			const resp = await getAllRoutes(user?.uid);
			const options = [];
			let map = {};
			resp
				?.filter((route) => route.status == "ACTIVE")
				.map((item) => {
					options.push({
						label: item.routeLabel,
						value: item.id,
					});
					map[item.id] = item.routeLabel;
				});
			setRouteOptions([{ label: "All", value: "all" }, ...options]);
			setServiceTypeOptions([{ label: "All", value: "all" }, ...serviceTypes]);
			setSelectedServices(["all", ...serviceTypes.map((item) => item.value)]);
			setSelectedRoutes(["all", ...options.map((item) => item.value)]);
		} catch (error) {
			console.log("Error fetching routes", error);
		}
	};

	useEffect(() => {
		if (user) {
			fetchAllDriverOptions();
			fetchAllRoutesOptions();
			fetchAllTransferOptions();
			fetchAllServiceVehicleOptions();
		}
	}, [user]);

	console.log({ isLoading, isFiltering, filteredData });

	const handleBillingCheckbox = async (isChecked, serviceId, statusUpdateReason = "") => {
		let docRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
		console.log({ isChecked, serviceId, statusUpdateReason });

		let toUpdate = {
			billed: isChecked,
			billedDate: isChecked ? Timestamp.now() : null,
			billingMethod: isChecked ? "internal" : "",
			billingNote: isChecked ? "Invoiced Through External Billing Platform" : "",
			statusUpdateReason: arrayUnion({
				statusUpdateReason,
				by: user.userId ?? "",
			}),
		};

		try {
			await updateDoc(docRef, toUpdate);
			setCompleteServices((prevServices) =>
				prevServices.map((service) =>
					service.id === serviceId
						? {
								...service,
								...toUpdate,
								billedDate: isChecked ? Timestamp.now()?.toDate()?.toLocaleDateString() : null,
						  }
						: service
				)
			);

			toast.success(isChecked ? "Invoiced Through External Billing Platform!" : "Billing status updated.");
		} catch (error) {
			console.error("Error updating billing status:", error);
			toast.error("Failed to update billing status.");
		}
	};

	const handlePaidCheckbox = async (isChecked, serviceId, statusUpdateReason = "") => {
		let docRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
		console.log({ isChecked, serviceId, statusUpdateReason });

		let toUpdate = {
			paid: isChecked ? true : false,
			paidDate: isChecked ? Timestamp.now() : null,
			billingNote: isChecked ? "Payment recorded." : "",
			statusUpdateReason: arrayUnion({
				statusUpdateReason,
				by: user.userId ?? "",
			}),
		};

		try {
			await updateDoc(docRef, toUpdate);
			setCompleteServices((prevServices) =>
				prevServices.map((service) =>
					service.id === serviceId
						? {
								...service,
								...toUpdate,
								paidDate: isChecked ? Timestamp.now()?.toDate()?.toLocaleDateString() : null,
						  }
						: service
				)
			);

			toast.success(isChecked ? "Payment marked as complete!" : "Payment status updated.");
		} catch (error) {
			console.error("Error updating payment status:", error);
			toast.error("Failed to update payment status.");
		}
	};
	const handleApprovedCheckbox = async (isChecked, serviceId, statusUpdateReason = "") => {
		let docRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
		console.log({ isChecked, serviceId, statusUpdateReason });

		let toUpdate = {
			approved: isChecked,
			approvedDate: isChecked ? Timestamp.now() : null,
			approvedNote: isChecked ? "Service approved." : "",
			statusUpdateReason: arrayUnion({
				statusUpdateReason,
				by: user.userId ?? "",
			}),
		};

		try {
			await updateDoc(docRef, toUpdate);
			setCompleteServices((prevServices) =>
				prevServices.map((service) =>
					service.id === serviceId
						? {
								...service,
								...toUpdate,
								approvedDate: isChecked ? Timestamp.now()?.toDate()?.toLocaleDateString() : null,
						  }
						: service
				)
			);

			toast.success(isChecked ? "Payment marked as complete!" : "Payment status updated.");
		} catch (error) {
			console.error("Error updating payment status:", error);
			toast.error("Failed to update payment status.");
		}
	};

	const handleSelectAll = () => {
		if (selectedRows.length === filteredData.length) {
			setSelectedRows([]);
		} else {
			const allIds = filteredData.map((service) => service.id);
			setSelectedRows(allIds);
		}
	};

	const handleRowCheckbox = (e, serviceId) => {
		const isChecked = e.target.checked;
		setSelectedRows((prev) => (isChecked ? [...prev, serviceId] : prev.filter((id) => id !== serviceId)));
	};

	const handleEditClick = (serviceId, section) => {
		setEditing({ serviceId, section, consentAcceptance: false });
		const service = JSON.parse(JSON.stringify(filteredData.find((s) => s.id === serviceId)));
		setEditedData({
			serviceSummary: sortedServiceSummary([...service.serviceSummary]),
			deliverySummary: [...service.deliverySummary],
		});
		setNewContainers([]);
		setNewDelContainers([]);
	};

	const handleFieldChange = (serviceId, section, index, field, value, containerId) => {
		console.log({ serviceId, section, index, field, value, containerId });
		const newData = [...editedData[section]].map((item) => {
			if (item.id === containerId) {
				return { ...item, [field]: value };
			} else if (item.tempId === containerId) {
				return { ...item, [field]: value };
			}
			return item;
		});
		setEditedData((prev) => ({ ...prev, [section]: newData }));
	};

	const handleSubWasteTypeChange = async (serviceId, section, index, field, value, group) => {
		const newData = [...editedData[section]];
		newData[index][field] = value;
		let resp = await fetchContainerData(value);
		console.log({ field, value, resp, group, containersMap, containerPriceBook });
		newData[index]["subWasteType"] = resp.subWasteType;
		setEditedData((prev) => ({ ...prev, [section]: newData }));
	};

	const formatDateToMMDDYYYY = (date, timezone = "America/New_York") => {
		const zonedDate = dateFnsTz.formatInTimeZone(date, timezone, "MMddyyyy");
		return zonedDate;
	};

	const createManifestId = (transporterOctoId, generatorOctoId, serviceDate) => {
		let dateString = formatDateToMMDDYYYY(serviceDate.toDate(), "America/New_York");
		let manifestCount = 0;
		return `M-${transporterOctoId.slice(2, 6)}-${generatorOctoId.replace(/\D/g, "")}-${dateString}-${manifestCount
			.toString()
			.padStart(2, "0")}`;
	};

	const handleSave = async (serviceId) => {
		const serviceRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
		const batch = writeBatch(db);
		const service = completeServices.find((s) => s.id === serviceId);
		console.log("service", service);
		try {
			let subWasteGroups = {};
			let oldSubWasteGroups = {};
			let newManifests = [];
			const newContainerIds = [];
			const deletedManifestIds = [];

			console.log({ newContainers, newDelContainers });

			if (editing.section === "service") {
				let newItemWithInvalidVal = newContainers.find(
					(item) => !item.containerType || item.containerType == "" || !Number(item.quantity)
				);
				if (newItemWithInvalidVal) {
					if (newItemWithInvalidVal.containerType == "") {
						toast.error("Container Type is required");
						return;
					}
					if (!Number(newItemWithInvalidVal.quantity)) {
						toast.error("Quantity must be non-zero value");
						return;
					}
				}
				console.log({ editedData });
				let itemWithInvalidVal = editedData.serviceSummary.find(
					(item) => !item.containerType || item.containerType == "" || !Number(item.quantity)
				);
				if (itemWithInvalidVal) {
					if (itemWithInvalidVal.containerType == "") {
						toast.error("Container Type is required");
						return;
					}
					if (!Number(itemWithInvalidVal.quantity)) {
						toast.error("Quantity must be non-zero value");
						return;
					}
				}
				const serviceUpdate = {
					consolidated: editedData.serviceSummary
						.filter((item) => item.serviceType === "CONSOLIDATED")
						.map(({ serviceType, _index, ...rest }) => rest),
					itemized: editedData.serviceSummary
						.filter((item) => item.serviceType === "ITEMIZED")
						.map(({ serviceType, _index, ...rest }) => rest),
				};

				let newContainerss = [];

				// Process Old Containers (Means containers having firestore doc ID)
				await Promise.all(
					editedData.serviceSummary.map(async (item) => {
						if (!item.id) {
							newContainerss.push(item);
							return;
						}
						const containerRef = doc(db, COLLECTIONS.servicedContainers, item.id);
						const containerDoc = await getDoc(containerRef);
						const containerData = containerDoc.data();
						console.log({ containerDoc, containerData });
						const oldSWT = containerData?.subWasteType;
						const newSWT = item.subWasteType;
						batch.update(containerRef, {
							quantity: Number(item.quantity) || 0,
							weight: Number(item.weight) || 0,
							subWasteType: newSWT,
							containerType: item.containerType,
						});
						subWasteGroups[newSWT] = [...(subWasteGroups[newSWT] || []), containerRef.id];
						if (oldSWT !== newSWT) {
							oldSubWasteGroups[oldSWT] = [...(oldSubWasteGroups[oldSWT] || []), containerRef.id];
						}
					})
				);

				console.log({ newContainerss });
				// Processing NEW containers
				for (let i = 0; i < newContainerss.length; i++) {
					const containerRef = doc(collection(db, COLLECTIONS.servicedContainers));
					const newContainer = {
						...newContainerss[i],
						id: containerRef.id,
						serviceId,
						driverId: service.driverId,
						generatorId: service.generatorId,
						routeId: service.routeId,
						scheduleId: service.scheduleId,
						serviceVehicleId: service.serviceVehicleId,
						transporterId: service.transporterId,
						transferStatus: service.transferStatus ?? transferStatusType.ON_TRUCK,
						createdAt: Timestamp.now(),
						updatedAt: Timestamp.now(),
					};
					newContainerss[i] = newContainer;
					newContainerIds.push(containerRef.id);
					batch.set(containerRef, newContainer);
					const swt = newContainer.subWasteType;
					subWasteGroups[swt] = [...(subWasteGroups[swt] || []), containerRef.id];
				}

				// Removing containers from old manifests
				Object.entries(oldSubWasteGroups).forEach(([oldSWT, containerIds]) => {
					const oldManifest = service.manifestData.find((m) => m.subWasteType === oldSWT);
					if (oldManifest) {
						const manifestRef = doc(db, COLLECTIONS.manifests, oldManifest.id);
						const originalContainers = oldManifest.containers || [];
						const remainingContainers = originalContainers.filter((id) => !containerIds.includes(id));
						if (remainingContainers.length === 0) {
							batch.delete(manifestRef);
							deletedManifestIds.push(oldManifest.id);
						} else {
							batch.update(manifestRef, {
								containers: arrayRemove(...containerIds),
								updatedAt: Timestamp.now(),
								isEdited: true,
								url: null,
							});
						}
					}
				});
				// Add/update for new manifests
				let sampleManifest = service.manifestData?.[0];
				console.log({ sampleManifest });
				if (!sampleManifest) {
					sampleManifest = {
						driverId: service.driverId,
						generatorId: service.generatorId,
						routeId: service.routeId,
						scheduleId: service.scheduleId,
						serviceVehicleId: service.serviceVehicleId,
						transporterId: service.transporterId,
						manifestOctoId: createManifestId(transporterData?.transporterOctoId, service.octoNumber, service.date),
					};
				}

				console.log({ sampleManifest });
				Object.entries(subWasteGroups).forEach(([newSWT, containerIds]) => {
					const existingManifest = service.manifestData.find((m) => m.subWasteType === newSWT);
					if (existingManifest) {
						const manifestRef = doc(db, COLLECTIONS.manifests, existingManifest.id);
						batch.update(manifestRef, {
							containers: arrayUnion(...containerIds),
							updatedAt: Timestamp.now(),
							isEdited: true,
							url: null,
						});
					} else {
						const existingManifestOctoIds = service.manifestData.map((m) => m.manifestOctoId);
						const maxSuffix = existingManifestOctoIds.reduce((max, octoId) => {
							const parts = octoId.split("-");
							const suffix = parseInt(parts[parts.length - 1], 10);
							return suffix > max ? suffix : max;
						}, 0);
						const newSuffix = String(maxSuffix + 1).padStart(2, "0");
						console.log({ newSuffix, maxSuffix, existingManifestOctoIds });

						const baseManifestId = sampleManifest.manifestOctoId.split("-").slice(0, -1).join("-");
						const newManifestOctoId = `${baseManifestId}-${newSuffix}`;
						console.log({ baseManifestId, newManifestOctoId });

						const newManifestRef = doc(collection(db, COLLECTIONS.manifests));
						const newManifestData = {
							...(sampleManifest && {
								driverId: sampleManifest.driverId,
								generatorId: sampleManifest.generatorId,
								routeId: sampleManifest.routeId,
								scheduleId: sampleManifest.scheduleId,
								serviceVehicleId: sampleManifest.serviceVehicleId,
								transporterId: sampleManifest.transporterId,
							}),
							subWasteType: newSWT,
							containers: containerIds,
							serviceId: service.id,
							manifestOctoId: newManifestOctoId,
							createdAt: Timestamp.now(),
							updatedAt: Timestamp.now(),
							isEdited: true,
							url: null,
						};
						batch.set(newManifestRef, newManifestData);
						newManifests.push({ ...newManifestData, id: newManifestRef.id });
					}
				});
				serviceUpdate.manifestData = [
					...service.manifestData.filter((m) => !subWasteGroups[m.subWasteType]),
					...newManifests.map(({ id, subWasteType }) => ({ id, subWasteType })),
				];
				const newConsolidated = [];
				const newItemized = [];

				newContainerss.forEach((c, idx) => {
					const newEntry = {
						...c,
						id: newContainerIds[idx],
					};

					if (newEntry.serviceType === "ITEMIZED") {
						newItemized.push(newEntry);
					} else {
						newConsolidated.push(newEntry);
					}
				});

				serviceUpdate.consolidated = [...serviceUpdate.consolidated, ...newConsolidated];

				serviceUpdate.itemized = [...serviceUpdate.itemized, ...newItemized];
				if (service.status !== SERVICE_STATUS.COMPLETE) {
					serviceUpdate.status = SERVICE_STATUS.COMPLETE;
					serviceUpdate.completedAt = Timestamp.now();
				}
				console.log({ serviceUpdate });
				if (service.noWaste) serviceUpdate.noWaste = service.noWaste;
				batch.update(serviceRef, serviceUpdate);
				await batch.commit();
				setCompleteServices((prev) =>
					prev.map((s) => {
						if (s.id !== serviceId) return s;
						const updatedManifests = [
							...s.manifestData.map((m) => {
								if (subWasteGroups[m.subWasteType]) {
									return {
										...m,
										containers: [...new Set([...m.containers, ...subWasteGroups[m.subWasteType]])],
										url: null,
									};
								}
								return m;
							}),
							...newManifests.filter((nm) => !s.manifestData.some((m) => m.subWasteType === nm.subWasteType)),
						];
						return {
							...s,
							serviceSummary: [
								...editedData.serviceSummary.filter((item) => item.id),
								...newContainerss.map((c) => ({
									...c,
									id: newContainerIds.shift(),
								})),
							],

							manifestData: updatedManifests.filter((m) => m.containers?.length > 0),
						};
					})
				);
				// Updating filteredData
				setFilteredData((prev) =>
					prev.map((s) => (s.id === serviceId ? completeServices.find((cs) => cs.id === serviceId) : s))
				);

				// return;
			}

			if (editing.section === "delivery") {
				console.log({ delId: service?.deliveryId });
				let invalidContainer = newDelContainers.find(
					(item) => !item.containerType || item.containerType == "" || !item.type || !Number(item.quantity)
				);
				if (invalidContainer) {
					if (invalidContainer.containerType == "") {
						toast.error("Container is required");
						return;
					}
					if (invalidContainer.type == "") {
						toast.error("Usage is required");
						return;
					}
					if (!Number(invalidContainer.quantity)) {
						toast.error("Quantity must be non-zero value");
						return;
					}
				}

				let itemWithInvalidVal = editedData.deliverySummary.find(
					(item) => !item.containerType || item.containerType == "" || !item.type || !Number(item.quantity)
				);
				if (itemWithInvalidVal) {
					if (!Number(itemWithInvalidVal.quantity)) {
						toast.error("Quantity must be non-zero value");
					}
					return;
				}

				const newDelContainerIds = [];
				let deliveryRef,
					deliveryDoc,
					deliveryCount = 0;

				if (!service?.deliveryId) {
					// Create a new delivery document
					deliveryRef = doc(collection(db, COLLECTIONS.deliveries));
					deliveryDoc = {
						id: deliveryRef.id,
						generatorId: service.generatorId,
						routeId: service.routeId,
						scheduleId: service.scheduleId,
						serviceId: service.serviceId,
						transporterId: service.transporterId,
						driverId: service.driverId,
						serviceVehicleId: service.serviceVehicleId,
						createdAt: Timestamp.now(),
						date: service?.completedAt ?? Timestamp.now(),
						updatedAt: Timestamp.now(),
						containers: [],
					};

					batch.set(deliveryRef, deliveryDoc);
				} else {
					// Fetch existing delivery document
					deliveryRef = doc(db, COLLECTIONS.deliveries, service.deliveryId);
					const deliverySnap = await getDoc(deliveryRef);

					if (deliverySnap.exists()) {
						deliveryDoc = { id: deliverySnap.id, ...deliverySnap.data() };
					} else {
						return toast.error("Couldn't find any delivery for this service");
					}
				}

				deliveryCount = deliveryDoc.containers.length;

				// Fetch existing delivery containers
				const existingContainerDocs = [];
				if (deliveryDoc.containers.length > 0) {
					const existingContainersQuery = query(
						collection(db, COLLECTIONS.deliveredContainers),
						where(documentId(), "in", deliveryDoc.containers)
					);
					const existingContainersSnap = await getDocs(existingContainersQuery);
					existingContainersSnap.forEach((doc) => {
						existingContainerDocs.push({ id: doc.id, ...doc.data() });
					});
				}

				let updatedContainers = newDelContainers.map((newContainer, index) => {
					let existingContainer = existingContainerDocs.find((c) => c.containerType === newContainer.containerType);

					if (existingContainer) {
						// UPDATE existing container
						batch.update(doc(db, COLLECTIONS.deliveredContainers, existingContainer.id), {
							...existingContainer,
							quantity: newContainer.quantity,
							weight: newContainer.weight,
							updatedAt: Timestamp.now(),
						});
						return { ...existingContainer, quantity: newContainer.quantity, weight: newContainer.weight };
					} else {
						const containerRef = doc(collection(db, COLLECTIONS.deliveredContainers));
						newDelContainerIds.push(containerRef.id);

						const newContainerData = {
							...newContainer,
							updatedAt: Timestamp.now(),
							createdAt: Timestamp.now(),
							generatorId: service.generatorId,
							deliveryId: deliveryRef.id,
							routeId: service.routeId,
							scheduleId: service.scheduleId,
							serviceId: service.serviceId,
							serviceStatus: "COMPLETE",
							serviceVehicleId: service.serviceVehicleId,
							transporterId: service.transporterId,
						};

						batch.set(containerRef, newContainerData);
						return newContainerData;
					}
				});

				setNewDelContainers(updatedContainers);

				if (newDelContainerIds.length > 0) {
					batch.update(deliveryRef, {
						containers: arrayUnion(...newDelContainerIds),
						driverId: service.driverId,
						updatedAt: Timestamp.now(),
						url: "",
					});
				}

				const serviceRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
				batch.update(serviceRef, { status: SERVICE_STATUS.COMPLETE });
				await batch.commit();

				setCompleteServices((prev) =>
					prev.map((s) =>
						s.id === serviceId
							? {
									...s,
									deliverySummary: [
										...s.deliverySummary,
										...updatedContainers.map((c, index) => ({ ...c, id: newDelContainerIds[index] || c.id })),
									],
									deliveryId: deliveryDoc.id,
									deliveryReceipt: {
										deliveryId: deliveryDoc.id,
										deliveryOctoId: deliveryDoc.deliveryOctoId,
										url: "",
									},
							  }
							: s
					)
				);

				setFilteredData((prev) =>
					prev.map((s) =>
						s.id === serviceId
							? {
									...s,
									deliverySummary: [
										...s.deliverySummary,
										...updatedContainers.map((c, index) => ({ ...c, id: newDelContainerIds[index] || c.id })),
									],
									deliveryId: deliveryDoc.id,
									deliveryReceipt: {
										deliveryId: deliveryDoc.id,
										deliveryOctoId: deliveryDoc.deliveryOctoId,
										url: "",
									},
							  }
							: s
					)
				);
			}

			setNewContainers([]);
			setNewDelContainers([]);
			setEditing({ serviceId: null, section: null, consentAcceptance: false });
			toast.success("Changes saved successfully!");
		} catch (error) {
			setCompleteServices((prev) => prev.map((s) => (s.id === serviceId ? service : s)));
			setFilteredData((prev) => prev.map((s) => (s.id === serviceId ? service : s)));
			console.error("Error saving changes:", error);
			toast.error("Failed to save changes");
		}
	};

	const fetchContainerData = async (containerType = null) => {
		if (!containerType) return {};
		try {
			const docRef = doc(db, COLLECTIONS.defaultPriceBook, "services", "containers", containerType);
			const docSnap = await getDoc(docRef);

			let docData = { id: docSnap.id, ...docSnap.data() };

			return docData;
		} catch (error) {
			console.error("Error fetching containers:", error);
		}
	};

	const handleAddNewContainer = async (serviceId) => {
		let containerData = editedData.serviceSummary?.[0];
		setNewContainerData({
			subWasteType: "",
			containerType: "",
			quantity: 1,
			weight: 0,
			rate: 0,
			total: 0,
			cost: 0,
			serviceType: containerData?.serviceType ?? "",
		});
		setShowAddContainerModal(true);
	};

	const handleAddNewDelContainer = async (serviceId) => {
		setNewDelContainers([
			...newDelContainers,
			{
				tempId: Date.now(),
				containerType: "",
				type: "",
				quantity: 1,
			},
		]);
	};

	const handleNewDelContainerChange = (tempId, field, value) => {
		setNewDelContainers(
			newDelContainers.map((container) => (container.tempId === tempId ? { ...container, [field]: value } : container))
		);
	};

	const handleDeleteContainer = async (serviceId, containerId) => {
		let toDeleteService = filteredData.find((item) => item.id == serviceId);
		if (toDeleteService?.serviceSummary?.length === 1) {
			toast.warn("All the containers cannot be removed!");
			return;
		}

		console.log("Deleting ", {
			serviceId,
			containerId,
			editedData,
			editing,
			toDeleteService: toDeleteService?.serviceSummary,
		});

		// Find the container to delete
		let container = toDeleteService?.serviceSummary?.find((item) => item.id === containerId);

		if (!container) {
			setEditedData((prev) => ({
				...prev,
				serviceSummary: prev.serviceSummary.filter((item) => item.tempId !== containerId),
			}));
			setIsDeleting(null);
			return;
		}

		try {
			toast.loading("Deleting container...");
			if (containerId && serviceId) {
				const batch = writeBatch(db);

				// Delete the container from `servicedContainers`
				batch.delete(doc(db, COLLECTIONS.servicedContainers, containerId));

				// Find the associated manifest
				const manifestQuery = query(
					collection(db, COLLECTIONS.manifests),
					where("containers", "array-contains", containerId)
				);
				const manifestSnap = await getDocs(manifestQuery);

				console.log("====================================");
				console.log({ ManifestEmpty: manifestSnap.empty, containerId });
				console.log("====================================");

				if (!manifestSnap.empty) {
					console.log("Manifest found");

					const manifestRef = doc(db, COLLECTIONS.manifests, manifestSnap.docs[0].id);
					const manifestData = manifestSnap.docs[0].data();

					console.log({ containerId, manifestData });

					batch.update(manifestRef, {
						containers: arrayRemove(containerId),
						isEdited: true,
						updatedAt: new Date(),
						url: null,
					});

					// If the manifest is left with no containers, delete it
					if (manifestData?.containers?.length === 1) {
						batch.delete(manifestRef);
						console.log(`Manifest with ID ${manifestSnap.docs[0].id} is now empty and will be deleted.`);
					}
				}

				// Updating `scheduledServices` document
				const serviceRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
				const serviceSnap = await getDoc(serviceRef);
				if (!serviceSnap.exists()) {
					toast.error("Something went wrong while deleting the container");
					throw new Error(`Service ${serviceId} not found`);
				}

				const serviceUpdate = serviceSnap.data();
				const updatedContainers = serviceUpdate?.consolidated
					? serviceUpdate.consolidated.filter((item) => item.id !== containerId)
					: [];
				const updatedItemized = serviceUpdate?.itemized
					? serviceUpdate.itemized.filter((item) => item.id !== containerId)
					: [];

				console.log({ serviceUpdate, updatedContainers, containerId });

				batch.update(serviceRef, {
					consolidated: updatedContainers,
					itemized: updatedItemized,
				});

				await batch.commit();
				console.log("Batch commit successful!");

				// Updating local state after deletion
				setCompleteServices((prev) => {
					let updated = prev.map((service) =>
						service.id === serviceId
							? {
									...service,
									serviceSummary: service.serviceSummary.filter((c) => c.id !== containerId),
									manifestData: service.manifestData
										.map((manifest) => {
											let containerData = manifest.containers.filter((id) => id !== containerId);
											if (containerData.length === 0) return null;
											return {
												...manifest,
												containers: containerData,
											};
										})
										.filter(Boolean),
							  }
							: service
					);
					console.log("Updated completeServices:", updated);
					return updated;
				});

				setFilteredData((prev) => {
					let updated = prev.map((service) =>
						service.id === serviceId
							? {
									...service,
									serviceSummary: service.serviceSummary.filter((c) => c.id !== containerId),
									manifestData: service.manifestData
										.map((manifest) => {
											let containerData = manifest.containers.filter((id) => id !== containerId);
											if (containerData.length === 0) return null;
											return {
												...manifest,
												containers: containerData,
											};
										})
										.filter(Boolean),
							  }
							: service
					);
					console.log("Updated filteredData:", updated);
					return updated;
				});

				setEditedData((prev) => {
					if (!prev?.serviceSummary) return prev;
					let newServiceSummary = prev.serviceSummary.filter((item) => item.id !== containerId);
					console.log("Updated editedData:", { ...prev, serviceSummary: newServiceSummary });
					return { ...prev, serviceSummary: sortedServiceSummary(newServiceSummary) };
				});

				toast.dismiss();
				setIsDeleting(null);
				toast.success("Container deleted successfully!");
			}
		} catch (error) {
			console.error("Error deleting container:", error);
			toast.dismiss();
			toast.error("Failed to delete container.");
		}
	};

	const handleDeleteDelContainer = async (serviceId, containerId) => {
		toast.loading("Deleting container...");
		let toDeleteService = filteredData.find((item) => item.id == serviceId);

		if (toDeleteService.deliverySummary?.length == 1) {
			toast.warn("All the containers cannot be removed!");
			return;
		}

		try {
			const batch = writeBatch(db);
			console.log("Deleting ", serviceId, containerId);

			batch.delete(doc(db, COLLECTIONS.deliveredContainers, containerId));
			const deliveryRef = doc(db, COLLECTIONS.deliveries, toDeleteService.deliveryId);
			const deliverySnap = await getDoc(deliveryRef);

			if (deliverySnap.exists()) {
				const deliveryData = deliverySnap.data();
				const updatedContainers = deliveryData.containers.filter((id) => id !== containerId);

				if (updatedContainers.length === 0) {
					batch.delete(deliveryRef);
					console.log(`Delivery with ID ${toDeleteService.deliveryId} is now empty and will be deleted.`);
				} else {
					batch.update(deliveryRef, {
						containers: arrayRemove(containerId),
						url: "",
					});
				}
			}

			await batch.commit();

			setCompleteServices((prev) =>
				prev.map((service) =>
					service.id === serviceId
						? {
								...service,
								deliverySummary: service.deliverySummary.filter((c) => c.id !== containerId),
								deliveryReceipt: { ...service.deliveryReceipt, url: "" },
						  }
						: service
				)
			);

			setFilteredData((prev) =>
				prev.map((service) =>
					service.id === serviceId
						? {
								...service,
								deliverySummary: service.deliverySummary.filter((c) => c.id !== containerId),
								deliveryReceipt: { ...service.deliveryReceipt, url: "" },
						  }
						: service
				)
			);

			setEditedData((prev) => {
				let newDeliverySummary = prev.deliverySummary.filter((item) => item.id != containerId);
				return { ...prev, deliverySummary: newDeliverySummary };
			});
			toast.dismiss();
			setIsDeleting(null);
			toast.success("Container deleted successfully!");
		} catch (error) {
			console.error("Error deleting container:", error);
			toast.dismiss();
			toast.error("Failed to delete container.");
		}
	};

	console.log("====================================");
	console.log({ completeServices, containersMap, filteredData, editedData });
	console.log("====================================");

	const groupContainers = (containers, manifests) => {
		return containers.reduce((groups, container) => {
			const key = container.subWasteType;
			if (!groups[key]) {
				groups[key] = {
					containers: [],
					manifest: manifests.find((m) => m.subWasteType === key) || {},
					subtotal: { quantity: 0, weight: 0, total: 0 },
				};
			}
			groups[key].containers.push(container);
			groups[key].subtotal.quantity += Number(container.quantity);
			groups[key].subtotal.weight += Number(container.weight);
			groups[key].subtotal.total += Number(container.quantity) * Number(container.rate);
			return groups;
		}, {});
	};

	const totalCountData = useMemo(() => {
		let totalCounts = {};

		filteredData.forEach((item) => {
			item.serviceSummary?.forEach((container) => {
				const { subWasteType, quantity, weight } = container;

				if (subWasteType === undefined) return;

				const qty = Number(quantity);
				const wgt = Number(weight);

				if (isNaN(qty) || isNaN(wgt)) return;

				totalCounts[subWasteType] = totalCounts[subWasteType] || {
					quantity: 0,
					weight: 0,
				};
				totalCounts[subWasteType].quantity += qty;
				totalCounts[subWasteType].weight += wgt;
			});
		});
		Object.keys(totalCounts).forEach((key) => {
			const { quantity, weight } = totalCounts[key];
			if (isNaN(quantity) || isNaN(weight)) {
				delete totalCounts[key];
			}
		});

		return totalCounts;
	}, [filteredData]);

	return (
		<div
			style={{ height: selectedRows.length > 0 ? `calc(100% - 60px)` : "100%" }}
			className={`flex flex-col border-cardBorderCol overflow-clip bg-white rounded-cardRadii`}
		>
			<div className="h-fit">
				<div className="text-lg font-medium px-8 py-4 text-black">Service History Report</div>
				<FilterComp
					to={to}
					from={from}
					setTo={setTo}
					setFrom={setFrom}
					searchQuery={searchQuery}
					routeOptions={routeOptions}
					driverOptions={driverOptions}
					selectedRoutes={selectedRoutes}
					setSearchQuery={setSearchQuery}
					selectedDrivers={selectedDrivers}
					selectedServices={selectedServices}
					contractorOptions={contractorOptions}
					setSelectedRoutes={setSelectedRoutes}
					transStatusOptions={transStatusOptions}
					serviceTypeOptions={serviceTypeOptions}
					setSelectedDrivers={setSelectedDrivers}
					setSelectedServices={setSelectedServices}
					serviceStatusOptions={serviceStatusOptions}
					subContractorOptions={subContractorOptions}
					setContractorOptions={setContractorOptions}
					setSubContractorOptions={setSubContractorOptions}
					selectedTransStatusOptions={selectedTransStatusOptions}
					selectedServiceStatusOptions={selectedServiceStatusOptions}
					setSelectedTransStatusOptions={setSelectedTransStatusOptions}
					setSelectedServiceStatusOptions={setSelectedServiceStatusOptions}
				/>
			</div>
			<div className={`flex flex-col w-full font-medium overflow-y-scroll`}>
				<div className="flex bg-whiteBlue w-fit py-4">
					<div className="w-8 mx-8 flex justify-center items-center hover:cursor-pointer">
						<input
							type="checkbox"
							ref={selectAllRef}
							className="w-4 h-4 bg-white"
							checked={selectAll}
							onChange={handleSelectAll}
						/>
					</div>
					<div className="flex items-center">
						<div className="truncate w-60">Service Date</div>
						<div className="truncate w-40">OCTO Number</div>
						<div className="truncate w-80">Generator</div>
						<div className="truncate w-48">Service Type</div>
						<div className="truncate w-40">Route</div>
						<div className="truncate w-40">Service Vehicle</div>
						<div className="truncate w-52">Driver</div>
						<div className="truncate w-48">Transporter ID</div>
						<div className="truncate w-48">Service Status</div>
						<div className="truncate w-40 text-center">Transfer Status</div>
					</div>
				</div>
				<div className="flex flex-col w-fit overflow-y-auto">
					{!isFiltering && !isLoading && filteredData.length == 0 && (
						<div className="flex h-40  w-screen text-cardTextGray text-xl justify-center items-center">
							<p>No result found</p>
						</div>
					)}

					{filteredData.map((service, index) => (
						<div key={service.id} className="py-2 w-fit font-normal border-b">
							<DataTable
								handleRowCheckbox={handleRowCheckbox}
								selectedRows={selectedRows}
								service={service}
								transporterData={transporterData}
							/>
							<div className="flex w-full overflow-hidden gap-6 border-dashInActiveBtnText px-6 pl-10">
								<div className="w-[55%] border border-dashInActiveBtnText overflow-hidden">
									<div className="w-full bg-lightGray flex h-12 items-center justify-center gap-2">
										<h6 className="font-medium text-center">Service Summary</h6>
										{editing.serviceId === service.id && editing.section === "service" ? (
											<>
												<button className="text-primary text-sm" onClick={() => handleSave(service.id)}>
													Save
												</button>
												<button
													className="text-cardTextGray text-sm"
													onClick={() => {
														setEditing({
															serviceId: null,
															section: null,
															consentAcceptance: false,
														});
														setNewContainers([]);
														setEditedData({});
													}}
												>
													Cancel
												</button>
											</>
										) : (
											service.transferStatus !== transferStatusType.COMPLETE && (
												<button className="text-primary text-sm" onClick={() => handleEditClick(service.id, "service")}>
													(Edit)
												</button>
											)
										)}
									</div>
									<div className="px-4 pb-2">
										<>
											{service.serviceSummary?.length == 0 &&
												service.noWaste &&
												(editing.section == "service" && editing.serviceId == service.id ? (
													<p className="text-center py-2"></p>
												) : (
													<p className="text-center py-2">Delivery Only</p>
												))}
										</>
										{service.serviceSummary?.length > 0 && (
											<div className="flex gap-2 text-left py-2 font-medium">
												<p className="w-[20%]">Subwaste Type</p>
												<p className="w-[30%]">Container</p>
												<p className="w-[8%]">Qty</p>
												<p className="w-[10%]">Weight</p>
												<p className="w-[8%]">Rate</p>
												<p className="w-[8%]">Total</p>
												<p className="w-[8%]">Cost</p>
												<p className="w-[8%]">
													{editing.serviceId === service.id && editing.section === "service" && "Delete"}
												</p>
											</div>
										)}
										{Object.entries(
											groupContainers(
												editing.serviceId === service.id && editing.section === "service"
													? [...editedData.serviceSummary]
													: service.serviceSummary,
												service.manifestData
											)
										).map(([subWasteType, group], i, arr) => {
											let groupTotal = 0;
											const subtotal = group.containers.reduce(
												(acc, container) => {
													const quantity = Number(container.quantity) || 0;
													const weight = Number(container.weight) || 0;
													const rate = Number(container.priceBookData?.rate) || 0;

													return {
														quantity: acc.quantity + quantity,
														weight: acc.weight + weight,
														total: acc.total + quantity * rate,
													};
												},
												{ quantity: 0, weight: 0, total: 0, cost: 0 }
											);

											return (
												<div key={subWasteType} className={`${i < arr.length - 1 ? "border-b border-black/40" : ""}`}>
													<button
														className="text-left text-primary hover:underline"
														onClick={() => handleManifestView(group?.manifest?.id, group.manifest?.url)}
													>
														{group?.manifest?.manifestOctoId || ""}
													</button>

													{group.containers.map((summary, idx) => {
														const rate = Number(summary.priceBookData?.pricePerPound) || 0;

														const containerTotal =
															Number(summary.weight) * Number(summary.priceBookData?.pricePerPound);
														groupTotal += containerTotal;

														return (
															<div
																key={summary.id || summary.tempId}
																className="flex items-center gap-2 my-1 text-left"
															>
																{editing.serviceId === service.id && editing.section === "service" ? (
																	<>
																		{/* Subwaste Type */}
																		<div className="w-[20%]">
																			{subWasteTypesMap[summary.subWasteType] || summary.subWasteType}
																		</div>

																		{/* Container Type Dropdown */}
																		<select
																			value={summary.containerType}
																			onChange={(e) =>
																				handleSubWasteTypeChange(
																					service.id,
																					"serviceSummary",
																					idx,
																					"containerType",
																					e.target.value,
																					subWasteType,
																					summary.id || summary.tempId
																				)
																			}
																			className="border rounded p-0.5 w-[30%] px-1"
																		>
																			<option value="" disabled hidden></option>
																			{Object.entries(containerPriceBook)
																				.filter(([value, data]) => data.subWasteType == summary.subWasteType)
																				.map(([value, data]) => (
																					<option key={value} value={value}>
																						{data.labelOCTOFieldApp}
																					</option>
																				))}
																		</select>

																		{/* Quantity Input */}
																		<input
																			className="border-b focus:outline-none w-[8%] px-1"
																			value={Number(summary.quantity)}
																			type="number"
																			disabled={summary.serviceType == "ITEMIZED"}
																			min={1}
																			onChange={(e) =>
																				handleFieldChange(
																					service.id,
																					"serviceSummary",
																					idx,
																					"quantity",
																					e.target.value,
																					summary.id || summary.tempId
																				)
																			}
																		/>

																		{/* Weight Input */}
																		<input
																			className="border-b focus:outline-none w-[10%] px-1"
																			value={Number(summary.weight)}
																			type="number"
																			min={0}
																			onChange={(e) =>
																				handleFieldChange(
																					service.id,
																					"serviceSummary",
																					idx,
																					"weight",
																					e.target.value,
																					summary.id || summary.tempId
																				)
																			}
																		/>

																		{/* Rate Display */}
																		<div className="w-[8%]">${rate}</div>

																		{/* Total Display */}
																		<div className="w-[8%]">${containerTotal.toFixed(2)}</div>

																		{/* Cost Display */}
																		<div className="w-[8%]">{summary.cost ? `$${Number(summary.cost) / 100}` : ""}</div>

																		{/* Delete Button */}
																		<button
																			onClick={() => {
																				console.log({ summary });
																				setIsDeleting({
																					serviceId: service.id,
																					containerId: summary.id ?? summary.tempId,
																					section: "service",
																				});
																			}}
																			className="text-red-500 w-[8%] hover:text-red-700"
																		>
																			<BiTrash className="w-4 h-4" />
																		</button>
																	</>
																) : (
																	<>
																		<p className="w-[20%]">
																			{subWasteTypesMap[summary.subWasteType] ?? summary.subWasteType ?? "--"}
																		</p>
																		<p className="w-[30%]">{containersMap[summary.containerType] ?? "--"}</p>
																		<p className="w-[8%]">{summary.quantity}</p>
																		<p className="w-[10%]">{summary.weight}</p>
																		<p className="w-[8%]">${Number(summary.priceBookData?.pricePerPound).toFixed(2)}</p>
																		<p className="w-[8%]">
																			$
																			{(
																				Number(summary.quantity) *
																				Number(summary.weight) *
																				Number(summary.priceBookData?.pricePerPound)
																			).toFixed(2)}
																		</p>
																		<p className="w-[8%]">{summary.cost ? `$${Number(summary.cost) / 100}` : ""}</p>
																		<p className="w-[8%]"></p>
																	</>
																)}
															</div>
														);
													})}

													{/* Subtotal Row */}
													<div className="flex items-center gap-2 my-1 text-left font-semibold bg-gray-50 p-1">
														<p className="w-[20%]">Subtotal</p>
														<p className="w-[30%]"></p>
														<p className="w-[8%]">{subtotal.quantity}</p>
														<p className="w-[10%]">{subtotal.weight.toFixed(2)}</p>
														<p className="w-[8%]"></p>
														<p className="w-[8%]">${groupTotal.toFixed(2)}</p>
														<p className="w-[8%]"></p>
														<p className="w-[8%]"></p>
													</div>
												</div>
											);
										})}
										{editing.serviceId === service.id && editing.section === "service" && (
											<div className="flex gap-2 mt-2">
												<button className="text-primary text-sm" onClick={() => handleAddNewContainer(service.id)}>
													+ Add Container
												</button>
											</div>
										)}
									</div>
								</div>
								<DeliverySummaryContainer
									delContainersMap={delContainersMap}
									editedData={editedData}
									editing={editing}
									handleAddNewDelContainer={handleAddNewDelContainer}
									handleEditClick={handleEditClick}
									handleFieldChange={handleFieldChange}
									handleNewDelContainerChange={handleNewDelContainerChange}
									handleRemoveNewDelContainer={handleAddNewDelContainer}
									handleSave={handleSave}
									newDelContainers={newDelContainers}
									service={service}
									setEditedData={setEditedData}
									setEditing={setEditing}
									setIsDeleting={setIsDeleting}
									setNewDelContainers={setNewDelContainers}
								/>
								<OptionsContainer
									handleBillingCheckbox={handleBillingCheckbox}
									handlePaidCheckbox={handlePaidCheckbox}
									handleApprovedCheckbox={handleApprovedCheckbox}
									service={service}
								/>
							</div>
							<PictureSection service={service} />
						</div>
					))}
					{isLoading && <Loader height="h-20 py-4 w-screen" />}
					{!isLoading && hasMore && (
						<div className="flex justify-center my-4 h-fit w-screen">
							<button
								onClick={loadMore}
								className="px-2 py-1 bg-creamWhite border border-cardTextGray rounded hover:bg-primary-dark"
							>
								Load More
							</button>
						</div>
					)}
				</div>
			</div>
			{editing.section && editing.serviceId && !editing.consentAcceptance && (
				<div className="z-40 fixed inset-0 bg-mediumGray bg-opacity-50 flex justify-center items-center ">
					<div className="modal-box">
						<div>
							<button
								className="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"
								type="button"
								onClick={() => {
									setEditing({ section: null, serviceId: null, consentAcceptance: false });
									setShowDropdowns(false);
								}}
							>
								✕
							</button>
						</div>
						<h3 className="font-bold text-lg">Are you sure?</h3>
						<div className="flex py-5 gap-5 flex-col">
							<p>You are about to edit this service!</p>

							{showDropdowns && (
								<div className="flex flex-col gap-4">
									<div>
										<label className="block text-sm font-medium mb-1">Select Driver</label>
										<select
											className="w-full p-2 border rounded bg-gray-100"
											value={selectedDriver}
											onChange={(e) => setSelectedDriver(e.target.value)}
										>
											<option value=""></option>
											{allDrivers.map(({ label, value }) => (
												<option key={label} value={value}>
													{label}
												</option>
											))}
										</select>
									</div>
									<div>
										<label className="block text-sm font-medium mb-1">Select Vehicle</label>
										<select
											className="w-full p-2 border rounded bg-gray-100"
											value={selectedVehicle}
											onChange={(e) => setSelectedVehicle(e.target.value)}
										>
											<option value=""></option>
											{serviceVehicleOptions.map(({ label, value }) => (
												<option key={value} value={value}>
													{label}
												</option>
											))}
										</select>
									</div>

									<button
										className="px-4 py-2 bg-primary disabled:bg-primaryGray disabled:text-black/40 disabled:border disabled:border-cardTextGray/40 text-white rounded"
										disabled={!selectedDriver || !selectedVehicle}
										onClick={async () => {
											let driver = allDrivers.find((item) => item.value == selectedDriver);
											let vehicle = serviceVehicleOptions.find((item) => item.value == selectedVehicle);
											let toUpdate = {
												assignedDriverId: driver?.value,
												assignedDriverName: driver?.label,
												assignedServiceVehicleId: vehicle.value,
												assignedServiceVehicleName: vehicle.label,
											};

											console.log({ toUpdate, selectedDriver, selectedVehicle });

											let docRef = doc(db, "scheduledServices", editing.serviceId);

											try {
												await updateDoc(docRef, toUpdate);
												setSelectedDriver("");
												setSelectedVehicle("");
												setEditing((prev) => ({
													...prev,
													consentAcceptance: true,
													selectedDriver,
													selectedVehicle,
												}));
											} catch (error) {
												console.log(error);
												toast.error("Something went wrong!");
											} finally {
												setShowDropdowns(false);
											}
										}}
									>
										Confirm Selection
									</button>
								</div>
							)}
						</div>

						{!showDropdowns && (
							<div className="flex w-full justify-between">
								<button
									type="button"
									className="btn btn-error btn-sm"
									onClick={() => setEditing({ section: null, serviceId: null, consentAcceptance: false })}
								>
									No
								</button>
								<button
									className="btn btn-primary btn-sm"
									type="button"
									onClick={() => {
										const matchedService = completeServices.find((service) => service.id === editing.serviceId);
										if (matchedService?.serviceVehicleId && matchedService?.driverName) {
											setEditing((prev) => ({ ...prev, consentAcceptance: true }));
										} else {
											setShowDropdowns(true);
										}
										console.log({ allDrivers, serviceVehicleOptions });
									}}
								>
									Yes
								</button>
							</div>
						)}
					</div>
				</div>
			)}
			{isDeleting && (
				<div className="z-40 fixed inset-0 bg-mediumGray bg-opacity-50 flex justify-center items-center ">
					<div className="modal-box">
						<div>
							<button
								className="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"
								type="button"
								onClick={() => setIsDeleting(null)}
							>
								✕
							</button>
						</div>
						<h3 className="font-bold text-lg">Are you sure?</h3>
						<div className="flex py-5 gap-5 flex-col">
							<p className="">You are about to delete container of this service!</p>
						</div>
						<div className="flex w-full justify-between">
							<button type="button" className={`btn btn-error btn-sm`} onClick={() => setIsDeleting(null)}>
								{"No"}
							</button>
							<button
								className={`btn btn-primary btn-sm`}
								type="button"
								onClick={() => {
									if (isDeleting.section === "service") {
										handleDeleteContainer(isDeleting.serviceId, isDeleting.containerId);
									} else if (isDeleting.section === "delivery") {
										handleDeleteDelContainer(isDeleting.serviceId, isDeleting.containerId);
									}
								}}
							>
								{"Yes"}
							</button>
						</div>
					</div>
				</div>
			)}
			{showAddContainerModal && (
				<NewContainerModalHandler
					containerPriceBook={containerPriceBook}
					containersMap={containersMap}
					editedData={editedData}
					setEditedData={setEditedData}
					newContainerData={newContainerData}
					setNewContainerData={setNewContainerData}
					setNewContainers={setNewContainers}
					setShowAddContainerModal={setShowAddContainerModal}
				/>
			)}
			{!isLoading && <CounterHandler totalCountData={totalCountData} />}
			<FooterActionItems servicesSelected={selectedRows} />
		</div>
	);
};

export default ServiceReporting;

const NewContainerModalHandler = ({
	newContainerData,
	setNewContainerData,
	containersMap,
	containerPriceBook,
	editedData,
	setEditedData,
	setNewContainers,
	setShowAddContainerModal,
}) => {
	return (
		<div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
			<div className="bg-white p-6 w-96 rounded shadow">
				<h3 className="text-lg font-bold mb-4">Add New Container</h3>

				<div className="space-y-4">
					<div>
						<label className="block text-sm font-medium mb-1">Service Type</label>
						<select
							className="w-full p-2 border rounded"
							value={newContainerData.serviceType}
							disabled={newContainerData.serviceType?.length > 0}
							onChange={(e) => {
								const value = e.target.value;
								setNewContainerData((prev) => ({
									...prev,
									serviceType: value,
									quantity: value === "ITEMIZED" ? 1 : prev.quantity,
									serialNumber: value === "ITEMIZED" ? "" : "",
								}));
							}}
						>
							<option value=""></option>
							<option value="CONSOLIDATED">Consolidated</option>
							<option value="ITEMIZED">Itemized</option>
						</select>
					</div>
					{/* SubWaste Type (disabled) */}
					<div>
						<label className="block text-sm font-medium mb-1">Sub Waste Type</label>
						<select
							className="w-full p-2 border rounded bg-gray-100 cursor-not-allowed"
							value={newContainerData.subWasteType}
							disabled
						>
							<option value="">Subwaste Type</option>
							{Object.entries(subWasteTypesMap).map(([key, value]) => (
								<option key={value} value={value}>
									{subWasteTypesMap[key]}
								</option>
							))}
						</select>
					</div>

					{/* Container Type */}
					<div>
						<label className="block text-sm font-medium mb-1">Container Type</label>
						<select
							className="w-full p-2 border rounded"
							value={newContainerData.containerType}
							onChange={(e) => {
								let subWasteType = containerPriceBook[e.target.value]?.subWasteType;
								setNewContainerData((prev) => ({
									...prev,
									containerType: e.target.value,
									subWasteType,
									priceBookData: containerPriceBook[e.target.value] || null,
								}));
							}}
						>
							<option value="">Select Container Type</option>
							{Object.entries(containersMap)
								.map(([value, label]) => ({ value, label }))
								.filter((item) => !editedData.serviceSummary.map((item) => item.containerType).includes(item.value))
								.map(({ value, label }) => (
									<option key={value} value={value}>
										{label}
									</option>
								))}
						</select>
					</div>

					<div className={`${newContainerData.serviceType == "ITEMIZED" ? "block" : "hidden"}`}>
						<label className="block text-sm font-medium mb-1">Serial Number</label>
						<input
							type="text"
							className="w-full p-2 border rounded"
							placeholder="Quantity"
							value={newContainerData.serialNumber}
							onChange={(e) => {
								setNewContainerData((prev) => ({
									...prev,
									serialNumber: e.target.value,
								}));
							}}
						/>
					</div>

					{/* Quantity */}
					<div>
						<label className="block text-sm font-medium mb-1">Quantity</label>
						<input
							type="number"
							className="w-full p-2 border rounded"
							placeholder="Quantity"
							value={newContainerData.quantity}
							min={1}
							disabled={newContainerData.serviceType === "ITEMIZED"}
							onChange={(e) => {
								const value = parseInt(e.target.value, 10);
								setNewContainerData((prev) => ({
									...prev,
									quantity: isNaN(value) || value < 1 ? 1 : value,
								}));
							}}
						/>
					</div>

					{/* Weight */}
					<div>
						<label className="block text-sm font-medium mb-1">Weight (lbs)</label>
						<input
							type="number"
							className="w-full p-2 border rounded"
							placeholder="Weight"
							value={newContainerData.weight}
							onChange={(e) =>
								setNewContainerData((prev) => ({
									...prev,
									weight: parseFloat(e.target.value) || 0,
								}))
							}
						/>
					</div>

					{/* Buttons */}
					<div className="flex justify-end space-x-2 pt-2">
						<button
							className="px-4 py-2 text-gray-500 hover:text-gray-700"
							onClick={() => {
								setShowAddContainerModal(false);
								let containerData = editedData.serviceSummary?.[0];
								setNewContainerData({
									subWasteType: "",
									containerType: "",
									quantity: 1,
									weight: 0,
									rate: 0,
									total: 0,
									cost: 0,
									serviceType: containerData?.serviceType ?? "",
								});
							}}
						>
							Cancel
						</button>

						<button
							className="px-4 py-2 bg-primary text-white rounded"
							onClick={() => {
								const { containerType, serviceType, quantity, weight } = newContainerData;

								if (!containerType) {
									toast.error("Please select a container type.");
									return;
								}

								if (!serviceType?.length) {
									toast.error("Please select a service type.");
									return;
								}

								if (serviceType == "ITEMIZED") {
									if (newContainerData.serialNumber?.trim()?.length == 0) {
										toast.error("Please enter the serial number.");
										return;
									}
								}

								if (quantity < 1) {
									toast.error("Quantity must be at least 1.");
									return;
								}

								if (!weight?.toString()) {
									toast.error("Weight must be greater than 0.");
									return;
								}

								const tempId = Date.now();
								const container = { ...newContainerData, tempId };

								setNewContainers((prev) => [...prev, container]);

								setEditedData((prev) => ({
									...prev,
									serviceSummary: [...prev.serviceSummary, container],
								}));

								setShowAddContainerModal(false);
								let containerData = editedData.serviceSummary?.[0];
								setNewContainerData({
									subWasteType: "",
									containerType: "",
									quantity: 1,
									weight: 0,
									rate: 0,
									total: 0,
									cost: 0,
									serviceType: containerData.serviceType ?? "",
								});
							}}
						>
							Add Container
						</button>
					</div>
				</div>
			</div>
		</div>
	);
};

const CounterHandler = ({ totalCountData }) => {
	return (
		<div className="bg-whiteBlue font-medium min-h-12 h-16 p-4 px-10 w-full min-w-fit grid grid-cols-1 sm:grid-cols-2 gap-4">
			{Object.entries(totalCountData).map(([key, value]) => (
				<div className="flex gap-1" key={key}>
					<p className="font-medium">
						{key}
						{"- "}{" "}
					</p>
					<p className="font-normal">Qty: {Number(value.quantity)}</p>
					<p className="font-normal">Weight: {Number(value.weight).toFixed(2)} (lbs)</p>
				</div>
			))}
		</div>
	);
};

const DeliverySummaryContainer = ({
	editing,
	service,
	handleSave,
	setEditing,
	setNewDelContainers,
	setEditedData,
	handleEditClick,
	editedData,
	delContainersMap,
	handleFieldChange,
	setIsDeleting,
	newDelContainers,
	handleNewDelContainerChange,
	handleAddNewDelContainer,
	handleRemoveNewDelContainer,
}) => {
	return (
		<div className="w-[35%] border border-dashInActiveBtnText overflow-hidden">
			<div className="bg-lightGray h-12 w-full flex items-center justify-center gap-2">
				<h6 className="font-medium text-center">Delivery Summary</h6>
				{editing.serviceId === service.id && editing.section === "delivery" ? (
					<>
						<button className="text-primary text-sm" onClick={() => handleSave(service.id)}>
							Save
						</button>
						<button
							className="text-cardTextGray text-sm"
							onClick={() => {
								setEditing({
									serviceId: null,
									section: null,
									consentAcceptance: false,
								});
								setNewDelContainers([]);
								setEditedData({});
							}}
						>
							Cancel
						</button>
					</>
				) : (
					service.transferStatus !== transferStatusType.COMPLETE && (
						<button className="text-primary text-sm" onClick={() => handleEditClick(service.id, "delivery")}>
							(Edit)
						</button>
					)
				)}
			</div>
			<div className="px-4 pb-2">
				{service?.deliverySummary?.length > 0 && (
					<div className="flex gap-2 text-left py-2 font-medium">
						<p className="w-[50%]">Description</p>
						<p className="w-[30%]">Usage</p>
						<p className="w-[20%]">Quantity</p>
						{editing.serviceId === service.id && editing.section === "delivery" && <p>Delete</p>}
					</div>
				)}

				{service?.deliverySummary?.length > 0 && service?.deliveryReceipt && (
					<button
						className="text-left mr-1 hover:underline text-primary"
						onClick={() => handleDeliveryView(service?.deliveryReceipt?.deliveryId, service?.deliveryReceipt?.url)}
					>
						{service?.deliveryReceipt?.deliveryOctoId ?? service?.deliveryReceipt?.deliveryId}
					</button>
				)}
				{Array.isArray(service?.deliverySummary) ? (
					service.deliverySummary?.map((summary, idx) => (
						<div key={idx} className="flex gap-2 my-1 text-left">
							{editing.serviceId === service.id && editing.section === "delivery" ? (
								<>
									{/* Container Type Dropdown */}
									<select
										value={editedData.deliverySummary[idx].containerType}
										onChange={(e) =>
											handleFieldChange(service.id, "deliverySummary", idx, "containerType", e.target.value)
										}
										className="w-[50%] max-w-[50%] border rounded p-0.5 px-1"
									>
										<option value="" disabled hidden></option>
										{Object.entries(delContainersMap).map(([value, label]) => (
											<option key={value} value={value}>
												{label}
											</option>
										))}
									</select>
									{/* Usage Type Dropdown */}
									<select
										value={editedData.deliverySummary[idx].type}
										onChange={(e) => handleFieldChange(service.id, "deliverySummary", idx, "type", e.target.value)}
										className="w-[30%] max-w-[30%] border rounded p-0.5 px-1 capitalize"
									>
										<option value="" disabled hidden></option>
										<option value="USE">Use</option>
										<option value="SUPPLY">Supply</option>
									</select>
									{/* Quantity Input */}
									<div className="w-[15%] p-0.5">
										<input
											className="w-16 border-b focus:outline-none px-1"
											value={
												editedData.deliverySummary[idx].quantity ? Number(editedData.deliverySummary[idx].quantity) : 1
											}
											type="number"
											min={1}
											onChange={(e) =>
												handleFieldChange(
													service.id,
													"deliverySummary",
													idx,
													"quantity",
													e.target.value ? e.target.value?.toString() : "1"
												)
											}
											onKeyDown={(e) => {
												if (e.key === "." || e.key === "e") {
													e.preventDefault();
												}
											}}
										/>
									</div>
									{editing.serviceId === service.id && editing.section === "delivery" && (
										<button
											onClick={() =>
												setIsDeleting({
													serviceId: service.id,
													containerId: editedData.deliverySummary[idx].id,
													section: "delivery",
												})
											}
											className="text-red-500 hover:text-red-700 w-[5%]"
										>
											<BiTrash className="w-4 h-4" />
										</button>
									)}
								</>
							) : (
								<>
									<p className="w-[50%] p-0.5 px-1">{delContainersMap[summary?.containerType] ?? "--"}</p>
									<p className="w-[30%] p-0.5 px-1 capitalize">{summary?.type ?? "--"}</p>
									<p className="w-[15%] p-0.5 px-1.5">{summary.quantity}</p>
									<p className="w-[5%] p-0.5 px-1.5"></p>
								</>
							)}
						</div>
					))
				) : (
					<div className="w-full text-center py-2 text-secondary">
						<p>No data found</p>
					</div>
				)}
				{newDelContainers.map((delContainer, idx) => (
					<div key={delContainer.tempId} className="flex gap-2 h-7 my-1 text-left items-center">
						<select
							value={delContainer.containerType}
							onChange={(e) => handleNewDelContainerChange(delContainer.tempId, "containerType", e.target.value)}
							className="w-[50%] max-w-[50%] border rounded p-0.5 px-1"
						>
							<option value="" disabled hidden></option>
							{Object.entries(delContainersMap).map(([value, label]) => (
								<option key={value} value={value}>
									{label}
								</option>
							))}
						</select>
						{/* Usage Type Dropdown */}
						<select
							value={delContainer.type}
							onChange={(e) => handleNewDelContainerChange(delContainer.tempId, "type", e.target.value)}
							className="w-[30%] max-w-[30%] border rounded p-0.5 px-1 capitalize"
						>
							<option value="" disabled hidden></option>
							<option value="USE">Use</option>
							<option value="SUPPLY">Supply</option>
						</select>
						{/* Quantity Input */}
						<div className="w-[15%] p-0.5">
							<input
								className="w-16 border-b focus:outline-none px-1"
								value={delContainer.quantity ? Number(delContainer.quantity) : 1}
								type="number"
								min={1}
								onChange={(e) =>
									handleNewDelContainerChange(
										delContainer.tempId,
										"quantity",
										e.target.value ? e.target.value?.toString() : "1"
									)
								}
								onKeyDown={(e) => {
									if (e.key === "." || e.key === "e") {
										e.preventDefault();
									}
								}}
							/>
						</div>
						<button
							onClick={() => handleRemoveNewDelContainer(delContainer.tempId)}
							className="text-red-500 hover:text-red-700 w-[5%]"
						>
							<BiTrash className="w-4 h-4" />
						</button>
					</div>
				))}
				{editing.serviceId === service.id && editing.section === "delivery" && (
					<div className="flex gap-2 mt-2">
						<button className="text-primary text-sm" onClick={() => handleAddNewDelContainer(service.id)}>
							+ Add Container
						</button>
					</div>
				)}
			</div>
		</div>
	);
};

export const FooterActionItems = ({ servicesSelected, services }) => {
	const deleteGenerators = () => {
		// const selectedGenIds = generators.filter((gen) => servicesSelected.includes(gen?.id)).map((gen) => gen.id);
		// try {
		// 	dispatch(deleteGenerator(selectedGenIds));
		// } catch (error) {
		// 	console.log(error);
		// }
	};

	const sendEmail = () => {
		// const selectedGens = generators
		// 	.filter((gen) => servicesSelected.includes(gen?.id))
		// 	.map((item) => item.generatorEmail)
		// 	.filter((item) => emailRegex.test(item))
		// 	.join(";");
		// window.open(`mailto:${selectedGens}`, "_blank");
	};

	const clickHandler = async (btnType) => {
		// if (btnType == "Delete") {
		// 	deleteGenerators();
		// } else if (btnType == "Email") {
		// 	sendEmail();
		// } else if (btnType == "Share") {
		// 	toast.info("Sharing feature is in progress!");
		// }
	};

	return (
		<div
			className={`fixed bottom-0 left-0 right-0 ml-72 shadow-md px-6 transition-all duration-300 ease-in-out ${
				servicesSelected?.length > 0 ? "translate-y-0" : "translate-y-full"
			}`}
		>
			<div className="w-full py-4 flex justify-between items-center">
				<span className="truncate">{servicesSelected?.length} item(s) selected</span>
				<div className="flex gap-2">
					<ExportComponent servicesSelected={servicesSelected} generators={servicesSelected} />
					<button
						className={`px-4 py-2 disabled:bg-cardTextGray disabled:bg-opacity-10 disabled:cursor-not-allowed bg-creamWhite hover:bg-cardTextGray hover:bg-opacity-10 border transition-colors duration-200 ease-in-out`}
						onClick={() => clickHandler("Send to Billing")}
					>
						Send to Billing
					</button>
				</div>
			</div>
		</div>
	);
};

const ExportComponent = ({ genSelected, generators }) => {
	const [progress, setProgress] = useState(0);
	const [isExporting, setIsExporting] = useState(false);
	const [isModalOpen, setIsModalOpen] = useState(false);

	// Close modal when clicking outside
	useEffect(() => {
		const handleClickOutside = (e) => {
			if (!isExporting && e.target.classList.contains("modal-overlay")) {
				setIsModalOpen(false);
			}
		};

		document.addEventListener("mousedown", handleClickOutside);
		return () => document.removeEventListener("mousedown", handleClickOutside);
	}, [isExporting]);

	const handleExport = async () => {
		setIsExporting(true);
		setIsModalOpen(true);
		setProgress(0);

		try {
			// // Step 1: Data preparation (20% of progress)
			// let data = generators.filter((item) => genSelected.includes(item.id));
			// const worksheetData = data.map((item, index) => {
			// 	setProgress((index / data.length) * 20);
			// 	return {
			// 		"Generator Name": item.name,
			// 		"OCTO Number": item.octoNumber,
			// 		"Internal Account Number": item.internalAccountNumber,
			// 		"Service Address": item.address,
			// 		"Service Phone": item.phone,
			// 		"Service Email": item.email,
			// 		Status: item.generatorStatus,
			// 		"Onboarding Stage": JSON.stringify(item.onboardingStatus ?? {}),
			// 	};
			// });
			// setProgress(20);

			// // Step 2: Create worksheet (40% of progress)
			// const workbook = XLSX.utils.book_new();
			// const worksheet = XLSX.utils.json_to_sheet(worksheetData);
			// XLSX.utils.book_append_sheet(workbook, worksheet, "DataSheet");
			// setProgress(40);

			// // Step 3: Convert to binary (70% of progress)
			// const excelBuffer = XLSX.write(workbook, {
			// 	bookType: "xlsx",
			// 	type: "array",
			// });
			// setProgress(70);

			// // Step 4: Create blob and prepare for download (90% of progress)
			// const blob = new Blob([excelBuffer], {
			// 	type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
			// });
			// setProgress(90);

			// // Step 5: Trigger download (100% of progress)
			// saveAs(blob, "exported_data.xlsx");
			// setProgress(100);

			// Reset after showing 100% completion
			setTimeout(() => {
				setIsExporting(false);
				setProgress(0);
				setIsModalOpen(false);
			}, 1000);
		} catch (error) {
			console.error("Export failed:", error);
			setIsExporting(false);
			setProgress(0);
			setIsModalOpen(false);
		}
	};

	return (
		<>
			<button
				onClick={handleExport}
				disabled={isExporting}
				className={`px-4 py-2 disabled:bg-cardTextGray disabled:bg-opacity-10 
			disabled:cursor-not-allowed bg-creamWhite hover:bg-cardTextGray hover:bg-opacity-10 
			border transition-colors duration-200 ease-in-out`}
			>
				{isExporting ? "Exporting..." : "Export"}
			</button>
		</>
	);
};

const FilterComp = ({
	to,
	from,
	setTo,
	setFrom,
	searchQuery,
	routeOptions,
	driverOptions,
	setSearchQuery,
	selectedRoutes,
	selectedDrivers,
	selectedServices,
	setSelectedRoutes,
	contractorOptions,
	serviceTypeOptions,
	transStatusOptions,
	setSelectedDrivers,
	setSelectedServices,
	serviceStatusOptions,
	subContractorOptions,
	setContractorOptions,
	setSubContractorOptions,
	selectedTransStatusOptions,
	selectedServiceStatusOptions,
	setSelectedTransStatusOptions,
	setSelectedServiceStatusOptions,
}) => {
	const clearFilters = () => {
		setSearchQuery("");
		setSelectedRoutes(["all", ...routeOptions.map((item) => item.value)]);
		setSelectedServices(["all", ...serviceTypeOptions.map((item) => item.value)]);
		setSelectedDrivers(["all", ...driverOptions.map((item) => item.value)]);
		setSelectedTransStatusOptions([...transStatusOptions.map((item) => item.value)]);
		setSelectedServiceStatusOptions([...serviceStatusOptions.map((item) => item.value)]);
	};

	return (
		<>
			<div className="px-8 flex items-center justify-between">
				<div className="flex items-center bg-white rounded-full p-3 px-4 border border-gray-200 w-full max-w-[50%]">
					<FiSearch className="text-cardTextGray opacity-50" size={20} />
					<input
						type="text"
						placeholder="Search by Name, OCTO Number, Phone, Email, Address, Documents "
						value={searchQuery}
						onChange={(e) => setSearchQuery(e.target.value)}
						className="pl-2 bg-transparent focus:outline-none text-cardTextGray flex-1 w-full"
					/>
				</div>
				<button className="text-primary hover:text-blue-900" onClick={clearFilters}>
					Clear Filter
				</button>
			</div>
			<div className="w-11/12 flex px-8 py-5">
				<div className="flex flex-wrap gap-5 gap-y-3 items-end">
					<div className="flex flex-col min-w-52">
						<p className="text-sm text-gray-500 px-2">From</p>
						<CustomDatePicker
							selectedDate={from}
							setSelectedDate={(value) => setFrom(new Date(value))}
							label={"From Date"}
						/>
					</div>
					<div className="flex flex-col min-w-52">
						<p className="text-sm text-gray-500 px-2">To</p>
						<CustomDatePicker selectedDate={to} setSelectedDate={(value) => setTo(new Date(value))} label={"To Date"} />
					</div>
					<MultiselectDropdown
						width="w-48"
						buttonText="Service Type"
						options={serviceTypeOptions}
						selectedOptions={selectedServices}
						onSelectedOptionsChange={(values) => setSelectedServices(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Route"
						options={routeOptions}
						selectedOptions={selectedRoutes}
						onSelectedOptionsChange={(values) => setSelectedRoutes(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Driver"
						options={driverOptions}
						selectedOptions={selectedDrivers}
						onSelectedOptionsChange={(values) => setSelectedDrivers(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Service Status"
						options={serviceStatusOptions}
						selectedOptions={selectedServiceStatusOptions}
						onSelectedOptionsChange={(values) => setSelectedServiceStatusOptions(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Contractor"
						options={[]}
						selectedOptions={contractorOptions}
						onSelectedOptionsChange={(values) => setContractorOptions(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Subcontractor"
						options={[]}
						selectedOptions={subContractorOptions}
						onSelectedOptionsChange={(values) => setSubContractorOptions(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Transfer Status"
						options={transStatusOptions}
						selectedOptions={selectedTransStatusOptions}
						onSelectedOptionsChange={(values) => setSelectedTransStatusOptions(values)}
					/>
				</div>
			</div>
		</>
	);
};

const PictureSection = ({ service }) => {
	return (
		<div className="flex flex-col px-10 py-6">
			<div className="flex justify-between">
				<div className="flex gap-4">
					<p className="w-32 font-medium">Images:</p>
					{service?.picture?.length > 0 ? (
						service.picture.map((item, i) => (
							<Link target="_blank" key={item.url} className="text-primary underline" to={item.url}>
								View Image {i + 1}
							</Link>
						))
					) : (
						<p>N/A</p>
					)}
				</div>
				<div className="flex gap-4 w-[18%]">
					<p className="w-32 font-medium">Contractor:</p>
					<p>{service?.additional?.contractor}</p>
				</div>
			</div>
			<div className="flex justify-between">
				<div>
					{service?.tempServiceIns?.length && (
						<div className="flex gap-4">
							<p className="text-nowrap w-32 font-red-500 font-medium">Temporary Service Instructions:</p>
							<p>{service?.tempServiceIns}</p>
						</div>
					)}
					<div className="flex gap-4">
						<p className="text-nowrap w-32 font-medium">Driver Note:</p>
						<p>{service?.driverNote}</p>
					</div>
				</div>
				<div className="flex gap-4 w-[18%] h-fit">
					<p className="text-nowrap min-w-32 font-medium">Subcontractor:</p>
					<p>{service?.additional?.subcontractor}</p>
				</div>
			</div>
		</div>
	);
};

const DataTable = ({ service, selectedRows, handleRowCheckbox, transporterData }) => {
	return (
		<div className="flex w-fit items-center pt-2 pb-6">
			<div className="min-w-8 mx-8 flex justify-center hover:cursor-pointer">
				<input
					type="checkbox"
					className="w-4 h-4 bg-white"
					checked={selectedRows.includes(service.id)}
					onChange={(e) => handleRowCheckbox(e, service.id)}
				/>
			</div>
			<div className="flex items-center">
				<div className="truncate w-60">
					{service.completedAt
						? formattedDateTime(service.completedAt)
						: formatUtcDateString(service.date.toDate().toUTCString())}
				</div>
				<div className="truncate w-40">{service.octoNumber}</div>
				<div className="truncate w-80 text-thatblue">
					<Link to={`/admin/generators/${service.genId}/generator-dashboard`}>{service.generatorName}</Link>
				</div>
				<div className="truncate w-48">{serviceTypesMap?.[service.serviceType]}</div>
				<div className="truncate w-40">{service.routeName}</div>
				<div className="truncate w-40">{service.pickUpTruck}</div>
				<div className="truncate w-52">{service.driverName}</div>
				<div className="truncate w-48">{transporterData?.transporterOctoId}</div>
				<div className="truncate w-48">{capitalizeFirstLetter(service?.serviceStatus)}</div>
				<div className="truncate w-40 text-center">
					{service.completedAt
						? service.transferStatus == TRANSFER_STATUS.COMPLETE
							? "Transferred"
							: "In Transit"
						: "--"}
				</div>
			</div>
		</div>
	);
};

const ManifestMapper = ({ service }) => {
	return (
		<div className="flex text-sm justify-center">
			<span>
				{service?.manifestData?.[0]?.manifestOctoId?.slice(0, service?.manifestData?.[0]?.manifestOctoId?.length - 2)}
			</span>
			{service.manifestData?.map((manifest, index) => (
				<button
					key={manifest?.id}
					className="text-center mr-1 hover:underline text-primary"
					onClick={() => handleManifestView(manifest.id, manifest.url)}
				>
					{manifest?.manifestOctoId?.slice(manifest?.manifestOctoId?.length - 2, manifest?.manifestOctoId?.length)}
					{index < service.manifestData?.length - 1 ? ", " : ""}
				</button>
			))}
		</div>
	);
};

function formatDateToMMDDYYYY(date) {
	if (!(date instanceof Date)) {
		throw new Error("Invalid date object");
	}

	const month = String(date.getMonth() + 1).padStart(2, "0");
	const day = String(date.getDate()).padStart(2, "0");
	const year = date.getFullYear();

	return `${month}${day}${year}`;
}
