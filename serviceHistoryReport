import { useCallback, useEffect, useMemo, useRef, useState, useTransition } from "react";
import { Link } from "react-router-dom";
import * as dateFnsTz from "date-fns-tz";
import CustomDatePicker from "../../../../../components/UI/CustomDatePicker";
import Loader from "../../../../../components/UI/loaders/Loader";
import {
	arrayRemove,
	arrayUnion,
	collection,
	doc,
	documentId,
	getDoc,
	getDocs,
	limit,
	onSnapshot,
	or,
	orderBy,
	query,
	startAfter,
	Timestamp,
	getCountFromServer,
	updateDoc,
	where,
	writeBatch,
} from "firebase/firestore";
import { auth, COLLECTIONS, db, getDeliveryUrl, getManifestUrl } from "../../../../../config/firebase";
import {
	invoiceStatus,
	itemsMap,
	paymentTerms,
	SERVICE_STATUS,
	serviceTypes,
	serviceTypesMap,
	subWasteTypesArray,
	subWasteTypesMap,
	TRANSFER_STATUS,
	transferStatusMap,
	transferStatusType,
} from "../../../../../utils/constants";
import {
	capitalizeFirstLetter,
	formattedDateTime,
	formatUtcDateString,
	formatUtcDateTimeString,
	octoFormatter,
} from "../../../../../utils/helpers";
import MultiselectDropdown from "../../../../../components/UI/dropdowns/MultiselectDropdown";
import { FiSearch } from "react-icons/fi";
import {
	getAllDrivers,
	getAllRoutes,
	getAllTreatmentOptions,
	getAllServiceVehicleOptions,
} from "../../../../../utils/firebaseOperations";
import { useAuthState } from "react-firebase-hooks/auth";
import Button from "../../../../../components/UI/Button";
import useTUserContext from "../../../../../context/TransporterUserContext";
import { toast } from "react-toastify";
import { BiTrash } from "react-icons/bi";
import { log } from "handlebars";
import OptionsContainer from "./OptionsContainer";
import { BsFillInfoCircleFill } from "react-icons/bs";

const transStatusOptions = [
	{
		label: "All",
		value: "all",
	},
	{
		label: "In Transit",
		value: transferStatusType.ON_TRUCK,
	},
	{
		label: "Transferred",
		value: transferStatusType.COMPLETE,
	},
];

const serviceStatusOptions = [
	{ label: "All", value: "all" },
	{ label: "Canceled", value: "CANCELED" },
	{ label: "Completed", value: "COMPLETE" },
	{ label: "Unavailable", value: "UNAVAILABLE" },
	{ label: "Unlogged", value: "UNLOGGED" },
];

const getStringOfServiceTypes = (scheduleData) => {
	if (!scheduleData || !scheduleData.serviceType || !serviceTypes) {
		return "N/A";
	}
	return Array.isArray(scheduleData.serviceType)
		? scheduleData.serviceType.reduce((accumulator, serviceType) => {
				const matchingService = serviceTypes.find((service) => service.value === serviceType);
				return accumulator.concat(matchingService ? matchingService.label : "N/A");
		  }, [])
		: scheduleData.serviceType;
};

const getFormattedAddress = (add) => {
	const addressParts = [add.serviceAddress?.street, add.serviceAddress?.city, add.serviceAddress?.state].filter(
		Boolean
	);

	const address = addressParts.length
		? addressParts.join(", ") + (add.serviceAddress?.zipCode ? ` ${add.serviceAddress.zipCode}` : "")
		: "--";

	return address;
};

const handleDeliveryView = async (id, url) => {
	console.log("id,url", { id, url });

	if (url && url?.length > 0) {
		window.open(url, "_blank");
	} else {
		const fetchUrl = getDeliveryUrl(id);
		console.log("fetchUrl", fetchUrl);
		window.open(fetchUrl, "_blank");
	}
};

const sortedServiceSummary = (summary) =>
	summary.sort((a, b) => {
		const aType = a.subWasteType?.toLowerCase() || "";
		const bType = b.subWasteType?.toLowerCase() || "";
		return aType.localeCompare(bType);
	});

const handleManifestView = async (id, url) => {
	console.log({ id, url });

	if (url && url?.length > 0) {
		window.open(url, "_blank");
	} else {
		const fetchUrl = getManifestUrl(id);
		console.log("fetchUrl", fetchUrl);
		window.open(fetchUrl, "_blank");
	}
};

const getTransferredContainers = async (allContainerEntries = [], serviceId = "") => {
	if (allContainerEntries.length === 0) {
		return {
			transferStatus: "PENDING",
			transferredContainers: [],
		};
	}

	const containerRefs = allContainerEntries
		.map((item) => (item.id ? doc(db, COLLECTIONS.servicedContainers, item.id) : null))
		.filter(Boolean);

	const containerDocs = await Promise.all(containerRefs.map((ref) => getDoc(ref)));
	const allContainersExist = containerDocs.every((doc) => doc.exists());

	let allDocs = containerDocs.map((item) => ({
		id: item.id,
		...item.data(),
	}));

	const allComplete = containerDocs.every((doc) => doc.exists() && doc.data()?.transferStatus === "COMPLETE");

	const transferStatus = allContainersExist && allComplete ? "COMPLETE" : "INPROGRESS";

	if (transferStatus === "COMPLETE") {
		const treatmentIds = allDocs.map((doc) => doc.treatmentId).filter(Boolean);
		const treatmentRefs = treatmentIds.map((id) => doc(db, COLLECTIONS.treatments, id));
		const treatmentDocs = await Promise.all(treatmentRefs.map((ref) => getDoc(ref)));

		const treatmentMap = {};
		treatmentDocs.forEach((tDoc) => {
			if (tDoc.exists()) {
				treatmentMap[tDoc.id] = { id: tDoc.id, ...tDoc.data() };
			}
		});

		allDocs = allDocs.map((container) => {
			const treatmentData = container.treatmentId ? treatmentMap[container.treatmentId]?.wasteProcessingFees : null;

			console.log({ "Treatment data from waste processing fees": treatmentData });

			let wasteProcessingFees = {};

			if (treatmentData && typeof treatmentData === "object") {
				Object.entries(treatmentData).forEach(([key, value]) => {
					if (value && value.checked && value.fee?.isActive) {
						if (key == "biohazard") {
							wasteProcessingFees["Bio/Sharps"] = value.fee.price;
						} else if (key == "pharmaceutical") {
							wasteProcessingFees["RCRA Pharmaceutical"] = value.fee.price;
							wasteProcessingFees["Non-RCRA Pharmaceutical"] = value.fee.price;
						} else if (key == "pathology") {
							wasteProcessingFees["Chemotherapy"] = value.fee.price;
						} else if (key == "paperShredding") {
							wasteProcessingFees["Paper Shredding"] = value.fee.price;
						}
					}
				});
			}

			return {
				...container,
				treatmentData,
				wasteProcessingFees,
			};
		});
	}

	return {
		transferStatus,
		transferredContainers: transferStatus === "COMPLETE" ? allDocs : [],
	};
};

const loadServiceContainerPriceBook = async ({ transporterId }) => {
	const containersRef = collection(db, COLLECTIONS.priceBooks, transporterId, "default", "services", "containers");
	const snapshot = await getDocs(containersRef);

	const containerMap = {};
	snapshot.forEach((doc) => {
		containerMap[doc.id] = doc.data();
	});

	return containerMap;
};

const loadProductContainerPriceBook = async ({ transporterId }) => {
	const containersRef = collection(db, COLLECTIONS.priceBooks, transporterId, "default", "products", "containers");
	const snapshot = await getDocs(containersRef);

	const containerMap = {};
	snapshot.forEach((doc) => {
		containerMap[doc.id] = doc.data();
	});

	return containerMap;
};

const approvalOptionsForDropdown = [
	{ label: "Approved", value: "approved" },
	{ label: "Pending", value: "pending" },
];

const ServiceReporting = () => {
	const [isLoading, setIsLoading] = useState(true);
	const [isLoadingMore, setIsLoadingMore] = useState(false);
	const [selectAll, setSelectAll] = useState(false);
	const [indeterminate, setIndeterminate] = useState(false);
	const [completeServices, setCompleteServices] = useState([]);
	const [searchQuery, setSearchQuery] = useState("");
	const [from, setFrom] = useState(new Date());
	const [to, setTo] = useState(() => new Date());
	const [serviceTypeOptions, setServiceTypeOptions] = useState([]);
	const [routeOptions, setRouteOptions] = useState([]);
	const [driverOptions, setDriverOptions] = useState([]);
	const [serviceVehicleOptions, setServiceVehicleOptions] = useState([]);
	const [allDrivers, setAllDrivers] = useState([]);
	const [contractorOptions, setContractorOptions] = useState([]);
	const [subContractorOptions, setSubContractorOptions] = useState([]);
	const [showDropdowns, setShowDropdowns] = useState(false);
	const [selectedVehicle, setSelectedVehicle] = useState("");
	const [selectedDriver, setSelectedDriver] = useState("");
	const [selectedTransStatusOptions, setSelectedTransStatusOptions] = useState(
		transStatusOptions.map((item) => item.value)
	);
	const [subWasteTypeOptions] = useState([{ label: "All", value: "all" }, ...subWasteTypesArray]);
	const [approvalOptions] = useState([{ label: "All", value: "all" }, ...approvalOptionsForDropdown]);
	const [selectedApproved, setSelectedApproved] = useState([
		"all",
		...approvalOptionsForDropdown.map((item) => item.value),
	]);
	const [selectedPickupOptions, setSelectedPickupOptions] = useState([]);
	const [selectedServices, setSelectedServices] = useState([]);
	const [selectedDrivers, setSelectedDrivers] = useState([]);
	const [genIds, setGenIds] = useState([]);
	const [filteredData, setFilteredData] = useState([]);
	const [selectedRoutes, setSelectedRoutes] = useState([]);
	const [selectedSubWastes, setSelectedSubWastes] = useState(["all", ...subWasteTypesArray.map((item) => item.value)]);
	const [isFiltering, startTransition] = useTransition();
	const [genIdsLoading, setIsGenIdsLoading] = useState(true);
	const [containersMap, setContainersMap] = useState({});
	const [delContainersMap, setDelContainersMap] = useState({});
	const [transporterData, setTransporterData] = useState(null);
	const [newContainers, setNewContainers] = useState([]);
	const [newDelContainers, setNewDelContainers] = useState([]);
	const [selectedRows, setSelectedRows] = useState([]);
	const [isDeleting, setIsDeleting] = useState(null);
	const [editing, setEditing] = useState({
		serviceId: null,
		section: null,
		consentAcceptance: false,
	});
	const [editedData, setEditedData] = useState({});
	const { user, loading } = useTUserContext();
	const selectAllRef = useRef();
	const [serviceContainerPriceBook, setServiceContainerPriceBook] = useState({});
	const [productContainerPriceBook, setProductContainerPriceBook] = useState({});
	const [showAddContainerModal, setShowAddContainerModal] = useState(false);
	const [unSubscribers, setUnSubscribers] = useState([]);
	const [unavalogCount, setUnavalogCount] = useState({});
	const [selectedServiceStatusOptions, setSelectedServiceStatusOptions] = useState(
		serviceStatusOptions.map((item) => item.value)
	);
	const [newContainerData, setNewContainerData] = useState({
		subWasteType: "",
		containerType: "",
		quantity: 1,
		weight: 0,
		rate: 0,
		total: 0,
		serviceType: "CONSOLIDATED",
	});
	const [pageSize] = useState(100);
	const [lastVisibleDoc, setLastVisibleDoc] = useState(null);
	const [hasMore, setHasMore] = useState(false);
	const [dateFilterManuallyChanged, setDateFilterManuallyChanged] = useState(false);
	const [treatmentMap, setTreatmentMap] = useState({});
	const [totalC, setTotalC] = useState(0);
	const [unloggedCount, setUnloggedCount] = useState(0);

	useEffect(() => {
		if (user) {
			loadServiceContainerPriceBook({ transporterId: user.uid }).then(setServiceContainerPriceBook);
			loadProductContainerPriceBook({ transporterId: user.uid }).then(setProductContainerPriceBook);
		}
	}, [user]);

	const urlParams = new URLSearchParams(window.location.search);
	const genOctoNumber = urlParams.get("id");

	useEffect(() => {
		if (genOctoNumber) {
			console.log("genOctoNumber", genOctoNumber);
			setSearchQuery(genOctoNumber);
		}
	}, [genOctoNumber]);

	const fetchAllDriverOptions = async () => {
		try {
			const resp = await getAllDrivers(user?.uid);
			const options = [];
			resp.map((item) => {
				let label = item.firstName + " " + item.lastName;
				options.push({
					label,
					value: label,
				});
			});
			setAllDrivers(resp.map((item) => ({ label: item.firstName + " " + item.lastName, value: item.id })));
			setDriverOptions([{ label: "All", value: "all" }, ...options]);
			setSelectedDrivers(["all", ...options.map((item) => item.value)]);
			fetchDocuments();
		} catch (error) {
			console.log("Error fetching drivers", error);
		}
	};
	console.log({ productContainerPriceBook, serviceContainerPriceBook });

	const fetchDocuments = async () => {
		if (!user) return;

		try {
			const generatorsRef = collection(db, COLLECTIONS.generators);
			const q = query(
				generatorsRef,
				or(where("transporterId", "==", user?.uid), where("subContractor.id", "==", user?.uid))
			);
			const querySnapshot = await getDocs(q);

			const ids = querySnapshot.docs.map((doc) => doc.id);
			setGenIds(ids);
		} catch (error) {
			console.error("Error fetching documents:", error);
		} finally {
			setIsGenIdsLoading(false);
		}
	};

	const fetchAllTransferOptions = async () => {
		try {
			const resp = await getAllTreatmentOptions(user?.uid);
			const options = [];
			let map = {};
			resp.map((item) => {
				options.push({
					label: item.name,
					value: item.id,
				});
				map[item.id] = item.name;
			});
			console.log({ map, resp });
			setSelectedPickupOptions(["all", ...options.map((item) => item.value)]);
			setTreatmentMap(map);
		} catch (error) {
			console.log("Error fetching routes", error);
		}
	};

	const fetchAllServiceVehicleOptions = async () => {
		try {
			const resp = await getAllServiceVehicleOptions(user?.uid);
			const options = [];
			let map = {};
			resp.map((item) => {
				options.push({
					label: item.name,
					value: item.id,
				});
				map[item.id] = item.name;
			});
			setServiceVehicleOptions(options);
		} catch (error) {
			console.log("Error fetching routes", error);
		}
	};

	useEffect(() => {
		const fetchTransporterData = async () => {
			if (!user?.uid) return;
			let docSnapshot = await getDoc(doc(db, COLLECTIONS.transporters, user.uid));
			if (docSnapshot.exists()) {
				let data = { ...docSnapshot.data(), id: docSnapshot.id };
				setTransporterData(data);
			}
		};

		fetchTransporterData();
	}, [user]);

	console.log({ totalC, unloggedCount });

	useEffect(() => {
		let isActive = true;

		const fetchData = async () => {
			if (!user || genIdsLoading) return;

			// Reset state and start loading
			if (isActive) {
				setCompleteServices([]);
				setLastVisibleDoc(null);
				setIsLoading(true);
				setTotalC(0);
				setUnloggedCount(0);
			}
			try {
				// Unsubscribe any previous listeners
				unSubscribers.forEach((unSub) => unSub());
				setUnSubscribers([]);
				const shouldBypassDateFilter = genOctoNumber && !dateFilterManuallyChanged;
				// Fetch new data
				const utcFromDate = shouldBypassDateFilter
					? new Date(2000, 0, 1)
					: new Date(Date.UTC(from.getFullYear(), from.getMonth(), from.getDate(), 0, 0, 0, 0));
				const utcToDate = new Date(Date.UTC(to.getFullYear(), to.getMonth(), to.getDate(), 23, 59, 59, 999));

				const genIdChunks = [];
				for (let i = 0; i < genIds.length; i += 10) {
					genIdChunks.push(genIds.slice(i, i + 10));
				}

				// First get accurate total count from all chunks
				let totalCount = 0;

				// Run count queries for each chunk separately
				await Promise.all(
					genIdChunks.map(async (chunk) => {
						const countQuery = query(
							collection(db, COLLECTIONS.scheduledServices),
							where("date", ">=", Timestamp.fromDate(utcFromDate)),
							where("date", "<=", Timestamp.fromDate(utcToDate)),
							where("status", "!=", SERVICE_STATUS.DELETED),
							where("generatorId", "in", chunk)
						);

						const snapshot = await getCountFromServer(countQuery);
						const chunkCount = snapshot.data().count;
						totalCount += chunkCount;
						console.log(`Chunk count: ${chunkCount} for ${chunk.length} generatorIds`);
					})
				);

				setTotalC(totalCount);

				const q = query(
					collection(db, COLLECTIONS.scheduledServices),
					where("date", ">=", Timestamp.fromDate(utcFromDate)),
					where("date", "<=", Timestamp.fromDate(utcToDate)),
					where("status", "!=", SERVICE_STATUS.DELETED),
					orderBy("date", "desc"),
					limit(pageSize)
				);

				const snapshotRes = await getDocs(q);
				if (snapshotRes.empty) {
					console.log("No documents found");
				} 
				const docs = snapshotRes.docs
					.map((doc) => ({ id: doc.id, ...doc.data() }))
					.filter((doc) => genIds.includes(doc.generatorId));

				const processedDocs = (await Promise.all(docs.map((doc) => processDoc(doc))))
					.filter(Boolean)
					?.sort((a, b) => a.date?.toDate() > b.date?.toDate());
				calculateUnlogged(processedDocs);
				console.log({ processedDocs, genIds });
				let filteredDocs = processedDocs?.filter((item) => checkDate(item));
				if (isActive) {
					console.log({ filteredDocs, processedDocs });
					setCompleteServices(filteredDocs);
					const newUnSubscribers = setupDocumentListeners(docs);
					setUnSubscribers(newUnSubscribers);
					setLastVisibleDoc(snapshotRes.docs[snapshotRes.docs.length - 1]);
					setHasMore(snapshotRes.docs.length >= pageSize);
				}
			} catch (error) {
				console.error("Error fetching services:", error);
				if (isActive) toast.error("Failed to load services.");
			} finally {
				if (isActive) setIsLoading(false);
			}
		};
		setUnloggedCount(0);
		fetchData();

		return () => {
			isActive = false;
		};
	}, [to, from, user, genIdsLoading]);

	useEffect(() => {
		const fetchContainers = async () => {
			try {
				const containersRef = collection(db, COLLECTIONS.defaultPriceBook, "services", "containers");
				const snapshot = await getDocs(containersRef);

				const containersData = {};
				snapshot.forEach((doc) => {
					containersData[doc.id] = doc.data().labelOCTOFieldApp;
				});

				setContainersMap(containersData);
				console.log({ containersData });
			} catch (error) {
				console.error("Error fetching containers:", error);
			}
		};

		fetchContainers();
	}, []);

	useEffect(() => {
		const currentSelected = selectedRows.length;
		const total = filteredData.length;
		const allSelected = currentSelected === total && total > 0;
		const isIndeterminate = currentSelected > 0 && currentSelected < total;

		setSelectAll(allSelected);
		setIndeterminate(isIndeterminate);

		if (selectAllRef.current) {
			selectAllRef.current.indeterminate = isIndeterminate;
		}
	}, [selectedRows, filteredData]);

	useEffect(() => {
		const fetchDelContainers = async () => {
			try {
				const containersRef = collection(db, COLLECTIONS.defaultPriceBook, "products", "containers");
				const snapshot = await getDocs(containersRef);

				const containersData = {};
				snapshot.forEach((doc) => {
					containersData[doc.id] = doc.data().labelOCTOFieldApp;
				});

				setDelContainersMap(containersData);
			} catch (error) {
				console.error("Error fetching containers:", error);
			}
		};

		fetchDelContainers();
	}, []);

	const getSummaryData = (containers, transferredContainers = []) => {
		const summary = [];

		containers?.forEach((el, index) => {
			let container = transferredContainers.find((item) => item.containerType == el.containerType);
			console.log({ el, serviceContainerPriceBook, containers: transferredContainers });
			summary.push({
				...el,
				quantity: el.quantity ?? 1,
				priceBookData: serviceContainerPriceBook[el.containerType] || null,
				cost: container?.wasteProcessingFees?.[el.subWasteType] || "",
				containerWashingFee: container?.wasteProcessingFees?.containerWashing?.checked
					? Number(container?.wasteProcessingFees?.containerWashing?.fee?.price)
					: null,
			});
		});
		return summary;
	};

	const getDeliverySummaryData = (deliveredContainers = []) => {
		const summary = [];

		deliveredContainers?.forEach((el, index) => {
			summary.push({
				...el,
				priceBookData: productContainerPriceBook[el.containerType] || null,
			});
		});
		return summary;
	};

	const processDoc = async (serviceData) => {
		// if (serviceData.generatorId == "Tf7tyAV0CAeTE9Ub3JZQ") {
		console.log("Service data found for this generator", serviceData);
		// }
		const manifestDataRef = collection(db, COLLECTIONS.manifests);
		const manifestQuery = query(manifestDataRef, where("serviceId", "==", serviceData.id));
		const manifestRes = await getDocs(manifestQuery);
		let manifestData = manifestRes.docs.map((item) => ({ id: item.id, ...item.data() }));

		const containers = manifestData
			.map((item) => item.containers)
			.flat()
			.filter(Boolean);

		const containerDataRef = containers.map((id) => doc(db, COLLECTIONS.servicedContainers, id));
		const servicedContainerDocs = await Promise.all(containerDataRef.map((ref) => getDoc(ref)));
		const allServicedContainersData = servicedContainerDocs.map((doc) => ({ id: doc.id, ...doc.data() }));
		const { transferStatus, transferredContainers } = await getTransferredContainers(
			allServicedContainersData,
			serviceData.id
		);

		serviceData.transferStatus = transferStatus;
		serviceData.transferredContainers = transferredContainers;

		const scheduleDataRef = doc(db, `${COLLECTIONS.serviceSchedules}/${serviceData.serviceScheduleId}`);
		const scheduleRes = await getDoc(scheduleDataRef);
		if (!scheduleRes.exists()) return;
		const scheduleData = scheduleRes.data();

		const serviceTypeString = getStringOfServiceTypes(scheduleData);
		const generatorDataRef = doc(db, `${COLLECTIONS.generators}/${serviceData.generatorId}`);
		const generatorRes = await getDoc(generatorDataRef);
		if (!generatorRes.exists()) return;
		const generatorData = generatorRes.data();

		const routeDataRef = doc(db, `${COLLECTIONS.routes}/${serviceData.routeId}`);
		const routeRes = await getDoc(routeDataRef);
		if (!routeRes.exists()) return;
		const routeData = routeRes.data();

		const transDataRef = collection(db, COLLECTIONS.deliveries);
		const transQuery = query(transDataRef, where("serviceId", "==", serviceData.id));
		const transRes = await getDocs(transQuery);
		let transData = transRes.docs.map((item) => ({ id: item.id, ...item.data() }));
		let deliverySummary = [];
		let deliveryReceipt = null;

		if (transData.length > 0) {
			deliveryReceipt = {
				deliveryId: transData?.[0]?.id,
				deliveryOctoId: transData?.[0]?.deliveryOctoId,
				url: transData?.[0]?.url,
			};
			let allDeliveredContainers = transData?.[0]?.containers;
			const delContainerRefs = allDeliveredContainers.map((item) => doc(db, COLLECTIONS.deliveredContainers, item));
			const delContainerDocs = await Promise.all(delContainerRefs.map((ref) => getDoc(ref)));
			const delContainers = delContainerDocs.map((doc) => ({ id: doc.id, ...doc.data() }));
			deliverySummary = getDeliverySummaryData(delContainers);
		}

		if (serviceData.serviceScheduleId) {
			let scheduleDoc = await getDoc(doc(db, COLLECTIONS.serviceSchedules, serviceData.serviceScheduleId));
			if (scheduleDoc.exists()) serviceData.scheduleData = { id: scheduleDoc.id, ...scheduleDoc.data() };
			else serviceData.scheduleData = null;
		} else {
			serviceData.scheduleData = null;
		}

		let serviceSummary = await getSummaryData(
			allServicedContainersData,
			serviceData.transferStatus === "COMPLETE" ? serviceData.transferredContainers : []
		);

		if (serviceData?.status === SERVICE_STATUS.CLOSED) {
			console.log({ unavailableService: serviceData });
		}

		return processedServiceData({
			deliveryReceipt,
			deliverySummary,
			generatorData,
			generatorDataRef,
			manifestData,
			routeData,
			serviceData,
			serviceSummary,
			routeRes,
			serviceTypeString,
			transData,
			user,
			transporterData,
		});
	};

	// console.log({treatment})

	const loadMore = async () => {
		if (!lastVisibleDoc || !hasMore) return;
		setIsLoadingMore(true);

		try {
			const shouldBypassDateFilter = genOctoNumber && !dateFilterManuallyChanged;
			const utcFromDate = shouldBypassDateFilter
				? Timestamp.fromDate(new Date(2000, 0, 1))
				: Timestamp.fromDate(new Date(Date.UTC(from.getFullYear(), from.getMonth(), from.getDate(), 0, 0, 0, 0)));
			const utcToDate = new Date(Date.UTC(to.getFullYear(), to.getMonth(), to.getDate(), 23, 59, 59, 999));

			const q = query(
				collection(db, COLLECTIONS.scheduledServices),
				where("date", ">=", utcFromDate),
				where("date", "<=", utcToDate),
				where("status", "!=", SERVICE_STATUS.DELETED),
				orderBy("date", "desc"),
				startAfter(lastVisibleDoc),
				limit(pageSize)
			);

			const snap = await getDocs(q);
			const newDocs = snap.docs
				.map((doc) => ({ id: doc.id, ...doc.data() }))
				.filter((doc) => genIds.includes(doc.generatorId));

			// Process new documents
			const processedDocs = await Promise.all(newDocs.map((doc) => processDoc(doc)));
			calculateUnlogged(processedDocs);
			let filteredDocs = processedDocs?.filter((item) => checkDate(item));
			// Merge with existing documents
			setCompleteServices((prev) => [...prev, ...filteredDocs]);

			// Set up listeners for these new documents
			const newUnSubscribers = setupDocumentListeners(newDocs);
			setUnSubscribers((prev) => [...prev, ...newUnSubscribers]);

			setLastVisibleDoc(snap.docs[snap.docs.length - 1]);
			setHasMore(snap.docs.length >= pageSize);
		} catch (error) {
			console.error("Error loading more services:", error);
			toast.error("Failed to load more services. Please try again.");
		} finally {
			setIsLoadingMore(false);
		}
	};

	const checkDate = (item) => {
		const today = new Date();
		const todayUtc = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0));

		console.log({ todayUtc, dateUtc: item.date?.toDate(), diff: todayUtc - item.date?.toDate() });

		// Pure function without side effects
		if (item.completedAt) return true;
		if (todayUtc > item.date?.toDate()) return true;
		return item.serviceStatus !== "UNLOGGED";
	};

	const calculateUnlogged = (completeServices) => {
		const unlogged = completeServices.filter((service) => {
			const today = new Date();
			const todayUtc = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0));

			return !service.completedAt && todayUtc <= service.date?.toDate() && service.serviceStatus === "UNLOGGED";
		});

		setUnloggedCount((prev) => prev + unlogged.length);
	};

	// Helper function to set up listeners
	const setupDocumentListeners = (docs) => {
		const listeners = [];

		for (const docData of docs) {
			const docRef = doc(db, COLLECTIONS.scheduledServices, docData.id);
			const unsubscribe = onSnapshot(docRef, async (snap) => {
				if (!snap.exists()) return;

				const updatedDoc = { id: snap.id, ...snap.data() };
				if (!genIds.includes(updatedDoc.generatorId)) return;

				const processed = await processDoc(updatedDoc);

				if (!checkDate(processed)) return;

				setCompleteServices((prev) => {
					const index = prev.findIndex((doc) => doc.id === processed.id);

					if (index >= 0) {
						const newArray = [...prev];
						newArray[index] = processed;
						return newArray;
					} else {
						return [...prev, processed];
					}
				});
			});

			listeners.push(unsubscribe);
		}

		return listeners;
	};

	// Cleaning up all listeners when component unmounts
	useEffect(() => {
		return () => {
			unSubscribers.forEach((unsub) => unsub());
		};
	}, [unSubscribers]);

	const normalizedSearchQuery = searchQuery.toLowerCase().replace(/\s+/g, "");
	const getSortInfo = (item) => {
		const completed = item.completedAt?.toDate?.();
		const date = item.date?.toDate?.();
		return {
			hasCompletedAt: !!completed,
			sortValue: (completed || date)?.getTime?.() ?? 0,
		};
	};

	useEffect(() => {
		startTransition(() => {
			let matchedServices = completeServices.filter((data) =>
				[data.generatorName, data.phone, data.email, data.address, data.octoNumber, data.internalAccountNumber].some(
					(field) => field?.toString()?.toLowerCase().replace(/\s+/g, "").includes(normalizedSearchQuery)
				)
			);
			matchedServices = matchedServices.filter((item) =>
				selectedServices.includes("all") ? true : selectedServices.includes(item.serviceType)
			);
			matchedServices = matchedServices.filter((item) =>
				selectedDrivers.includes("all") ? true : selectedDrivers.includes(item.driverName)
			);
			matchedServices = matchedServices.filter((item) =>
				selectedRoutes.includes("all") ? true : selectedRoutes.includes(item.routeId)
			);
			matchedServices = matchedServices.filter((item) =>
				selectedSubWastes.includes("all") ? true : item.subWasteType.some((type) => selectedSubWastes.includes(type))
			);
			matchedServices = matchedServices.filter((item) =>
				selectedApproved.includes("all") ? true : selectedApproved.includes(item.approved ? "approved" : "pending")
			);

			matchedServices = selectedTransStatusOptions.includes("all")
				? matchedServices
				: matchedServices.filter((item) =>
						selectedTransStatusOptions.includes(
							item.transferStatus == transferStatusType.COMPLETE
								? transferStatusType.COMPLETE
								: transferStatusType.ON_TRUCK
						)
				  );
			matchedServices = selectedServiceStatusOptions.includes("all")
				? matchedServices
				: matchedServices.filter((item) => selectedServiceStatusOptions.includes(item.serviceStatus));

			console.log({ matchedServices });
			matchedServices = matchedServices.sort((a, b) => {
				const aInfo = getSortInfo(a);
				const bInfo = getSortInfo(b);

				if (bInfo.sortValue !== aInfo.sortValue) {
					return bInfo.sortValue - aInfo.sortValue;
				}

				if (aInfo.hasCompletedAt !== bInfo.hasCompletedAt) {
					return bInfo.hasCompletedAt ? 1 : -1;
				}

				return 0;
			});

			setFilteredData(matchedServices);
			setNewContainers([]);
			setNewDelContainers([]);
		});
	}, [
		searchQuery,
		selectedRoutes,
		selectedDrivers,
		selectedApproved,
		selectedServices,
		completeServices,
		selectedSubWastes,
		selectedPickupOptions,
		selectedTransStatusOptions,
		selectedServiceStatusOptions,
	]);

	const fetchAllRoutesOptions = async () => {
		try {
			const resp = await getAllRoutes(user?.uid);
			const options = [];
			let map = {};
			resp
				?.filter((route) => route.status == "ACTIVE")
				.map((item) => {
					options.push({
						label: item.routeLabel,
						value: item.id,
					});
					map[item.id] = item.routeLabel;
				});
			setRouteOptions([{ label: "All", value: "all" }, ...options]);
			setServiceTypeOptions([{ label: "All", value: "all" }, ...serviceTypes]);
			setSelectedServices(["all", ...serviceTypes.map((item) => item.value)]);
			setSelectedRoutes(["all", ...options.map((item) => item.value)]);
		} catch (error) {
			console.log("Error fetching routes", error);
		}
	};

	useEffect(() => {
		if (user) {
			fetchAllDriverOptions();
			fetchAllRoutesOptions();
			fetchAllTransferOptions();
			fetchAllServiceVehicleOptions();
		}
	}, [user]);

	const handleBillingCheckbox = async (isChecked, serviceId, statusUpdateReason = "") => {
		let docRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
		console.log({ isChecked, serviceId, statusUpdateReason });

		let toUpdate = {
			billed: isChecked,
			billedDate: isChecked ? Timestamp.now() : null,
			billingMethod: isChecked ? "internal" : "",
			billingNote: isChecked ? "Invoiced Through External Billing Platform" : "",
			statusUpdateReason: arrayUnion({
				statusUpdateReason,
				by: user.userId ?? "",
			}),
		};

		try {
			await updateDoc(docRef, toUpdate);
			setCompleteServices((prevServices) =>
				prevServices.map((service) =>
					service.id === serviceId
						? {
								...service,
								...toUpdate,
								billedDate: isChecked ? Timestamp.now()?.toDate()?.toLocaleDateString() : null,
						  }
						: service
				)
			);

			toast.success(isChecked ? "Invoiced Through External Billing Platform!" : "Billing status updated.");
		} catch (error) {
			console.error("Error updating billing status:", error);
			toast.error("Failed to update billing status.");
		}
	};

	const handlePaidCheckbox = async (isChecked, serviceId, statusUpdateReason = "") => {
		let docRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
		console.log({ isChecked, serviceId, statusUpdateReason });

		let toUpdate = {
			paid: isChecked ? true : false,
			paidDate: isChecked ? Timestamp.now() : null,
			billingNote: isChecked ? "Payment recorded." : "",
			statusUpdateReason: arrayUnion({
				statusUpdateReason,
				by: user.userId ?? "",
			}),
		};

		try {
			await updateDoc(docRef, toUpdate);
			setCompleteServices((prevServices) =>
				prevServices.map((service) =>
					service.id === serviceId
						? {
								...service,
								...toUpdate,
								paidDate: isChecked ? Timestamp.now()?.toDate()?.toLocaleDateString() : null,
						  }
						: service
				)
			);

			// toast.success(isChecked ? "Payment marked as complete!" : "Payment status updated.");
		} catch (error) {
			console.error("Error updating payment status:", error);
			toast.error("Failed to update payment status.");
		}
	};
	const handleApprovedCheckbox = async (isChecked, serviceId, statusUpdateReason = "", service) => {
		let docRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
		console.log({ isChecked, serviceId, statusUpdateReason, service });

		let toUpdate = {
			approved: isChecked,
			approvedDate: isChecked ? Timestamp.now() : null,
			approvedNote: isChecked ? "Service approved." : "",
			statusUpdateReason: arrayUnion({
				statusUpdateReason,
				by: user.userId ?? "",
			}),
		};

		try {
			const generatorRes = await getDoc(doc(db, COLLECTIONS.generators, service.generatorId));
			if (!generatorRes.exists()) {
				throw new Error("Generator not found");
			}
			const generatorData = generatorRes.data();
			let term = paymentTerms.NET30;
			if (typeof generatorData?.paymentTerms === "undefined" || !generatorData?.paymentTerms?.length) {
				const transporterBIllingSettingsRes = await getDoc(doc(db, COLLECTIONS.billingSettings, user.uid));
				if (transporterBIllingSettingsRes.exists()) {
					const transporterBillingSettings = transporterBIllingSettingsRes.data();
					term = transporterBillingSettings?.paymentOptions?.paymentTerms;
				} else {
					console.log("No payment terms found for generator or transporter");
				}
			} else {
				term = generatorData?.paymentTerms;
			}
			const res = await getDocs(
				query(
					collection(db, COLLECTIONS.invoices),
					where("transporterId", "==", user.uid),
					where("paymentTerm", "==", term),
					where("generatorId", "==", service.generatorId),
					where("status", "==", invoiceStatus.DELAYED_CHARGE)
				)
			);

			const batch = writeBatch(db);
			batch.update(docRef, toUpdate);

			await updateDoc(docRef, toUpdate);
			setCompleteServices((prevServices) =>
				prevServices.map((service) =>
					service.id === serviceId
						? {
								...service,
								...toUpdate,
								approvedDate: isChecked ? Timestamp.now()?.toDate()?.toLocaleDateString() : null,
						  }
						: service
				)
			);

			// toast.success(isChecked ? "Payment marked as complete!" : "Payment status updated.");
		} catch (error) {
			console.error("Error updating payment status:", error);
			toast.error("Failed to update payment status.");
		}
	};

	const handleSelectAll = () => {
		if (selectedRows.length === filteredData.length) {
			setSelectedRows([]);
		} else {
			const allIds = filteredData.map((service) => service.id);
			setSelectedRows(allIds);
		}
	};

	const handleRowCheckbox = (e, serviceId) => {
		const isChecked = e.target.checked;
		setSelectedRows((prev) => (isChecked ? [...prev, serviceId] : prev.filter((id) => id !== serviceId)));
	};

	const handleEditClick = (serviceId, section) => {
		setEditing({ serviceId, section, consentAcceptance: false });
		const service = JSON.parse(JSON.stringify(filteredData.find((s) => s.id === serviceId)));
		setEditedData({
			serviceSummary: sortedServiceSummary([...service.serviceSummary]),
			deliverySummary: [...service.deliverySummary],
		});
		setNewContainers([]);
		setNewDelContainers([]);
	};

	const handleFieldChange = (serviceId, section, index, field, value, containerId) => {
		console.log({ serviceId, section, index, field, value, containerId });
		const newData = [...editedData[section]].map((item) => {
			if (item.id === containerId) {
				return { ...item, [field]: value };
			} else if (item.tempId === containerId) {
				return { ...item, [field]: value };
			}
			return item;
		});
		setEditedData((prev) => ({ ...prev, [section]: newData }));
	};

	const handleSubWasteTypeChange = async (serviceId, section, index, field, value, group) => {
		const newData = [...editedData[section]];
		newData[index][field] = value;
		let resp = await fetchContainerData(value);
		console.log({ field, value, resp, group, containersMap, serviceContainerPriceBook });
		newData[index]["subWasteType"] = resp.subWasteType;
		setEditedData((prev) => ({ ...prev, [section]: newData }));
	};

	const formatDateToMMDDYYYY = (date, timezone = "America/New_York") => {
		const zonedDate = dateFnsTz.formatInTimeZone(date, timezone, "MMddyyyy");
		return zonedDate;
	};

	const createManifestId = (transporterOctoId, generatorOctoId, serviceDate) => {
		let dateString = formatDateToMMDDYYYY(serviceDate.toDate(), "America/New_York");
		let manifestCount = 0;
		return `M-${transporterOctoId.slice(2, 6)}-${generatorOctoId.replace(/\D/g, "")}-${dateString}-${manifestCount
			.toString()
			.padStart(2, "0")}`;
	};

	const handleSave = async (serviceId) => {
		const serviceRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
		const batch = writeBatch(db);
		const service = completeServices.find((s) => s.id === serviceId);
		console.log("service", service);
		try {
			let subWasteGroups = {};
			let oldSubWasteGroups = {};
			let newManifests = [];
			const newContainerIds = [];
			const deletedManifestIds = [];

			console.log({ newContainers, newDelContainers });

			if (editing.section === "service") {
				let newItemWithInvalidVal = newContainers.find(
					(item) => !item.containerType || item.containerType == "" || !Number(item.quantity)
				);
				if (newItemWithInvalidVal) {
					if (newItemWithInvalidVal.containerType == "") {
						toast.error("Container Type is required");
						return;
					}
					if (!Number(newItemWithInvalidVal.quantity)) {
						toast.error("Quantity must be non-zero value");
						return;
					}
				}
				console.log({ editedData });
				let itemWithInvalidVal = editedData.serviceSummary.find(
					(item) => !item.containerType || item.containerType == "" || !Number(item.quantity)
				);
				if (itemWithInvalidVal) {
					if (itemWithInvalidVal.containerType == "") {
						toast.error("Container Type is required");
						return;
					}
					if (!Number(itemWithInvalidVal.quantity)) {
						toast.error("Quantity must be non-zero value");
						return;
					}
				}
				const serviceUpdate = {
					consolidated: editedData.serviceSummary
						.filter((item) => item.serviceType === "CONSOLIDATED")
						.map(({ serviceType, _index, ...rest }) => rest),
					itemized: editedData.serviceSummary
						.filter((item) => item.serviceType === "ITEMIZED")
						.map(({ serviceType, _index, ...rest }) => rest),
				};

				let newContainerss = [];

				// Process Old Containers (Means containers having firestore doc ID)
				await Promise.all(
					editedData.serviceSummary.map(async (item) => {
						if (!item.id) {
							newContainerss.push(item);
							return;
						}
						const containerRef = doc(db, COLLECTIONS.servicedContainers, item.id);
						const containerDoc = await getDoc(containerRef);
						const containerData = containerDoc.data();
						console.log({ containerDoc, containerData });
						const oldSWT = containerData?.subWasteType;
						const newSWT = item.subWasteType;
						batch.update(containerRef, {
							quantity: Number(item.quantity) || 0,
							weight: Number(item.weight) || 0,
							subWasteType: newSWT,
							containerType: item.containerType,
						});
						subWasteGroups[newSWT] = [...(subWasteGroups[newSWT] || []), containerRef.id];
						if (oldSWT !== newSWT) {
							oldSubWasteGroups[oldSWT] = [...(oldSubWasteGroups[oldSWT] || []), containerRef.id];
						}
					})
				);

				console.log({ newContainerss });
				// Processing NEW containers
				for (let i = 0; i < newContainerss.length; i++) {
					const containerRef = doc(collection(db, COLLECTIONS.servicedContainers));
					const newContainer = {
						...newContainerss[i],
						id: containerRef.id,
						serviceId,
						driverId: service.driverId,
						generatorId: service.generatorId,
						routeId: service.routeId,
						scheduleId: service.scheduleId,
						serviceStatus: SERVICE_STATUS.COMPLETE,
						serviceVehicleId: service.serviceVehicleId,
						transporterId: service.transporterId,
						transferStatus: service.transferStatus ?? transferStatusType.ON_TRUCK,
						createdAt: service?.date?.toDate() ?? service?.completedAt?.toDate(),
						updatedAt: Timestamp.now(),
					};
					newContainerss[i] = newContainer;
					newContainerIds.push(containerRef.id);
					batch.set(containerRef, newContainer);
					const swt = newContainer.subWasteType;
					subWasteGroups[swt] = [...(subWasteGroups[swt] || []), containerRef.id];
				}

				// Removing containers from old manifests
				Object.entries(oldSubWasteGroups).forEach(([oldSWT, containerIds]) => {
					const oldManifest = service.manifestData.find((m) => m.subWasteType === oldSWT);
					if (oldManifest) {
						const manifestRef = doc(db, COLLECTIONS.manifests, oldManifest.id);
						const originalContainers = oldManifest.containers || [];
						const remainingContainers = originalContainers.filter((id) => !containerIds.includes(id));
						if (remainingContainers.length === 0) {
							batch.delete(manifestRef);
							deletedManifestIds.push(oldManifest.id);
						} else {
							batch.update(manifestRef, {
								containers: arrayRemove(...containerIds),
								updatedAt: Timestamp.now(),
								isEdited: true,
								url: null,
							});
						}
					}
				});
				// Add/update for new manifests
				let sampleManifest = service.manifestData?.[0];
				console.log({ sampleManifest });
				if (!sampleManifest) {
					sampleManifest = {
						driverId: service.driverId,
						generatorId: service.generatorId,
						routeId: service.routeId,
						scheduleId: service.scheduleId,
						serviceVehicleId: service.serviceVehicleId,
						transporterId: service.transporterId,
						manifestOctoId: createManifestId(transporterData?.transporterOctoId, service.octoNumber, service.date),
					};
				}

				console.log({ sampleManifest });
				Object.entries(subWasteGroups).forEach(([newSWT, containerIds]) => {
					const existingManifest = service.manifestData.find((m) => m.subWasteType === newSWT);
					if (existingManifest) {
						const manifestRef = doc(db, COLLECTIONS.manifests, existingManifest.id);
						batch.update(manifestRef, {
							containers: arrayUnion(...containerIds),
							updatedAt: Timestamp.now(),
							isEdited: true,
							url: null,
						});
					} else {
						const existingManifestOctoIds = service.manifestData.map((m) => m.manifestOctoId);
						const maxSuffix = existingManifestOctoIds.reduce((max, octoId) => {
							const parts = octoId.split("-");
							const suffix = parseInt(parts[parts.length - 1], 10);
							return suffix > max ? suffix : max;
						}, 0);
						const newSuffix = String(maxSuffix + 1).padStart(2, "0");
						console.log({ newSuffix, maxSuffix, existingManifestOctoIds });

						const baseManifestId = sampleManifest.manifestOctoId.split("-").slice(0, -1).join("-");
						const newManifestOctoId = `${baseManifestId}-${newSuffix}`;
						console.log({ baseManifestId, newManifestOctoId });

						const newManifestRef = doc(collection(db, COLLECTIONS.manifests));
						const newManifestData = {
							...(sampleManifest && {
								driverId: sampleManifest.driverId,
								generatorId: sampleManifest.generatorId,
								routeId: sampleManifest.routeId,
								scheduleId: sampleManifest.scheduleId,
								serviceVehicleId: sampleManifest.serviceVehicleId,
								transporterId: sampleManifest.transporterId,
							}),
							subWasteType: newSWT,
							containers: containerIds,
							serviceId: service.id,
							manifestOctoId: newManifestOctoId,
							createdAt: Timestamp.now(),
							updatedAt: Timestamp.now(),
							isEdited: true,
							url: null,
						};
						batch.set(newManifestRef, newManifestData);
						newManifests.push({ ...newManifestData, id: newManifestRef.id });
					}
				});
				serviceUpdate.manifestData = [
					...service.manifestData.filter((m) => !subWasteGroups[m.subWasteType]),
					...newManifests.map(({ id, subWasteType }) => ({ id, subWasteType })),
				];
				const newConsolidated = [];
				const newItemized = [];

				newContainerss.forEach((c, idx) => {
					const newEntry = {
						...c,
						id: newContainerIds[idx],
					};

					if (newEntry.serviceType === "ITEMIZED") {
						newItemized.push(newEntry);
					} else {
						newConsolidated.push(newEntry);
					}
				});

				serviceUpdate.consolidated = [...serviceUpdate.consolidated, ...newConsolidated];

				serviceUpdate.itemized = [...serviceUpdate.itemized, ...newItemized];
				if (service.serviceStatus !== SERVICE_STATUS.COMPLETE) {
					console.log({ serviceOriginalStatus: service.serviceStatus });
					serviceUpdate.status = SERVICE_STATUS.COMPLETE;
					const originalDate = service.date.toDate();
					const year = originalDate.getUTCFullYear();
					const month = originalDate.getUTCMonth();
					const date = originalDate.getUTCDate();

					const completedAt = new Date();
					completedAt.setFullYear(year);
					completedAt.setMonth(month);
					completedAt.setDate(date);
					completedAt.setHours(12, 0, 0, 0); // Set to 12 PM

					// Convert back to Firestore Timestamp
					const updatedTimestamp = Timestamp.fromDate(completedAt);
					serviceUpdate.completedAt = updatedTimestamp;
					serviceUpdate.earlierStatus = service.serviceStatus;
					serviceUpdate.transferStatus = TRANSFER_STATUS.ON_TRUCK;
				}
				console.log({ serviceUpdate });
				// return;
				if (service.noWaste) serviceUpdate.noWaste = service.noWaste;
				batch.update(serviceRef, serviceUpdate);
				await batch.commit();
				setCompleteServices((prev) =>
					prev.map((s) => {
						if (s.id !== serviceId) return s;
						const updatedManifests = [
							...s.manifestData.map((m) => {
								if (subWasteGroups[m.subWasteType]) {
									return {
										...m,
										containers: [...new Set([...m.containers, ...subWasteGroups[m.subWasteType]])],
										url: null,
									};
								}
								return m;
							}),
							...newManifests.filter((nm) => !s.manifestData.some((m) => m.subWasteType === nm.subWasteType)),
						];
						return {
							...s,
							serviceSummary: [
								...editedData.serviceSummary.filter((item) => item.id),
								...newContainerss.map((c) => ({
									...c,
									id: newContainerIds.shift(),
								})),
							],

							manifestData: updatedManifests.filter((m) => m.containers?.length > 0),
						};
					})
				);
				// Updating filteredData
				setFilteredData((prev) =>
					prev.map((s) => (s.id === serviceId ? completeServices.find((cs) => cs.id === serviceId) : s))
				);

				// return;
			}

			if (editing.section === "delivery") {
				console.log({ delId: service?.deliveryId });
				let invalidContainer = newDelContainers.find(
					(item) => !item.containerType || item.containerType == "" || !item.type || !Number(item.quantity)
				);
				if (invalidContainer) {
					if (invalidContainer.containerType == "") {
						toast.error("Container is required");
						return;
					}
					if (invalidContainer.type == "") {
						toast.error("Usage is required");
						return;
					}
					if (!Number(invalidContainer.quantity)) {
						toast.error("Quantity must be non-zero value");
						return;
					}
				}

				let itemWithInvalidVal = editedData.deliverySummary.find(
					(item) => !item.containerType || item.containerType == "" || !item.type || !Number(item.quantity)
				);
				if (itemWithInvalidVal) {
					if (!Number(itemWithInvalidVal.quantity)) {
						toast.error("Quantity must be non-zero value");
					}
					return;
				}

				const newDelContainerIds = [];
				let deliveryRef,
					deliveryDoc,
					deliveryCount = 0;

				if (!service?.deliveryId) {
					// Create a new delivery document
					deliveryRef = doc(collection(db, COLLECTIONS.deliveries));
					deliveryDoc = {
						id: deliveryRef.id,
						generatorId: service.generatorId,
						routeId: service.routeId,
						scheduleId: service.scheduleId,
						serviceId: service.serviceId,
						transporterId: service.transporterId,
						driverId: service.driverId,
						serviceVehicleId: service.serviceVehicleId,
						createdAt: service?.date ?? service?.completedAt,
						date: service?.date ?? service?.completedAt,
						updatedAt: service?.date ?? service?.completedAt,
						containers: [],
					};

					batch.set(deliveryRef, deliveryDoc);
				} else {
					// Fetch existing delivery document
					deliveryRef = doc(db, COLLECTIONS.deliveries, service.deliveryId);
					const deliverySnap = await getDoc(deliveryRef);

					if (deliverySnap.exists()) {
						deliveryDoc = { id: deliverySnap.id, ...deliverySnap.data() };
					} else {
						return toast.error("Couldn't find any delivery for this service");
					}
				}

				deliveryCount = deliveryDoc.containers.length;

				// Fetch existing delivery containers
				const existingContainerDocs = [];
				if (deliveryDoc.containers.length > 0) {
					const existingContainersQuery = query(
						collection(db, COLLECTIONS.deliveredContainers),
						where(documentId(), "in", deliveryDoc.containers)
					);
					const existingContainersSnap = await getDocs(existingContainersQuery);
					existingContainersSnap.forEach((doc) => {
						existingContainerDocs.push({ id: doc.id, ...doc.data() });
					});
				}

				let updatedContainers = newDelContainers.map((newContainer, index) => {
					let existingContainer = existingContainerDocs.find((c) => c.containerType === newContainer.containerType);

					if (existingContainer) {
						// UPDATE existing container
						batch.update(doc(db, COLLECTIONS.deliveredContainers, existingContainer.id), {
							...existingContainer,
							quantity: newContainer.quantity,
							weight: newContainer.weight,
							updatedAt: Timestamp.now(),
						});
						return { ...existingContainer, quantity: newContainer.quantity, weight: newContainer.weight };
					} else {
						const containerRef = doc(collection(db, COLLECTIONS.deliveredContainers));
						newDelContainerIds.push(containerRef.id);

						const newContainerData = {
							...newContainer,
							updatedAt: Timestamp.now(),
							createdAt: service?.date?.toDate() ?? service?.completedAt?.toDate(),
							generatorId: service.generatorId,
							deliveryId: deliveryRef.id,
							routeId: service.routeId,
							scheduleId: service.scheduleId,
							serviceId: service.serviceId,
							serviceStatus: "COMPLETE",
							serviceVehicleId: service.serviceVehicleId,
							transporterId: service.transporterId,
						};

						batch.set(containerRef, newContainerData);
						return newContainerData;
					}
				});

				setNewDelContainers(updatedContainers);

				if (newDelContainerIds.length > 0) {
					batch.update(deliveryRef, {
						containers: arrayUnion(...newDelContainerIds),
						driverId: service.driverId,
						updatedAt: Timestamp.now(),
						url: "",
					});
				}

				const serviceRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
				batch.update(serviceRef, { status: SERVICE_STATUS.COMPLETE });
				await batch.commit();

				setCompleteServices((prev) =>
					prev.map((s) =>
						s.id === serviceId
							? {
									...s,
									deliverySummary: [
										...s.deliverySummary,
										...updatedContainers.map((c, index) => ({ ...c, id: newDelContainerIds[index] || c.id })),
									],
									deliveryId: deliveryDoc.id,
									deliveryReceipt: {
										deliveryId: deliveryDoc.id,
										deliveryOctoId: deliveryDoc.deliveryOctoId,
										url: "",
									},
							  }
							: s
					)
				);

				setFilteredData((prev) =>
					prev.map((s) =>
						s.id === serviceId
							? {
									...s,
									deliverySummary: [
										...s.deliverySummary,
										...updatedContainers.map((c, index) => ({ ...c, id: newDelContainerIds[index] || c.id })),
									],
									deliveryId: deliveryDoc.id,
									deliveryReceipt: {
										deliveryId: deliveryDoc.id,
										deliveryOctoId: deliveryDoc.deliveryOctoId,
										url: "",
									},
							  }
							: s
					)
				);
			}

			setNewContainers([]);
			setNewDelContainers([]);
			setEditing({ serviceId: null, section: null, consentAcceptance: false });
			toast.success("Changes saved successfully!");
		} catch (error) {
			setCompleteServices((prev) => prev.map((s) => (s.id === serviceId ? service : s)));
			setFilteredData((prev) => prev.map((s) => (s.id === serviceId ? service : s)));
			console.error("Error saving changes:", error);
			toast.error("Failed to save changes");
		}
	};

	const fetchContainerData = async (containerType = null) => {
		if (!containerType) return {};
		try {
			const docRef = doc(db, COLLECTIONS.defaultPriceBook, "services", "containers", containerType);
			const docSnap = await getDoc(docRef);

			let docData = { id: docSnap.id, ...docSnap.data() };

			return docData;
		} catch (error) {
			console.error("Error fetching containers:", error);
		}
	};

	const handleAddNewContainer = async (serviceId) => {
		let containerData = editedData.serviceSummary?.[0];
		setNewContainerData({
			subWasteType: "",
			containerType: "",
			quantity: 1,
			weight: 0,
			rate: 0,
			total: 0,
			cost: 0,
			serviceType: containerData?.serviceType ?? "",
		});
		setShowAddContainerModal(true);
	};

	const handleAddNewDelContainer = async (serviceId) => {
		setNewDelContainers([
			...newDelContainers,
			{
				tempId: Date.now(),
				containerType: "",
				type: "",
				quantity: 1,
				priceBookData: null,
			},
		]);
	};

	const handleNewDelContainerChange = (tempId, field, value) => {
		setNewDelContainers(
			newDelContainers.map((container) => (container.tempId === tempId ? { ...container, [field]: value } : container))
		);
	};

	const handleRemoveNewDelContainer = (tempId) => {
		setNewDelContainers(newDelContainers.filter((c) => c.tempId !== tempId));
	};

	const handleDeleteContainer = async (serviceId, containerId) => {
		let toDeleteService = filteredData.find((item) => item.id == serviceId);
		if (toDeleteService?.serviceSummary?.length === 1) {
			toast.warn("All the containers cannot be removed!");
			return;
		}

		console.log("Deleting ", {
			serviceId,
			containerId,
			editedData,
			editing,
			toDeleteService: toDeleteService?.serviceSummary,
		});

		// Find the container to delete
		let container = toDeleteService?.serviceSummary?.find((item) => item.id === containerId);

		if (!container) {
			setEditedData((prev) => ({
				...prev,
				serviceSummary: prev.serviceSummary.filter((item) => item.tempId !== containerId),
			}));
			setIsDeleting(null);
			return;
		}

		try {
			toast.loading("Deleting container...");
			if (containerId && serviceId) {
				const batch = writeBatch(db);

				// Delete the container from `servicedContainers`
				batch.delete(doc(db, COLLECTIONS.servicedContainers, containerId));

				// Find the associated manifest
				const manifestQuery = query(
					collection(db, COLLECTIONS.manifests),
					where("containers", "array-contains", containerId)
				);
				const manifestSnap = await getDocs(manifestQuery);

				console.log("====================================");
				console.log({ ManifestEmpty: manifestSnap.empty, containerId });
				console.log("====================================");

				if (!manifestSnap.empty) {
					console.log("Manifest found");

					const manifestRef = doc(db, COLLECTIONS.manifests, manifestSnap.docs[0].id);
					const manifestData = manifestSnap.docs[0].data();

					console.log({ containerId, manifestData });

					batch.update(manifestRef, {
						containers: arrayRemove(containerId),
						isEdited: true,
						updatedAt: new Date(),
						url: null,
					});

					// If the manifest is left with no containers, delete it
					if (manifestData?.containers?.length === 1) {
						batch.delete(manifestRef);
						console.log(`Manifest with ID ${manifestSnap.docs[0].id} is now empty and will be deleted.`);
					}
				}

				// Updating `scheduledServices` document
				const serviceRef = doc(db, COLLECTIONS.scheduledServices, serviceId);
				const serviceSnap = await getDoc(serviceRef);
				if (!serviceSnap.exists()) {
					toast.error("Something went wrong while deleting the container");
					throw new Error(`Service ${serviceId} not found`);
				}

				const serviceUpdate = serviceSnap.data();
				const updatedContainers = serviceUpdate?.consolidated
					? serviceUpdate.consolidated.filter((item) => item.id !== containerId)
					: [];
				const updatedItemized = serviceUpdate?.itemized
					? serviceUpdate.itemized.filter((item) => item.id !== containerId)
					: [];

				console.log({ serviceUpdate, updatedContainers, containerId });

				batch.update(serviceRef, {
					consolidated: updatedContainers,
					itemized: updatedItemized,
				});

				await batch.commit();
				console.log("Batch commit successful!");

				// Updating local state after deletion
				setCompleteServices((prev) => {
					let updated = prev.map((service) =>
						service.id === serviceId
							? {
									...service,
									serviceSummary: service.serviceSummary.filter((c) => c.id !== containerId),
									manifestData: service.manifestData
										.map((manifest) => {
											let containerData = manifest.containers.filter((id) => id !== containerId);
											if (containerData.length === 0) return null;
											return {
												...manifest,
												containers: containerData,
											};
										})
										.filter(Boolean),
							  }
							: service
					);
					console.log("Updated completeServices:", updated);
					return updated;
				});

				setFilteredData((prev) => {
					let updated = prev.map((service) =>
						service.id === serviceId
							? {
									...service,
									serviceSummary: service.serviceSummary.filter((c) => c.id !== containerId),
									manifestData: service.manifestData
										.map((manifest) => {
											let containerData = manifest.containers.filter((id) => id !== containerId);
											if (containerData.length === 0) return null;
											return {
												...manifest,
												containers: containerData,
											};
										})
										.filter(Boolean),
							  }
							: service
					);
					console.log("Updated filteredData:", updated);
					return updated;
				});

				setEditedData((prev) => {
					if (!prev?.serviceSummary) return prev;
					let newServiceSummary = prev.serviceSummary.filter((item) => item.id !== containerId);
					console.log("Updated editedData:", { ...prev, serviceSummary: newServiceSummary });
					return { ...prev, serviceSummary: sortedServiceSummary(newServiceSummary) };
				});

				toast.dismiss();
				setIsDeleting(null);
				toast.success("Container deleted successfully!");
			}
		} catch (error) {
			console.error("Error deleting container:", error);
			toast.dismiss();
			toast.error("Failed to delete container.");
		}
	};

	const handleDeleteDelContainer = async (serviceId, containerId) => {
		toast.loading("Deleting container...");
		let toDeleteService = filteredData.find((item) => item.id == serviceId);

		if (toDeleteService.deliverySummary?.length == 1) {
			toast.warn("All the containers cannot be removed!");
			return;
		}

		try {
			const batch = writeBatch(db);
			console.log("Deleting ", serviceId, containerId);

			batch.delete(doc(db, COLLECTIONS.deliveredContainers, containerId));
			const deliveryRef = doc(db, COLLECTIONS.deliveries, toDeleteService.deliveryId);
			const deliverySnap = await getDoc(deliveryRef);

			if (deliverySnap.exists()) {
				const deliveryData = deliverySnap.data();
				const updatedContainers = deliveryData.containers.filter((id) => id !== containerId);

				if (updatedContainers.length === 0) {
					batch.delete(deliveryRef);
					console.log(`Delivery with ID ${toDeleteService.deliveryId} is now empty and will be deleted.`);
				} else {
					batch.update(deliveryRef, {
						containers: arrayRemove(containerId),
						url: "",
					});
				}
			}

			await batch.commit();

			setCompleteServices((prev) =>
				prev.map((service) =>
					service.id === serviceId
						? {
								...service,
								deliverySummary: service.deliverySummary.filter((c) => c.id !== containerId),
								deliveryReceipt: { ...service.deliveryReceipt, url: "" },
						  }
						: service
				)
			);

			setFilteredData((prev) =>
				prev.map((service) =>
					service.id === serviceId
						? {
								...service,
								deliverySummary: service.deliverySummary.filter((c) => c.id !== containerId),
								deliveryReceipt: { ...service.deliveryReceipt, url: "" },
						  }
						: service
				)
			);

			setEditedData((prev) => {
				let newDeliverySummary = prev.deliverySummary.filter((item) => item.id != containerId);
				return { ...prev, deliverySummary: newDeliverySummary };
			});
			toast.dismiss();
			setIsDeleting(null);
			toast.success("Container deleted successfully!");
		} catch (error) {
			console.error("Error deleting container:", error);
			toast.dismiss();
			toast.error("Failed to delete container.");
		}
	};

	const groupContainers = (containers, manifests) => {
		return containers.reduce((groups, container) => {
			const key = container.subWasteType;
			if (!groups[key]) {
				groups[key] = {
					containers: [],
					manifest: manifests.find((m) => m.subWasteType === key) || {},
					subtotal: { quantity: 0, weight: 0, total: 0 },
				};
			}
			groups[key].containers.push(container);
			groups[key].subtotal.quantity += Number(container.quantity);
			groups[key].subtotal.weight += Number(container.weight);
			groups[key].subtotal.total += Number(container.quantity) * Number(container.rate);
			return groups;
		}, {});
	};

	const totalCountData = useMemo(() => {
		let totalCounts = {};
		let unloggedCounts = 0,
			unavailableCounts = 0;

		filteredData
			?.filter((service) => selectedRows.includes(service.id))
			.forEach((item) => {
				if (item.serviceStatus == "UNLOGGED") {
					unloggedCounts++;
				} else if (item.serviceStatus == "UNAVAILABLE") {
					unavailableCounts++;
				}
				item.serviceSummary?.forEach((container) => {
					console.log({ container });
					const { subWasteType, quantity = 1, weight } = container;

					if (subWasteType === undefined) return;

					const qty = Number(quantity);
					const wgt = Number(weight);

					if (isNaN(qty) || isNaN(wgt)) return;

					totalCounts[subWasteType] = totalCounts[subWasteType] || {
						quantity: 0,
						weight: 0,
					};
					totalCounts[subWasteType].quantity += qty;
					totalCounts[subWasteType].weight += wgt;
				});
			});
		Object.keys(totalCounts).forEach((key) => {
			const { quantity, weight } = totalCounts[key];
			if (isNaN(quantity) || isNaN(weight)) {
				delete totalCounts[key];
			}
		});

		setUnavalogCount({
			["Unlogged"]: unloggedCounts,
			["Unavailable"]: unavailableCounts,
		});

		return totalCounts;
	}, [selectedRows]);

	console.log({ filteredData });

	return (
		<div
			style={{ height: selectedRows.length > 0 ? `calc(100% - 60px)` : "100%" }}
			className={`flex flex-col border-cardBorderCol overflow-clip bg-white rounded-cardRadii`}
		>
			<div className="h-fit">
				<div className="text-lg font-medium px-8 py-4 text-black">Service History Report</div>
				<FilterComp
					to={to}
					from={from}
					setTo={setTo}
					setFrom={setFrom}
					searchQuery={searchQuery}
					routeOptions={routeOptions}
					driverOptions={driverOptions}
					selectedRoutes={selectedRoutes}
					setSearchQuery={setSearchQuery}
					selectedDrivers={selectedDrivers}
					selectedServices={selectedServices}
					contractorOptions={contractorOptions}
					setSelectedRoutes={setSelectedRoutes}
					transStatusOptions={transStatusOptions}
					serviceTypeOptions={serviceTypeOptions}
					setSelectedDrivers={setSelectedDrivers}
					setSelectedServices={setSelectedServices}
					serviceStatusOptions={serviceStatusOptions}
					subContractorOptions={subContractorOptions}
					setContractorOptions={setContractorOptions}
					setSubContractorOptions={setSubContractorOptions}
					approvalOptionsForDropdown={approvalOptionsForDropdown}
					selectedTransStatusOptions={selectedTransStatusOptions}
					selectedServiceStatusOptions={selectedServiceStatusOptions}
					setSelectedTransStatusOptions={setSelectedTransStatusOptions}
					setSelectedServiceStatusOptions={setSelectedServiceStatusOptions}
					setDateFilterManuallyChanged={setDateFilterManuallyChanged}
					selectedSubWastes={selectedSubWastes}
					setSelectedSubWastes={setSelectedSubWastes}
					subWasteTypeOptions={subWasteTypeOptions}
					approvalOptions={approvalOptions}
					selectedApproved={selectedApproved}
					setSelectedApproved={setSelectedApproved}
				/>
			</div>
			<div className="px-8 py-3 bg-white border-b border-gray-200 flex items-center justify-between">
				<p className="text-sm text-gray-600 flex items-center">
					{!isLoading && (
						<p>
							{filteredData.length} of {totalC - unloggedCount} results
						</p>
					)}
				</p>
			</div>

			<div className={`flex flex-col w-full font-medium overflow-y-scroll`}>
				<div className="flex bg-whiteBlue w-fit py-4">
					<div className="w-8 mx-8 flex justify-center items-center hover:cursor-pointer">
						<input
							type="checkbox"
							ref={selectAllRef}
							className="w-4 h-4 bg-white"
							checked={selectAll}
							onChange={handleSelectAll}
						/>
					</div>
					<div className="flex items-center">
						<div className="truncate w-60">Service Date</div>
						<div className="truncate w-40">OCTO Number</div>
						<div className="truncate w-80">Generator</div>
						<div className="truncate w-48">Service Type</div>
						<div className="truncate w-40">Route</div>
						<div className="truncate w-40">Service Vehicle</div>
						<div className="truncate w-52">Driver</div>
						<div className="truncate w-48">Transporter ID</div>
						<div className="truncate w-48">Service Status</div>
						<div className="truncate w-40 text-center">Transfer Status</div>
					</div>
				</div>
				{isLoading ? (
					<Loader height="h-20 py-4 w-screen" />
				) : (
					<div className="flex flex-col w-fit overflow-y-auto">
						{!isFiltering && !isLoading && filteredData.length == 0 && (
							<div className="flex h-40  w-screen text-cardTextGray text-xl justify-center items-center">
								<p>No result found</p>
							</div>
						)}

						{filteredData.map((service, index) => (
							<div key={service.id} className="py-2 w-fit font-normal border-b">
								<DataTable
									handleRowCheckbox={handleRowCheckbox}
									selectedRows={selectedRows}
									service={service}
									transporterData={transporterData}
								/>
								<div className="flex w-full overflow-hidden gap-6 border-dashInActiveBtnText px-6 pl-10">
									<div className="w-[55%] border border-dashInActiveBtnText overflow-hidden">
										<div className="w-full bg-lightGray flex h-12 items-center justify-center gap-2">
											<h6 className="font-medium text-center">Service Summary</h6>
											{editing.serviceId === service.id && editing.section === "service" ? (
												<>
													<button className="text-primary text-sm" onClick={() => handleSave(service.id)}>
														Save
													</button>
													<button
														className="text-cardTextGray text-sm"
														onClick={() => {
															setEditing({
																serviceId: null,
																section: null,
																consentAcceptance: false,
															});
															setNewContainers([]);
															setEditedData({});
														}}
													>
														Cancel
													</button>
												</>
											) : (
												service.transferStatus !== transferStatusType.COMPLETE && (
													<button
														className="text-primary text-sm"
														onClick={() => handleEditClick(service.id, "service")}
													>
														(Edit)
													</button>
												)
											)}
										</div>
										<div className="px-4 pb-2">
											<>
												{service.serviceSummary?.length == 0 &&
													service.noWaste &&
													(editing.section == "service" && editing.serviceId == service.id ? (
														<p className="text-center py-2"></p>
													) : (
														<p className="text-center py-2">Delivery Only</p>
													))}
											</>
											{(service.serviceSummary?.length > 0 ||
												(editing.serviceId === service.id && editing.section === "service")) && (
												<div className="flex gap-2 text-left py-2 font-medium">
													<p className="w-[20%]">Subwaste Type</p>
													<p className="w-[30%]">Container</p>
													<p className="w-[8%]">Qty</p>
													<p className="w-[10%]">Weight</p>
													<p className="w-[8%]">Rate</p>
													<p className="w-[8%]">Total</p>
													<p className="w-[8%]">Cost</p>
													<p className="w-[8%]">
														{editing.serviceId === service.id && editing.section === "service" && "Delete"}
													</p>
												</div>
											)}
											{Object.entries(
												groupContainers(
													editing.serviceId === service.id && editing.section === "service"
														? [...editedData.serviceSummary]
														: service.serviceSummary,
													service.manifestData
												)
											).map(([subWasteType, group], i, arr) => {
												let groupTotal = 0;
												const subtotal = group.containers.reduce(
													(acc, container) => {
														let isPricePerPound = Boolean(container.priceBookData?.chargePerPound);
														const quantity = Number(container.quantity) || 1;
														const weight = Number(container.weight) || 0;

														const weightLimit = Number(container.priceBookData?.weightLimit) || 0;
														const servicePrice = Number(container.priceBookData?.servicePrice) || 0;
														const pricePerPound = Number(container.priceBookData?.pricePerPound) || 0;

														let containerTotal = 0;

														if (isPricePerPound) {
															containerTotal = weight * pricePerPound;
														} else {
															if (weight <= weightLimit) {
																containerTotal = quantity * servicePrice;
															} else {
																const extraWeight = weight - weightLimit;
																const baseCharge = quantity * servicePrice;
																const extraCharge = extraWeight * pricePerPound;
																containerTotal = baseCharge + extraCharge;
															}
														}

														return {
															quantity: acc.quantity + quantity,
															weight: acc.weight + weight,
															total: acc.total + containerTotal,
														};
													},
													{ quantity: 0, weight: 0, total: 0, cost: 0 }
												);

												return (
													<div key={subWasteType} className={`${i < arr.length - 1 ? "border-b border-black/40" : ""}`}>
														{group?.manifest?.manifestOctoId && (
															<button
																className="text-left text-primary hover:underline"
																onClick={() => handleManifestView(group?.manifest?.id, group.manifest?.url)}
															>
																{group?.manifest?.manifestOctoId}
															</button>
														)}

														{group.containers.map((summary, idx) => {
															let isPricePerPound = Boolean(summary.priceBookData?.chargePerPound);
															let containerTotal = 0;
															let rate = 0;

															const weight = Number(summary.weight);
															const weightLimit = Number(summary.priceBookData?.weightLimit) || 0;
															const servicePrice = Number(summary.priceBookData?.servicePrice) || 0;
															const pricePerPound = Number(summary.priceBookData?.pricePerPound) || 0;
															const quantity = Number(summary.quantity);

															if (isPricePerPound) {
																rate = pricePerPound;
																containerTotal = weight * rate;
															} else {
																if (weight <= weightLimit) {
																	rate = servicePrice;
																	containerTotal = quantity * rate;
																} else {
																	const extraWeight = weight - weightLimit;
																	const baseCharge = quantity * servicePrice;
																	const extraCharge = extraWeight * pricePerPound;

																	rate = servicePrice;
																	// rate = `${servicePrice} (base) + ${pricePerPound}/lb over limit`;
																	containerTotal = baseCharge + extraCharge;
																}
															}

															groupTotal += containerTotal;

															return (
																<div
																	key={summary.id || summary.tempId}
																	className="flex items-center gap-2 my-1 text-left"
																>
																	{editing.serviceId === service.id && editing.section === "service" ? (
																		<>
																			{/* Subwaste Type */}
																			<div className="w-[20%]">
																				{subWasteTypesMap[summary.subWasteType] || summary.subWasteType}
																			</div>

																			{/* Container Type Dropdown */}
																			<select
																				value={summary.containerType}
																				onChange={(e) =>
																					handleSubWasteTypeChange(
																						service.id,
																						"serviceSummary",
																						idx,
																						"containerType",
																						e.target.value,
																						subWasteType,
																						summary.id || summary.tempId
																					)
																				}
																				className="border rounded p-0.5 w-[30%] px-1"
																			>
																				<option value="" disabled hidden></option>
																				{Object.entries(serviceContainerPriceBook)
																					.filter(([value, data]) => data.subWasteType == summary.subWasteType)
																					.map(([value, data]) => (
																						<option key={value} value={value}>
																							{data.labelOCTOFieldApp}
																						</option>
																					))}
																			</select>

																			{/* Quantity Input */}
																			<input
																				className="border-b focus:outline-none w-[8%] px-1"
																				value={Number(summary.quantity)}
																				type="number"
																				disabled={summary.serviceType == "ITEMIZED"}
																				min={1}
																				onChange={(e) =>
																					handleFieldChange(
																						service.id,
																						"serviceSummary",
																						idx,
																						"quantity",
																						e.target.value,
																						summary.id || summary.tempId
																					)
																				}
																			/>

																			{/* Weight Input */}
																			<input
																				className="border-b focus:outline-none w-[10%] px-1"
																				value={Number(summary.weight)}
																				type="number"
																				min={0}
																				onChange={(e) =>
																					handleFieldChange(
																						service.id,
																						"serviceSummary",
																						idx,
																						"weight",
																						e.target.value,
																						summary.id || summary.tempId
																					)
																				}
																			/>

																			{/* Rate Display */}
																			<div className="w-[8%]">${rate?.toFixed(2)}</div>

																			{/* Total Display */}
																			<div className="w-[8%]">${containerTotal.toFixed(2)}</div>

																			{/* Cost Display */}
																			<div className="w-[8%]">
																				{summary.cost
																					? `$${(
																							Math.abs(Number(summary.cost)) / 100 +
																							Number(summary?.containerWashingFee)
																					  ).toFixed(2)}`
																					: ""}
																			</div>

																			{/* Delete Button */}
																			<button
																				onClick={() => {
																					console.log({ summary });
																					setIsDeleting({
																						serviceId: service.id,
																						containerId: summary.id ?? summary.tempId,
																						section: "service",
																					});
																				}}
																				className="text-red-500 w-[8%] hover:text-red-700"
																			>
																				<BiTrash className="w-4 h-4" />
																			</button>
																		</>
																	) : (
																		<>
																			<p className="w-[20%]">
																				{subWasteTypesMap[summary.subWasteType] ?? summary.subWasteType ?? "--"}
																			</p>
																			<div
																				className={`flex items-center gap-2 ${
																					service.expectedItemOrService?.includes(summary.containerType)
																						? ""
																						: "text-red-500"
																				} w-[30%]`}
																			>
																				<p>{containersMap[summary.containerType] ?? "--"}</p>
																				{!service.expectedItemOrService?.includes(summary.containerType) && (
																					<BsFillInfoCircleFill
																						size={14}
																						className="text-cardTextGray"
																						title="Out of Scope container was used while servicing this account"
																					/>
																				)}
																			</div>
																			<p className="w-[8%]">{summary.quantity ?? 1}</p>
																			<p className="w-[10%]">{weight.toFixed(2)}</p>
																			<p className="w-[8%]">${rate?.toFixed(2)}</p>
																			<p className="w-[8%]">${containerTotal?.toFixed(2)}</p>
																			<p className="w-[8%]">
																				{summary.cost
																					? `$${(
																							Math.abs(Number(summary.cost)) / 100 +
																							Number(summary?.containerWashingFee)
																					  ).toFixed(2)}`
																					: ""}
																			</p>
																			<p className="w-[8%]"></p>
																		</>
																	)}
																</div>
															);
														})}

														{/* Subtotal Row */}
														<div className="flex items-center gap-2 my-1 text-left font-semibold bg-gray-50 p-1">
															<p className="w-[20%]">Subtotal</p>
															<p className="w-[30%]"></p>
															<p className="w-[8%]">{subtotal.quantity}</p>
															<p className="w-[10%]">{subtotal.weight.toFixed(2)}</p>
															<p className="w-[8%]"></p>
															<p className="w-[8%]">${groupTotal.toFixed(2)}</p>
															<p className="w-[8%]"></p>
															<p className="w-[8%]"></p>
														</div>
													</div>
												);
											})}
											{editing.serviceId === service.id && editing.section === "service" && (
												<div className="flex gap-2 mt-2">
													<button className="text-primary text-sm" onClick={() => handleAddNewContainer(service.id)}>
														+ Add Container
													</button>
												</div>
											)}
										</div>
									</div>
									<DeliverySummaryContainer
										delContainersMap={delContainersMap}
										editedData={editedData}
										editing={editing}
										handleAddNewDelContainer={handleAddNewDelContainer}
										handleEditClick={handleEditClick}
										handleFieldChange={handleFieldChange}
										handleNewDelContainerChange={handleNewDelContainerChange}
										handleRemoveNewDelContainer={handleRemoveNewDelContainer}
										handleSave={handleSave}
										newDelContainers={newDelContainers}
										service={service}
										setEditedData={setEditedData}
										setEditing={setEditing}
										setIsDeleting={setIsDeleting}
										setNewDelContainers={setNewDelContainers}
									/>
									<OptionsContainer
										handleBillingCheckbox={handleBillingCheckbox}
										handlePaidCheckbox={handlePaidCheckbox}
										handleApprovedCheckbox={handleApprovedCheckbox}
										service={service}
									/>
								</div>
								<PictureSection
									service={service}
									generatorData={{ id: service.genId, generatorName: service.generatorName }}
									treatmentMap={treatmentMap}
								/>
							</div>
						))}
						{isLoadingMore && <Loader height="h-20 py-4 w-screen" />}
						{!isLoading && !isLoadingMore && hasMore && filteredData.length > 0 && (
							<div className="flex justify-center my-4 h-fit w-screen">
								<button
									onClick={loadMore}
									className="px-2 py-1 bg-creamWhite border border-cardTextGray rounded hover:bg-primary-dark"
								>
									Load More
								</button>
							</div>
						)}
					</div>
				)}
			</div>
			{editing.section && editing.serviceId && !editing.consentAcceptance && (
				<div className="z-40 fixed inset-0 bg-mediumGray bg-opacity-50 flex justify-center items-center ">
					<div className="modal-box">
						<div>
							<button
								className="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"
								type="button"
								onClick={() => {
									setEditing({ section: null, serviceId: null, consentAcceptance: false });
									setShowDropdowns(false);
								}}
							>
								
							</button>
						</div>
						<h3 className="font-bold text-lg">Are you sure?</h3>
						<div className="flex py-5 gap-5 flex-col">
							<p>You are about to edit this service!</p>

							{showDropdowns && (
								<div className="flex flex-col gap-4">
									<div>
										<label className="block text-sm font-medium mb-1">Select Driver</label>
										<select
											className="w-full p-2 border rounded bg-gray-100"
											value={selectedDriver}
											onChange={(e) => setSelectedDriver(e.target.value)}
										>
											<option value=""></option>
											{allDrivers.map(({ label, value }) => (
												<option key={label} value={value}>
													{label}
												</option>
											))}
										</select>
									</div>
									<div>
										<label className="block text-sm font-medium mb-1">Select Vehicle</label>
										<select
											className="w-full p-2 border rounded bg-gray-100"
											value={selectedVehicle}
											onChange={(e) => setSelectedVehicle(e.target.value)}
										>
											<option value=""></option>
											{serviceVehicleOptions.map(({ label, value }) => (
												<option key={value} value={value}>
													{label}
												</option>
											))}
										</select>
									</div>

									<button
										className="px-4 py-2 bg-primary disabled:bg-primaryGray disabled:text-black/40 disabled:border disabled:border-cardTextGray/40 text-white rounded"
										disabled={!selectedDriver || !selectedVehicle}
										onClick={async () => {
											let driver = allDrivers.find((item) => item.value == selectedDriver);
											let vehicle = serviceVehicleOptions.find((item) => item.value == selectedVehicle);
											let toUpdate = {
												assignedDriverId: driver?.value,
												assignedDriverName: driver?.label,
												assignedServiceVehicleId: vehicle.value,
												assignedServiceVehicleName: vehicle.label,
											};

											console.log({ toUpdate, selectedDriver, selectedVehicle, serviceId: editing.serviceId });

											let docRef = doc(db, "scheduledServices", editing.serviceId);

											try {
												await updateDoc(docRef, toUpdate);
												setSelectedDriver("");
												setSelectedVehicle("");
												setEditing((prev) => ({
													...prev,
													consentAcceptance: true,
													selectedDriver,
													selectedVehicle,
												}));
											} catch (error) {
												console.log(error);
												toast.error("Something went wrong!");
											} finally {
												setShowDropdowns(false);
											}
										}}
									>
										Confirm Selection
									</button>
								</div>
							)}
						</div>

						{!showDropdowns && (
							<div className="flex w-full justify-between">
								<button
									type="button"
									className="btn btn-error btn-sm"
									onClick={() => setEditing({ section: null, serviceId: null, consentAcceptance: false })}
								>
									No
								</button>
								<button
									className="btn btn-primary btn-sm"
									type="button"
									onClick={() => {
										const matchedService = completeServices.find((service) => service.id === editing.serviceId);
										if (matchedService?.serviceVehicleId && matchedService?.driverName) {
											setEditing((prev) => ({ ...prev, consentAcceptance: true }));
										} else {
											setShowDropdowns(true);
										}
										console.log({ allDrivers, serviceVehicleOptions });
									}}
								>
									Yes
								</button>
							</div>
						)}
					</div>
				</div>
			)}
			{isDeleting && (
				<DeleteConfirmationModal
					handleDeleteContainer={handleDeleteContainer}
					handleDeleteDelContainer={handleDeleteDelContainer}
					isDeleting={isDeleting}
					setIsDeleting={setIsDeleting}
				/>
			)}
			{showAddContainerModal && (
				<NewContainerModalHandler
					serviceContainerPriceBook={serviceContainerPriceBook}
					containersMap={containersMap}
					editedData={editedData}
					setEditedData={setEditedData}
					newContainerData={newContainerData}
					setNewContainerData={setNewContainerData}
					setNewContainers={setNewContainers}
					setShowAddContainerModal={setShowAddContainerModal}
				/>
			)}
			{!isLoading && <CounterHandler totalCountData={totalCountData} unavalogCount={unavalogCount} />}
			<FooterActionItems servicesSelected={selectedRows} />
		</div>
	);
};

export default ServiceReporting;

const DeleteConfirmationModal = ({ setIsDeleting, handleDeleteContainer, handleDeleteDelContainer, isDeleting }) => {
	return (
		<div className="z-40 fixed inset-0 bg-mediumGray bg-opacity-50 flex justify-center items-center ">
			<div className="modal-box">
				<div>
					<button
						className="btn btn-sm btn-circle btn-ghost absolute right-2 top-2"
						type="button"
						onClick={() => setIsDeleting(null)}
					>
						
					</button>
				</div>
				<h3 className="font-bold text-lg">Are you sure?</h3>
				<div className="flex py-5 gap-5 flex-col">
					<p className="">You are about to delete container of this service!</p>
				</div>
				<div className="flex w-full justify-between">
					<button type="button" className={`btn btn-error btn-sm`} onClick={() => setIsDeleting(null)}>
						{"No"}
					</button>
					<button
						className={`btn btn-primary btn-sm`}
						type="button"
						onClick={() => {
							if (isDeleting.section === "service") {
								handleDeleteContainer(isDeleting.serviceId, isDeleting.containerId);
							} else if (isDeleting.section === "delivery") {
								handleDeleteDelContainer(isDeleting.serviceId, isDeleting.containerId);
							}
						}}
					>
						{"Yes"}
					</button>
				</div>
			</div>
		</div>
	);
};

const NewContainerModalHandler = ({
	newContainerData,
	setNewContainerData,
	containersMap,
	serviceContainerPriceBook,
	editedData,
	setEditedData,
	setNewContainers,
	setShowAddContainerModal,
}) => {
	return (
		<div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
			<div className="bg-white p-6 w-96 rounded shadow">
				<h3 className="text-lg font-bold mb-4">Add New Container</h3>

				<div className="space-y-4">
					<div>
						<label className="block text-sm font-medium mb-1">Service Type</label>
						<select
							className="w-full p-2 border rounded"
							value={newContainerData.serviceType}
							disabled={newContainerData.serviceType?.length > 0}
							onChange={(e) => {
								const value = e.target.value;
								setNewContainerData((prev) => ({
									...prev,
									serviceType: value,
									quantity: value === "ITEMIZED" ? 1 : prev.quantity,
									serialNumber: value === "ITEMIZED" ? "" : "",
								}));
							}}
						>
							<option value=""></option>
							<option value="CONSOLIDATED">Consolidated</option>
							<option value="ITEMIZED">Itemized</option>
						</select>
					</div>
					{/* SubWaste Type (disabled) */}
					<div>
						<label className="block text-sm font-medium mb-1">Sub Waste Type</label>
						<select
							className="w-full p-2 border rounded bg-gray-100 cursor-not-allowed"
							value={newContainerData.subWasteType}
							disabled
						>
							<option value="">Subwaste Type</option>
							{Object.entries(subWasteTypesMap).map(([key, value]) => (
								<option key={value} value={value}>
									{subWasteTypesMap[key]}
								</option>
							))}
						</select>
					</div>

					{/* Container Type */}
					<div>
						<label className="block text-sm font-medium mb-1">Container Type</label>
						<select
							className="w-full p-2 border rounded"
							value={newContainerData.containerType}
							onChange={(e) => {
								let subWasteType = serviceContainerPriceBook[e.target.value]?.subWasteType;
								setNewContainerData((prev) => ({
									...prev,
									containerType: e.target.value,
									subWasteType,
									priceBookData: serviceContainerPriceBook[e.target.value] || null,
								}));
							}}
						>
							<option value="">Select Container Type</option>
							{Object.entries(containersMap)
								.map(([value, label]) => ({ value, label }))
								.filter((item) => !editedData.serviceSummary.map((item) => item.containerType).includes(item.value))
								.map(({ value, label }) => (
									<option key={value} value={value}>
										{label}
									</option>
								))}
						</select>
					</div>

					<div className={`${newContainerData.serviceType == "ITEMIZED" ? "block" : "hidden"}`}>
						<label className="block text-sm font-medium mb-1">Serial Number</label>
						<input
							type="text"
							className="w-full p-2 border rounded"
							placeholder="Serial Number"
							value={newContainerData.serialNumber}
							onChange={(e) => {
								setNewContainerData((prev) => ({
									...prev,
									serialNumber: e.target.value,
								}));
							}}
						/>
					</div>

					{/* Quantity */}
					<div>
						<label className="block text-sm font-medium mb-1">Quantity</label>
						<input
							type="number"
							className="w-full p-2 border rounded"
							placeholder="Quantity"
							value={newContainerData.quantity}
							min={1}
							disabled={newContainerData.serviceType === "ITEMIZED"}
							onChange={(e) => {
								const value = parseInt(e.target.value, 10);
								setNewContainerData((prev) => ({
									...prev,
									quantity: isNaN(value) || value < 1 ? 1 : value,
								}));
							}}
						/>
					</div>

					{/* Weight */}
					<div>
						<label className="block text-sm font-medium mb-1">Weight (lbs)</label>
						<input
							type="number"
							className="w-full p-2 border rounded"
							placeholder="Weight"
							value={newContainerData.weight}
							onChange={(e) =>
								setNewContainerData((prev) => ({
									...prev,
									weight: parseFloat(e.target.value) || 0,
								}))
							}
						/>
					</div>

					{/* Buttons */}
					<div className="flex justify-end space-x-2 pt-2">
						<button
							className="px-4 py-2 text-gray-500 hover:text-gray-700"
							onClick={() => {
								setShowAddContainerModal(false);
								let containerData = editedData.serviceSummary?.[0];
								setNewContainerData({
									subWasteType: "",
									containerType: "",
									quantity: 1,
									weight: 0,
									rate: 0,
									total: 0,
									cost: 0,
									serviceType: containerData?.serviceType ?? "",
								});
							}}
						>
							Cancel
						</button>

						<button
							className="px-4 py-2 bg-primary text-white rounded"
							onClick={() => {
								const { containerType, serviceType, quantity, weight } = newContainerData;

								if (!containerType) {
									toast.error("Please select a container type.");
									return;
								}

								if (!serviceType?.length) {
									toast.error("Please select a service type.");
									return;
								}

								if (serviceType == "ITEMIZED") {
									if (newContainerData.serialNumber?.trim()?.length == 0) {
										toast.error("Please enter the serial number.");
										return;
									}
								}

								if (quantity < 1) {
									toast.error("Quantity must be at least 1.");
									return;
								}

								if (!weight?.toString()) {
									toast.error("Weight must be greater than 0.");
									return;
								}

								const tempId = Date.now();
								const container = { ...newContainerData, tempId };

								setNewContainers((prev) => [...prev, container]);

								setEditedData((prev) => ({
									...prev,
									serviceSummary: [...prev.serviceSummary, container],
								}));

								setShowAddContainerModal(false);
								let containerData = editedData.serviceSummary?.[0];
								setNewContainerData({
									subWasteType: "",
									containerType: "",
									quantity: 1,
									weight: 0,
									rate: 0,
									total: 0,
									cost: 0,
									serviceType: containerData?.serviceType ?? "",
								});
							}}
						>
							Add Container
						</button>
					</div>
				</div>
			</div>
		</div>
	);
};

const CounterHandler = ({ totalCountData, unavalogCount }) => {
	return (
		<div className="bg-whiteBlue font-medium h-fit p-4 px-10 w-full min-w-fit grid grid-cols-1 sm:grid-cols-2 gap-4">
			{Object.entries(totalCountData).map(([key, value]) => (
				<div className="flex gap-1" key={key}>
					<p className="font-medium">
						{key}
						{"- "}{" "}
					</p>
					<p className="font-normal">Qty: {Number(value.quantity)}</p>
					<p className="font-normal">Weight: {Number(value.weight).toFixed(2)} (lbs)</p>
				</div>
			))}
			{Object.values(unavalogCount).find((item) => Number(item) > 0) &&
				Object.entries(unavalogCount).map(([key, value]) => (
					<div className="flex gap-1" key={key}>
						<p className="font-medium">
							{key}
							{"- "}{" "}
						</p>
						<p className="font-normal">{Number(value)}</p>
					</div>
				))}
		</div>
	);
};

const DeliverySummaryContainer = ({
	editing,
	service,
	handleSave,
	setEditing,
	setNewDelContainers,
	setEditedData,
	handleEditClick,
	editedData,
	delContainersMap,
	handleFieldChange,
	setIsDeleting,
	newDelContainers,
	handleNewDelContainerChange,
	handleAddNewDelContainer,
	handleRemoveNewDelContainer,
}) => {
	const deliverySummary = service?.deliverySummary ?? [];

	console.log();

	const combinedSummary = [
		...deliverySummary,
		...newDelContainers.map((c) => ({
			quantity: Number(c.quantity) || 1,
			salePrice: Number(delContainersMap?.[c.containerType]?.priceBookData?.salePrice || 0),
		})),
	];

	const subTotal = combinedSummary.reduce(
		(acc, curr) => {
			const qty = Number(curr.quantity) || 1;
			const rate = Number(curr?.priceBookData?.salePrice) || 0;
			acc.quantity += qty;
			acc.total += qty * rate;
			return acc;
		},
		{ quantity: 0, total: 0 }
	);

	console.log({ editedData });

	return (
		<div className="w-[40%] border border-dashInActiveBtnText overflow-hidden">
			<div className="bg-lightGray h-12 w-full flex items-center justify-center gap-2">
				<h6 className="font-medium text-center">Delivery Summary</h6>
				{editing.serviceId === service.id && editing.section === "delivery" ? (
					<>
						<button className="text-primary text-sm" onClick={() => handleSave(service.id)}>
							Save
						</button>
						<button
							className="text-cardTextGray text-sm"
							onClick={() => {
								setEditing({
									serviceId: null,
									section: null,
									consentAcceptance: false,
								});
								setNewDelContainers([]);
								setEditedData({});
							}}
						>
							Cancel
						</button>
					</>
				) : (
					service.transferStatus !== transferStatusType.COMPLETE && (
						<button className="text-primary text-sm" onClick={() => handleEditClick(service.id, "delivery")}>
							(Edit)
						</button>
					)
				)}
			</div>
			{service?.deliverySummary?.length == 0 && service.noDelivery && (
				<div className="w-full text-center py-1">
					<p>No Delivery</p>
				</div>
			)}
			<div className="flex flex-col flex-grow justify-between">
				<div className="px-4 pb-2">
					{service?.deliverySummary?.length > 0 && (
						<div className="flex gap-2 text-left py-2 font-medium">
							<p className="w-[40%]">Description</p>
							<p className="w-[15%]">Usage</p>
							<p className="w-[15%] text-center">Quantity</p>
							<p className="w-[10%] text-center">Rate</p>
							<p className="w-[10%] text-center">Total</p>
							{editing.serviceId !== service.id && <p className="w-[10%] text-center"></p>}
							{editing.serviceId === service.id && editing.section === "delivery" && (
								<p className="w-[10%] text-center">Delete</p>
							)}
						</div>
					)}

					{service?.deliverySummary?.length > 0 &&
						service?.deliveryReceipt &&
						service?.deliveryReceipt?.deliveryOctoId && (
							<button
								className="text-left mr-1 hover:underline text-primary"
								onClick={() => handleDeliveryView(service?.deliveryReceipt?.deliveryId, service?.deliveryReceipt?.url)}
							>
								{service?.deliveryReceipt?.deliveryOctoId}
							</button>
						)}
					{Array.isArray(service?.deliverySummary) ? (
						service.deliverySummary?.map((summary, idx) => {
							console.log({ summary });
							let rate = Number(summary.priceBookData?.salePrice ?? 0);
							let total = rate * Number(summary.quantity ?? 1);
							return (
								<div key={idx} className="flex gap-2 my-1 text-left">
									{editing.serviceId === service.id && editing.section === "delivery" ? (
										<>
											{/* Container Type Dropdown */}
											<select
												value={editedData.deliverySummary[idx].containerType}
												onChange={(e) =>
													handleFieldChange(service.id, "deliverySummary", idx, "containerType", e.target.value)
												}
												className="w-[40%] max-w-[40%] border rounded"
											>
												<option value="" disabled hidden></option>
												{Object.entries(delContainersMap).map(([value, label]) => (
													<option key={value} value={value}>
														{label}
													</option>
												))}
											</select>
											{/* Usage Type Dropdown */}
											<select
												value={editedData.deliverySummary[idx].type}
												onChange={(e) => handleFieldChange(service.id, "deliverySummary", idx, "type", e.target.value)}
												className="w-[15%] max-w-[15%] border rounded capitalize"
											>
												<option value="" disabled hidden></option>
												<option value="USE">Use</option>
												<option value="SUPPLY">Supply</option>
											</select>
											{/* Quantity Input */}
											<div className="w-[15%] flex items-center justify-center">
												<input
													className="w-16 border-b focus:outline-none"
													value={
														editedData.deliverySummary[idx].quantity
															? Number(editedData.deliverySummary[idx].quantity)
															: 1
													}
													type="number"
													min={1}
													onChange={(e) =>
														handleFieldChange(
															service.id,
															"deliverySummary",
															idx,
															"quantity",
															e.target.value ? e.target.value?.toString() : "1"
														)
													}
													onKeyDown={(e) => {
														if (e.key === "." || e.key === "e") {
															e.preventDefault();
														}
													}}
												/>
											</div>
											<div className="w-[10%] text-center">${isNaN(rate) ? "" : rate?.toFixed(2)}</div>
											<div className="w-[10%] text-center">${isNaN(total) ? "" : total?.toFixed(2)}</div>
											<div className="w-[10%] flex items-center justify-center">
												{editing.serviceId === service.id && editing.section === "delivery" && (
													<button
														onClick={() =>
															setIsDeleting({
																serviceId: service.id,
																containerId: editedData.deliverySummary[idx].id,
																section: "delivery",
															})
														}
														className="text-red-500 hover:text-red-700"
													>
														<BiTrash className="w-4 h-4" />
													</button>
												)}
											</div>
										</>
									) : (
										<>
											<p className="w-[40%] max-w-[40%]">{delContainersMap[summary?.containerType] ?? "--"}</p>
											<p className="w-[15%] capitalize">{summary?.type ?? "--"}</p>
											<p className="w-[15%] text-center">{summary.quantity ?? 1}</p>
											<p className="w-[10%] text-center">${isNaN(rate) ? "" : rate?.toFixed(2)}</p>
											<p className="w-[10%] text-center">${isNaN(total) ? "" : total?.toFixed(2)}</p>
											<p className="w-[10%] text-center"></p>
										</>
									)}
								</div>
							);
						})
					) : (
						<div className="w-full text-center py-2 text-secondary">
							<p>No data found</p>
						</div>
					)}
					{newDelContainers.map((delContainer, idx) => {
						console.log({ delContainer });
						let rate = 0;
						let total = 0;
						return (
							<div key={delContainer.tempId} className="flex gap-2 h-7 my-1 text-left items-center">
								<select
									value={delContainer.containerType}
									onChange={(e) => handleNewDelContainerChange(delContainer.tempId, "containerType", e.target.value)}
									className="w-[40%] max-w-[40%] border rounded"
								>
									<option value="" disabled hidden></option>
									{Object.entries(delContainersMap).map(([value, label]) => (
										<option key={value} value={value}>
											{label}
										</option>
									))}
								</select>
								{/* Usage Type Dropdown */}
								<select
									value={delContainer.type}
									onChange={(e) => handleNewDelContainerChange(delContainer.tempId, "type", e.target.value)}
									className="w-[15%] max-w-[15%] border rounded px-1 capitalize"
								>
									<option value="" disabled hidden></option>
									<option value="USE">Use</option>
									<option value="SUPPLY">Supply</option>
								</select>
								{/* Quantity Input */}
								<div className="w-[15%] flex items-center justify-center">
									<input
										className="w-16 border-b focus:outline-none"
										value={delContainer.quantity ? Number(delContainer.quantity) : 1}
										type="number"
										min={1}
										onChange={(e) =>
											handleNewDelContainerChange(
												delContainer.tempId,
												"quantity",
												e.target.value ? e.target.value?.toString() : "1"
											)
										}
										onKeyDown={(e) => {
											if (e.key === "." || e.key === "e") {
												e.preventDefault();
											}
										}}
									/>
								</div>
								<div className="w-[10%] text-center">${isNaN(rate) ? "" : rate?.toFixed(2)}</div>
								<div className="w-[10%] text-center">${isNaN(total) ? "" : total?.toFixed(2)}</div>
								<div className="w-[10%] flex items-center justify-center">
									<button
										onClick={() => handleRemoveNewDelContainer(delContainer.tempId)}
										className="text-red-500 hover:text-red-700"
									>
										<BiTrash className="w-4 h-4" />
									</button>
								</div>
							</div>
						);
					})}
					{editing.serviceId === service.id && editing.section === "delivery" && (
						<div className="flex gap-2 mt-2">
							<button className="text-primary text-sm" onClick={() => handleAddNewDelContainer(service.id)}>
								+ Add Container
							</button>
						</div>
					)}
				</div>
				{service?.deliverySummary?.length > 0 && (
					<div className="flex items-center gap-2 text-left font-semibold bg-gray-50 p-1 px-4">
						<p className="w-[40%]">Subtotal:</p>
						<p className="w-[15%]"></p>
						<p className="w-[15%] text-center">{subTotal.quantity}</p>
						<p className="w-[10%]"></p>
						<p className="w-[10%] text-center">${subTotal.total.toFixed(2)}</p>
						<p className="w-[10%]"></p>
					</div>
				)}
			</div>
		</div>
	);
};

export const FooterActionItems = ({ servicesSelected, services }) => {
	const deleteGenerators = () => {
		// const selectedGenIds = generators.filter((gen) => servicesSelected.includes(gen?.id)).map((gen) => gen.id);
		// try {
		// 	dispatch(deleteGenerator(selectedGenIds));
		// } catch (error) {
		// 	console.log(error);
		// }
	};

	const sendEmail = () => {
		// const selectedGens = generators
		// 	.filter((gen) => servicesSelected.includes(gen?.id))
		// 	.map((item) => item.generatorEmail)
		// 	.filter((item) => emailRegex.test(item))
		// 	.join(";");
		// window.open(`mailto:${selectedGens}`, "_blank");
	};

	const clickHandler = async (btnType) => {
		// if (btnType == "Delete") {
		// 	deleteGenerators();
		// } else if (btnType == "Email") {
		// 	sendEmail();
		// } else if (btnType == "Share") {
		// 	toast.info("Sharing feature is in progress!");
		// }
	};

	return (
		<div
			className={`fixed bottom-0 left-0 right-0 ml-72 shadow-md px-6 transition-all duration-300 ease-in-out ${
				servicesSelected?.length > 0 ? "translate-y-0" : "translate-y-full"
			}`}
		>
			<div className="w-full py-4 flex justify-between items-center">
				<span className="truncate">{servicesSelected?.length} item(s) selected</span>
				<div className="flex gap-2">
					<ExportComponent servicesSelected={servicesSelected} generators={servicesSelected} />
					<button
						className={`px-4 py-2 disabled:bg-cardTextGray disabled:bg-opacity-10 disabled:cursor-not-allowed bg-creamWhite hover:bg-cardTextGray hover:bg-opacity-10 border transition-colors duration-200 ease-in-out`}
						onClick={() => clickHandler("Send to Billing")}
					>
						Send to Billing
					</button>
				</div>
			</div>
		</div>
	);
};

const ExportComponent = ({ genSelected, generators }) => {
	const [progress, setProgress] = useState(0);
	const [isExporting, setIsExporting] = useState(false);
	const [isModalOpen, setIsModalOpen] = useState(false);

	// Close modal when clicking outside
	useEffect(() => {
		const handleClickOutside = (e) => {
			if (!isExporting && e.target.classList.contains("modal-overlay")) {
				setIsModalOpen(false);
			}
		};

		document.addEventListener("mousedown", handleClickOutside);
		return () => document.removeEventListener("mousedown", handleClickOutside);
	}, [isExporting]);

	const handleExport = async () => {
		setIsExporting(true);
		setIsModalOpen(true);
		setProgress(0);

		try {
			// // Step 1: Data preparation (20% of progress)
			// let data = generators.filter((item) => genSelected.includes(item.id));
			// const worksheetData = data.map((item, index) => {
			// 	setProgress((index / data.length) * 20);
			// 	return {
			// 		"Generator Name": item.name,
			// 		"OCTO Number": item.octoNumber,
			// 		"Internal Account Number": item.internalAccountNumber,
			// 		"Service Address": item.address,
			// 		"Service Phone": item.phone,
			// 		"Service Email": item.email,
			// 		Status: item.generatorStatus,
			// 		"Onboarding Stage": JSON.stringify(item.onboardingStatus ?? {}),
			// 	};
			// });
			// setProgress(20);

			// // Step 2: Create worksheet (40% of progress)
			// const workbook = XLSX.utils.book_new();
			// const worksheet = XLSX.utils.json_to_sheet(worksheetData);
			// XLSX.utils.book_append_sheet(workbook, worksheet, "DataSheet");
			// setProgress(40);

			// // Step 3: Convert to binary (70% of progress)
			// const excelBuffer = XLSX.write(workbook, {
			// 	bookType: "xlsx",
			// 	type: "array",
			// });
			// setProgress(70);

			// // Step 4: Create blob and prepare for download (90% of progress)
			// const blob = new Blob([excelBuffer], {
			// 	type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
			// });
			// setProgress(90);

			// // Step 5: Trigger download (100% of progress)
			// saveAs(blob, "exported_data.xlsx");
			// setProgress(100);

			// Reset after showing 100% completion
			setTimeout(() => {
				setIsExporting(false);
				setProgress(0);
				setIsModalOpen(false);
			}, 1000);
		} catch (error) {
			console.error("Export failed:", error);
			setIsExporting(false);
			setProgress(0);
			setIsModalOpen(false);
		}
	};

	return (
		<>
			<button
				onClick={handleExport}
				disabled={isExporting}
				className={`px-4 py-2 disabled:bg-cardTextGray disabled:bg-opacity-10 
			disabled:cursor-not-allowed bg-creamWhite hover:bg-cardTextGray hover:bg-opacity-10 
			border transition-colors duration-200 ease-in-out`}
			>
				{isExporting ? "Exporting..." : "Export"}
			</button>
		</>
	);
};

const FilterComp = ({
	to,
	from,
	setTo,
	setFrom,
	searchQuery,
	routeOptions,
	driverOptions,
	setSearchQuery,
	selectedRoutes,
	selectedDrivers,
	selectedServices,
	setSelectedRoutes,
	contractorOptions,
	serviceTypeOptions,
	transStatusOptions,
	setSelectedDrivers,
	setSelectedServices,
	serviceStatusOptions,
	subContractorOptions,
	setContractorOptions,
	setSubContractorOptions,
	selectedTransStatusOptions,
	selectedServiceStatusOptions,
	setSelectedTransStatusOptions,
	setSelectedServiceStatusOptions,
	setDateFilterManuallyChanged,
	setSelectedSubWastes,
	selectedSubWastes,
	subWasteTypeOptions,
	approvalOptions,
	approvalOptionsForDropdown,
	setSelectedApproved,
	selectedApproved,
}) => {
	const clearFilters = () => {
		setSearchQuery("");
		setTo(() => new Date());
		setFrom(() => new Date());
		setSelectedRoutes(["all", ...routeOptions.map((item) => item.value)]);
		setSelectedApproved(["all", ...approvalOptionsForDropdown.map((item) => item.value)]);
		setSelectedDrivers(["all", ...driverOptions.map((item) => item.value)]);
		setSelectedServices(["all", ...serviceTypeOptions.map((item) => item.value)]);
		setSelectedSubWastes(["all", ...subWasteTypeOptions.map((item) => item.value)]);
		setSelectedTransStatusOptions([...transStatusOptions.map((item) => item.value)]);
		setSelectedServiceStatusOptions([...serviceStatusOptions.map((item) => item.value)]);
	};

	return (
		<>
			<div className="px-8 flex items-center justify-between">
				<div className="flex items-center bg-white rounded-full p-3 px-4 border border-gray-200 w-full max-w-[50%]">
					<FiSearch className="text-cardTextGray opacity-50" size={20} />
					<input
						type="text"
						placeholder="Search by Name, OCTO Number, Phone, Email, Address, Documents "
						value={searchQuery}
						onChange={(e) => setSearchQuery(e.target.value)}
						className="pl-2 bg-transparent focus:outline-none text-cardTextGray flex-1 w-full"
					/>
				</div>
				<button className="text-primary hover:text-blue-900" onClick={clearFilters}>
					Clear Filter
				</button>
			</div>
			<div className="w-11/12 flex px-8 py-5">
				<div className="flex flex-wrap gap-5 gap-y-3 items-end">
					<div className="flex flex-col min-w-52">
						<p className="text-sm text-gray-500 px-2">From</p>
						<CustomDatePicker
							disableFutureDates={true}
							selectedDate={from}
							setSelectedDate={(value) => {
								setFrom(new Date(value));
								setDateFilterManuallyChanged(true);
							}}
							label={"From Date"}
						/>
					</div>
					<div className="flex flex-col min-w-52">
						<p className="text-sm text-gray-500 px-2">To</p>
						<CustomDatePicker
							disableFutureDates={true}
							selectedDate={to}
							setSelectedDate={(value) => {
								setTo(new Date(value));
							}}
							label={"To Date"}
						/>
					</div>
					<MultiselectDropdown
						width="w-48"
						buttonText="Service Type"
						options={serviceTypeOptions}
						selectedOptions={selectedServices}
						onSelectedOptionsChange={(values) => setSelectedServices(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Subwaste Type"
						options={subWasteTypeOptions}
						selectedOptions={selectedSubWastes}
						onSelectedOptionsChange={(values) => setSelectedSubWastes(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Approval"
						options={approvalOptions}
						selectedOptions={selectedApproved}
						onSelectedOptionsChange={(values) => setSelectedApproved(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Route"
						options={routeOptions}
						selectedOptions={selectedRoutes}
						onSelectedOptionsChange={(values) => setSelectedRoutes(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Driver"
						options={driverOptions}
						selectedOptions={selectedDrivers}
						onSelectedOptionsChange={(values) => setSelectedDrivers(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Service Status"
						options={serviceStatusOptions}
						selectedOptions={selectedServiceStatusOptions}
						onSelectedOptionsChange={(values) => setSelectedServiceStatusOptions(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Contractor"
						options={[]}
						selectedOptions={contractorOptions}
						onSelectedOptionsChange={(values) => setContractorOptions(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Subcontractor"
						options={[]}
						selectedOptions={subContractorOptions}
						onSelectedOptionsChange={(values) => setSubContractorOptions(values)}
					/>
					<MultiselectDropdown
						width="w-48"
						buttonText="Transfer Status"
						options={transStatusOptions}
						selectedOptions={selectedTransStatusOptions}
						onSelectedOptionsChange={(values) => setSelectedTransStatusOptions(values)}
					/>
				</div>
			</div>
		</>
	);
};

const PictureSection = ({ service, generatorData, treatmentMap }) => {
	console.log({ generatorData, service });

	return (
		<div className="flex flex-col px-10 py-6">
			<div className="flex justify-between">
				<div className="flex gap-4">
					<p className="w-32 font-medium">Images:</p>
					{service?.picture?.length > 0 ? (
						service.picture.map((item, i) => (
							<Link target="_blank" key={item.url} className="text-primary underline" to={item.url}>
								View Image {i + 1}
							</Link>
						))
					) : (
						<p>N/A</p>
					)}
				</div>
				<div className="flex gap-4 w-[18%]">
					<p className="w-32 font-medium">Contractor:</p>
					<p>{service?.contractorName}</p>
				</div>
			</div>
			<div className="flex justify-between">
				<div>
					{service?.tempServiceIns?.length > 0 && (
						<div className="flex gap-4">
							<p className="text-nowrap w-60 font-red-500 font-medium">Temporary Service Instructions:</p>
							<p className="w-full max-w-96 text-wrap text-red-500">{service?.tempServiceIns}</p>
						</div>
					)}
					<div className="flex gap-4">
						<p className="text-nowrap w-32 font-medium">Driver Note:</p>
						<p>{service?.driverNote}</p>
					</div>
				</div>
				<div className="flex gap-4 w-[18%] h-fit">
					<p className="text-nowrap min-w-32 font-medium">Subcontractor:</p>
					<p>{service?.subcontractorName}</p>
				</div>
			</div>
			<div className="flex justify-end">
				<div className="flex gap-4 w-[18%] h-fit">
					<p className="text-nowrap min-w-32 font-medium">TS/TF:</p>
					<p>{treatmentMap?.[service?.treatmentId]}</p>
				</div>
			</div>
		</div>
	);
};

const DataTable = ({ service, selectedRows, handleRowCheckbox, transporterData }) => {
	return (
		<div className="flex w-fit items-center pt-2 pb-6">
			<div className="min-w-8 mx-8 flex justify-center hover:cursor-pointer">
				<input
					type="checkbox"
					className="w-4 h-4 bg-white"
					checked={selectedRows.includes(service.id)}
					onChange={(e) => handleRowCheckbox(e, service.id)}
				/>
			</div>
			<div className="flex items-center">
				<div className="truncate w-60">
					{service.markedAsClosedAt
						? formattedDateTime(service.markedAsClosedAt)
						: service.canceledAt
						? formattedDateTime(service.canceledAt)
						: service.completedAt
						? formattedDateTime(service.completedAt)
						: formatUtcDateString(service.date.toDate().toUTCString())}
				</div>
				<div className="truncate w-40">{service.octoNumber}</div>
				<div className="truncate w-80 text-thatblue">
					<Link to={`/admin/generators/${service.genId}/generator-dashboard`}>{service.generatorName}</Link>
				</div>
				<div className="truncate w-48">{serviceTypesMap?.[service.serviceType]}</div>
				<div className="truncate w-40">{service.routeName}</div>
				<div className="truncate w-40">{service.pickUpTruck}</div>
				<div className="truncate w-52">{service.driverName}</div>
				<div className="truncate w-48">{transporterData?.transporterOctoId}</div>
				<div className="truncate w-48 flex items-center gap-1">
					{capitalizeFirstLetter(service?.serviceStatus)}
					{service?.earlierStatus?.length > 0 && (
						<BsFillInfoCircleFill
							size={14}
							className="text-cardTextGray"
							title={`This was ${
								service.earlierStatus === "CANCELED" ? "a" : "an"
							} ${service.earlierStatus.toLowerCase()} service`}
						/>
					)}
				</div>
				<div className="truncate w-40 text-center">
					{service.completedAt
						? service.transferStatus == TRANSFER_STATUS.COMPLETE
							? "Transferred"
							: "In Transit"
						: "--"}
				</div>
			</div>
		</div>
	);
};

const processedServiceData = ({
	serviceData,
	generatorDataRef,
	generatorData,
	transData,
	routeRes,
	routeData,
	serviceTypeString,
	user,
	manifestData,
	serviceSummary,
	deliverySummary,
	deliveryReceipt,
	transporterData,
}) => {
	// Scheduled by
	const scheduledBy = serviceData?.transporterId;

	const isSubContracted = scheduledBy != user?.uid;

	console.log({ scheduledBy, isSubContracted, userId: user?.uid, generatorData });

	let resp = {
		id: serviceData.id,
		date: serviceData.date,
		completedAt: serviceData.completedAt,
		time: serviceData.date?.toDate(),
		driverNote: serviceData?.driverNote?.length > 0 ? serviceData?.driverNote : "--",
		tempServiceIns: serviceData?.temporaryServiceInstruction,
		customerId: generatorDataRef.id,
		generatorId: generatorData.id,
		serviceId: serviceData.id,
		completedViaServiceHistoryPage: Boolean(serviceData.completedViaServiceHistoryPage),
		scheduleId: serviceData.serviceScheduleId,
		generatorName: `${generatorData?.generatorName ?? "--"} `,
		email: generatorData.serviceAddress?.email?.length ? generatorData.serviceAddress?.email : "--",
		phone: generatorData.serviceAddress?.phone?.length ? generatorData.serviceAddress?.phone : "",
		internalAccountNumber: generatorData.internalAccountNumber?.length ? generatorData.internalAccountNumber : "--",
		genId: generatorData.id,
		expectedItemOrService: serviceData.scheduleData
			? serviceData.scheduleData?.expectedItemOrService
				? serviceData.scheduleData?.expectedItemOrService?.map((e) => e.item)
				: []
			: [],
		driverId: serviceData.assignedDriverId,
		deliveryId: transData.length > 0 ? transData?.[0].id : null,
		octoNumber: octoFormatter(generatorData.octoNumber) ?? "--",
		address: getFormattedAddress(generatorData?.serviceAddress),
		billed: Boolean(serviceData?.billed),
		billingMethod: serviceData?.billingMethod,
		billingNote: serviceData?.billingNote,
		billedDate: serviceData?.billedDate?.toDate()?.toLocaleDateString() ?? null,
		paidDate: serviceData?.paidDate?.toDate()?.toLocaleDateString() ?? null,
		approvedDate: serviceData?.approvedDate?.toDate()?.toLocaleDateString() ?? null,
		approvedNote: serviceData?.approvedNote,
		approved: serviceData?.approved ? true : false,
		paid: serviceData?.paid ?? false,
		noDelivery: Boolean(serviceData.noDelivery),
		contractorName: isSubContracted
			? generatorData?.subContractors?.find((item) => item.id == scheduledBy)?.subContractorName
			: transporterData?.transporterName,
		subContractorName: isSubContracted
			? generatorData?.subContractors?.find((item) => item.id == scheduledBy)?.name
			: "",
		adminNote: serviceData?.adminNote ?? "",
		paidAmount: serviceData?.paidAmount ?? "--",
		picture: Array.isArray(serviceData?.serviceImages) ? serviceData?.serviceImages : [],
		optionChecked: false,
		driverName: `${serviceData?.assignedDriverName ?? "--"}`,
		pickUpTruck: `${serviceData?.assignedServiceVehicleName ?? "--"}`,
		serviceType: serviceTypeString ?? "--",
		routeName: routeData?.routeLabel ?? "--",
		routeId: routeRes.id ?? "--",
		quantity: "--",
		totalWeight: "--",
		serviceVehicleId: serviceData.assignedServiceVehicleId,
		transporterId: user.uid,
		earlierStatus: serviceData?.earlierStatus ?? "",
		serviceStatus:
			serviceData?.status === SERVICE_STATUS.PENDING || serviceData?.status === SERVICE_STATUS.INPROGRESS
				? "UNLOGGED"
				: serviceData?.status === SERVICE_STATUS.COMPLETE
				? "COMPLETE"
				: serviceData?.status === SERVICE_STATUS.CLOSED
				? "UNAVAILABLE"
				: serviceData?.status === SERVICE_STATUS.CANCELLED
				? "CANCELED"
				: "",
		transferStatus: serviceData?.transferStatus,
		treatmentId: serviceData?.transferStatus === "COMPLETE" ? serviceData.transferredContainers?.[0]?.treatmentId : "",
		transferredContainers: serviceData.transferredContainers ?? [],
		subWasteType: serviceSummary.length > 0 ? [...new Set(serviceSummary.map((item) => item?.subWasteType))] : [],
		serviceSummary,
		deliverySummary,
		deliveryReceipt,
		noWaste: serviceData?.noWaste,
		manifestData: manifestData?.filter(
			(manifest, index, self) => index === self.findIndex((m) => m.manifestOctoId === manifest.manifestOctoId)
		),
		markedAsClosedAt: serviceData?.status === SERVICE_STATUS.CLOSED ? serviceData?.markedAsClosedAt?.toDate() : null,
		canceledAt:
			serviceData?.status === SERVICE_STATUS.CANCELLED
				? (serviceData?.canceledAt ?? serviceData?.cancelledAt)?.toDate()
				: null,
	};
	if (serviceData.generatorId == "Tf7tyAV0CAeTE9Ub3JZQ") {
		console.log({ resp });
	}
	return resp;
};
