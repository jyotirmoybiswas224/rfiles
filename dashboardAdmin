import { useEffect, useRef, useState, useMemo, useCallback } from "react";
import { CheckCircleIcon, ClockIcon, ArrowRightIcon } from "lucide-react";
import CalendarWithTimeSlots from "./components/open-calendar/GeneratorCalendarComponent";
import GeneratorDetailsForm from "./components/GeneratorDetailsForm/GeneratorDetailsForm";
import GeneratorOfficeHours from "./components/GeneratorOfficeHours/GeneratorOfficeHours";
import { useGeneratorUser } from "../../../../../../../context/GeneratorUserContext";
import { useNavigate, useLocation } from "react-router-dom";
import Loader from "../../../../../../../components/UI/loaders/Loader";
import {
	dateFormatter,
	daysOfWeek,
	renderAddress,
	randomizeCoordinates,
	octoFormatter,
	formatDateString,
	formattedDate,
} from "../../../../../../../utils/helpers";
import {
	frequencyPrimaryOptions,
	frequencySecondaryOptions,
	scheduledServiceStatus,
	SERVICE_STATUS,
	serviceTypes,
} from "../../../../../../../utils/constants";
import {
	collection,
	doc,
	getDoc,
	onSnapshot,
	orderBy,
	query,
	where,
	getDocs,
	Timestamp,
	limit,
} from "firebase/firestore";
import { SERVICE_TYPES } from "../../../../../../../utils/constants";
import { Map } from "@vis.gl/react-google-maps";
import { getGeneratorById } from "../../../../../../../utils/firebaseOperations";
import { useParams } from "react-router-dom";
import { useBreadcrumb } from "../../../../../../../context/BreadcrumbContext";
import { COLLECTIONS, db } from "../../../../../../../config/firebase";
import { AzureMapsProvider } from "react-azure-maps";
import CustomAzureGeneratorDashboardMap from "../../../../../../generator-portal/dashboard/CustomAzureGeneratorDashboardMap";
import ChildDropdown from "../../../../../../generator-portal/dashboard/components/dropDowns/childDropdown";
import ParentDropdown from "../../../../../../generator-portal/dashboard/components/dropDowns/parentDropdown";
import { endOfMonth, startOfMonth } from "date-fns";
import useTUserContext from "../../../../../../../context/TransporterUserContext";
import { useSSRManagement } from "../../../../../../../utils/useSsrRequests";

const DASHBOARD = "generator-dashboard";
const PROFILE = "generator-profile";
const CONTACTS = "generator-contacts";
const NOTES = "service-notes";
const ROUTES = "routes";
const GEN_HOME_ROUTE = "/admin/generators";
const SERVICE_CALENDAR = "service-calendar";

const GeneratorDashboardAdmin = ({ setGeneratorData, generatorData }) => {
	const { user, loading } = useTUserContext();
	
	// Add SSR management for accessing loading state and activeSentSSRs
	const { 
		activeSentSSRs, 
		isDataLoaded: ssrDataLoaded, 
		isLoading: ssrLoading 
	} = useSSRManagement(user?.uid, generatorData?.id);
	
	const [allServices, setAllServices] = useState({});
	const navigate = useNavigate();
	const [nextService, setNextService] = useState(null);
	const [lastCompleted, setLastCompleted] = useState(null);
	const contactFormRef = useRef();
	const { id: genId } = useParams();
	const [todayService, setTodayService] = useState([]);
	const location = useLocation();
	const [isLoading, setIsLoading] = useState(true);
	const [error, setError] = useState("");
	const [routeStarted, setRouteStarted] = useState(null);
	const [progressBar, setProgressbar] = useState("0%");
	const formName = location.pathname.split("/").pop();
	const { handleSetBreadcrumb, handleStepCompletion } = useBreadcrumb();
	const [waypointsRemaining, setWaypointsRemaining] = useState("Stops Remaining");
	const [completed, setCompleted] = useState(false);
	const [generatorWaypointCompleted, setGeneratorWaypointCompleted] = useState(false);
	const [sameParentGenerators, setSameParentGenerators] = useState(null);
	const [parentGenerator, setParentGenerator] = useState(null);
	const [stopsRemaining, setStopsRemaining] = useState(0);
	const [value, setValue] = useState("");
	const [serviceFrequency, setServiceFrequency] = useState("");
	const [isParent, setIsParent] = useState(null);
	const [parentData, setParentData] = useState({});
	const [randomCoordinates, setRandomCoordinates] = useState({ lat: 33.0181007, lng: 117.0809945 });
	const [allServiceFrequencies, setAllServiceFrequencies] = useState([
		...frequencyPrimaryOptions,
		...frequencySecondaryOptions,
	]);
	const [serviceCompletionText, setServiceCompletionText] = useState("");
	const [todayStartedRoute, setTodayStartedRoute] = useState();
	const [transporterName, setTransporterName] = useState("");
	const [delay, setDelay] = useState(0);

	const subscriptionsRef = useRef([]);
	const generatorCompletionStatusRef = useRef({});

	useEffect(() => {
		window._processingGenerator = null;
		generatorCompletionStatusRef.current = {};

		return () => {
			console.log("Component unmounting - cleaning up");
			if (subscriptionsRef.current) {
				subscriptionsRef.current.forEach((unsub) => {
					if (typeof unsub === "function") {
						try {
							unsub();
						} catch (e) {
							console.error("Error unsubscribing:", e);
						}
					}
				});
				subscriptionsRef.current = [];
			}

			generatorCompletionStatusRef.current = {};
			window._processedGenerators = {};
		};
	}, []);

	useEffect(() => {
		if (!generatorData?.id) return;
		const q = query(collection(db, COLLECTIONS.serviceSchedules), where("generatorId", "==", generatorData.id));
		const unsubscribe = onSnapshot(q, async (snap) => {
			try {
				const tempSchedules = await Promise.all(
					snap.docs.map(async (el) => {
						if (!el.exists()) return null;

						const data = { ...el.data(), id: el.id };
						if (Array.isArray(data.serviceType)) {
							data.serviceType = data.serviceType[0];
						}
						if (data.isDeleted) return null;
						let createdAt = null;
						if (data.createdAt?.seconds || data.createdAt?.nanoseconds) {
							createdAt = new Timestamp(data.createdAt.seconds, data.createdAt.nanoseconds).toDate();
						} else if (data.createdAt?.toDate) {
							createdAt = data.createdAt.toDate();
						} else {
							createdAt = new Date();
						}

						return { ...data, createdAt };
					})
				);
				const filteredSchedules = tempSchedules.filter(Boolean);
				filteredSchedules.sort((a, b) => a.createdAt - b.createdAt);

				const formattedServiceTypes = [...new Set(filteredSchedules.map((item) => item.serviceType))]
					.map((service) => {
						const matchedService = serviceTypes.find((type) => type.value === service);
						return matchedService ? matchedService.label : service;
					})
					.join(", ");

				console.log(formattedServiceTypes);
				const uniqueServiceTypes = [
					...new Set(
						filteredSchedules.map((item) => {
							const type = item.serviceFrequency?.type;
							return type;
						})
					),
				];
				uniqueServiceTypes.filter(Boolean);
				setValue(formattedServiceTypes);
				setServiceFrequency(uniqueServiceTypes);
			} catch (error) {
				console.error("Error processing snapshot:", error);
			}
		});
		return () => {
			console.log("Unsubscribing from snapshot listener");
			unsubscribe();
		};
	}, [generatorData?.id]);

	useEffect(() => {
		if (![DASHBOARD, PROFILE, CONTACTS, NOTES, ROUTES].includes(formName)) {
			return navigate(`${GEN_HOME_ROUTE}/${genId}/${DASHBOARD}`);
		}
	}, [location.pathname]);

	useEffect(() => {
		if (!generatorData?.id) return;
		if (parentData.parentAccount) {
			setIsParent(false);
		} else {
			setIsParent(true);
		}

		//	performInitialServiceStatusCheck(generatorData.id);
	}, [generatorData?.id]);

	useEffect(() => {
		console.log({ generatorData });
		if (!generatorData) return;
		if (
			generatorData?.serviceAddCoordinates &&
			generatorData.serviceAddCoordinates?.lat &&
			generatorData.serviceAddCoordinates?.lng
		) {
			setRandomCoordinates(
				randomizeCoordinates(generatorData.serviceAddCoordinates?.lat, generatorData.serviceAddCoordinates?.lng)
			);
		}

		return () => {};
	}, [generatorData]);

	useEffect(() => {
		const fetchDataOfGenerator = async () => {
			const data = await getGeneratorById(genId);
			if (!data) setError("Generator not found");
			else {
				setParentData(data);
				handleSetBreadcrumb("generator-dashboard", data?.octoNumber?.dashboardCompleted);
				handleStepCompletion("Generator Profile", data?.onboardingStatus?.profileCompleted);
				handleStepCompletion("Generator Contacts", data?.onboardingStatus?.contactsCompleted);
				handleStepCompletion("Service Notes", data?.onboardingStatus?.serviceNotesCompleted);
				handleStepCompletion("Routes", data?.onboardingStatus?.routesCompleted);
				handleStepCompletion("Service Calendar", true);
			}
			setIsLoading(false);
		};

		if (genId) {
			fetchDataOfGenerator(genId);
			// dispatch(fetchGenerator());
		}
	}, [genId, navigate]);

	useEffect(() => {
		if (!generatorData?.id) return;
		const currentDate = new Date();
		const currentYear = currentDate.getFullYear();
		const startOfYear = new Date(Date.UTC(currentYear, 0, 1, 0, 0, 0, 0));
		const endOfYear = new Date(Date.UTC(currentYear, 11, 31, 23, 59, 59, 999));
		const unsubscribe = onSnapshot(
			query(
				collection(db, COLLECTIONS.scheduledServices),
				where("generatorId", "==", generatorData.id),
				where("status", "not-in", [SERVICE_STATUS.DELETED, SERVICE_STATUS.CANCELLED]),
				where("date", ">=", Timestamp.fromDate(startOfYear)),
				where("date", "<=", Timestamp.fromDate(endOfYear)),
				orderBy("date", "asc")
			),
			async (snap) => {
				try {
					let tempServices = [];
					const jobs = snap.docs.map(async (el) => {
						if (el.exists()) {
							const data = { ...el.data(), id: el.id };
							if (data?.routeId?.length > 0) {
								const routeRes = await getDoc(doc(db, COLLECTIONS.routes, data.routeId));
								if (routeRes.exists()) {
									data.routeData = { ...routeRes.data(), id: routeRes.id };
								}
							}
							if (data?.serviceScheduleId?.length > 0) {
								const serviceScheduleRes = await getDoc(doc(db, COLLECTIONS.serviceSchedules, data.serviceScheduleId));
								if (serviceScheduleRes.exists()) {
									data.serviceScheduleData = { ...serviceScheduleRes.data(), id: serviceScheduleRes.id };
								}
							}
							tempServices.push(data);
						}
					});
					await Promise.all(jobs);
					tempServices = tempServices.sort((a, b) => a.date.toDate() - b.date.toDate());

					if (user.uid && generatorData?.transporterId != user.uid) {
						tempServices = tempServices.filter((service) => service.routeData.transporterId === user.uid);
					}

					setAllServices(tempServices);
				} catch (error) {
					console.error("Error processing snapshot:", error);
				}
			}
		);

		return () => {
			console.log("Unsubscribing from snapshot listener");
			unsubscribe();
		};
	}, [generatorData?.id]);

	const [childrenData, setChildrenData] = useState([]);

	useEffect(() => {
		if (!generatorData?.id) return;

		const unsubscribe = onSnapshot(
			query(collection(db, COLLECTIONS.generators), where("parentAccount", "==", genId)),
			async (snap) => {
				try {
					const data = snap.docs.map((doc) => doc.data());
					setChildrenData(data);
				} catch (error) {
					console.error("Error processing snapshot:", error);
				}
			}
		);
		if (generatorData.parentAccount) {
			const unsubscribe2 = onSnapshot(
				query(collection(db, COLLECTIONS.generators), where("parentAccount", "==", generatorData.parentAccount)),
				async (snap) => {
					try {
						const data = snap.docs.map((doc) => doc.data());
						setSameParentGenerators(data);
					} catch (error) {
						console.error("Error processing snapshot:", error);
					}
				}
			);

			const unsubscribe3 = onSnapshot(
				query(collection(db, COLLECTIONS.generators), where("id", "==", generatorData.parentAccount)),
				async (snap) => {
					try {
						const data = snap.docs.map((doc) => doc.data());
						setParentGenerator(data);
						console.log("psrentgen", data);
					} catch (error) {
						console.error("Error processing snapshot:", error);
					}
				}
			);
			return () => {
				console.log("Unsubscribing from snapshot listener");
				unsubscribe();
				unsubscribe2();
				unsubscribe3();
			};
		}
	}, [generatorData?.id, generatorData?.parentAccount]);

	useEffect(() => {
		if (!allServices?.length) return;
		const today = new Date();
		today.setHours(0, 0, 0, 0);

		const filteredDate = allServices?.filter((el) => {
			const serviceDate = el.date.toDate();
			return serviceDate.getTime() >= today.getTime();
		});

		const filteredCompleted = allServices?.filter((el) => el.status === SERVICE_STATUS.COMPLETE);
		if (filteredCompleted) {
			console.log("completed service", filteredCompleted, "yguyg", filteredCompleted[filteredCompleted.length - 1]);

			//setLastCompleted(filteredCompleted[filteredCompleted.length - 1]);
		} else {
			//setLastCompleted(null);
		}
		setCompleted(false);
		if (filteredDate.length) {
			//	setNextService(filteredDate[0]);
		}
	}, [allServices]);

	const startDate = new Date();
	startDate.setDate(startDate.getDate() - 30);
	const endDate = new Date();
	endDate.setDate(endDate.getDate() + 30);
	useEffect(() => {
		setServiceCompletionText("");
		setCompleted(false);
		setGeneratorWaypointCompleted(false);
		setWaypointsRemaining("Stops Remaining");
		setRouteStarted(false);
		setProgressbar("0%");
		setStopsRemaining(0);
	}, [generatorData?.id]);

	useEffect(() => {
		if (!generatorData?.id) return;

		const unsubscribers = [];
		const date = new Date();
		const todayUTC = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0));

		try {
			const servicesUnsubscribe = onSnapshot(
				query(
					collection(db, COLLECTIONS.scheduledServices),
					where("generatorId", "==", generatorData?.id),
					where("status", "not-in", [SERVICE_STATUS.CANCELLED, SERVICE_STATUS.DELETED]),
					where("date", ">=", Timestamp.fromDate(startDate)),
					where("date", "<=", Timestamp.fromDate(endDate)),
					orderBy("date", "asc")
				),
				async (snap) => {
					try {
						let tempServices = [];
						const jobs = snap.docs.map(async (el) => {
							if (el.exists()) {
								const data = { ...el.data(), id: el.id };
								if (data?.routeId?.length > 0) {
									const routeRes = await getDoc(doc(db, COLLECTIONS.routes, data.routeId));
									if (routeRes.exists()) {
										data.routeData = { ...routeRes.data(), id: routeRes.id };
									}
								}
								if (data?.serviceScheduleId?.length > 0) {
									const serviceScheduleRes = await getDoc(
										doc(db, COLLECTIONS.serviceSchedules, data.serviceScheduleId)
									);
									if (serviceScheduleRes.exists()) {
										data.serviceScheduleData = { ...serviceScheduleRes.data(), id: serviceScheduleRes.id };
									}
								}
								tempServices.push(data);
							}
						});

						await Promise.all(jobs);

						tempServices = tempServices.filter(
							(el) => el.status !== SERVICE_STATUS.DELETED && el.status !== SERVICE_STATUS.CANCELLED
						);

						const today = new Date();
						const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0));
						console.log("todayUTC", todayUTC);

						if (user.uid && generatorData?.transporterId != user.uid) {
							tempServices = tempServices.filter((service) => service.routeData.transporterId === user.uid);
						}
						setNextService(
							tempServices
								.filter((el) => {
									const isMarkedAsClosed = el.markedAsClosedAt && el.markedAsClosedAt.toDate instanceof Function;
									if (
										el.date.toDate().getTime() >= todayUTC.getTime() &&
										el.status !== SERVICE_STATUS.COMPLETE &&
										!isMarkedAsClosed
									) {
										return true;
									} else {
										return false;
									}
								})
								.sort((a, b) => a.date.toDate() - b.date.toDate())
						);
						const lastComplet = tempServices
							.filter((el) => {
								const isCompleted = el.date.toDate() <= todayUTC && el.status === SERVICE_STATUS.COMPLETE;

								const isMarkedAsClosed = el.markedAsClosedAt && el.markedAsClosedAt.toDate instanceof Function;
								return isCompleted || isMarkedAsClosed;
							})
							.sort((a, b) => {
								let aEffectiveDate;
								if (a.markedAsClosedAt && a.markedAsClosedAt.toDate instanceof Function) {
									aEffectiveDate = a.markedAsClosedAt.toDate();
								} else if (a.completedAt?.toDate() && a.completedAt.toDate() > a.date.toDate()) {
									aEffectiveDate = a.completedAt.toDate();
								} else {
									aEffectiveDate = a.date.toDate();
								}
								let bEffectiveDate;
								if (b.markedAsClosedAt && b.markedAsClosedAt.toDate instanceof Function) {
									bEffectiveDate = b.markedAsClosedAt.toDate();
								} else if (b.completedAt?.toDate() && b.completedAt.toDate() > b.date.toDate()) {
									bEffectiveDate = b.completedAt.toDate();
								} else {
									bEffectiveDate = b.date.toDate();
								}
								return bEffectiveDate - aEffectiveDate;
							});
						console.log("lastComplete");
						setLastCompleted(lastComplet);

						const todayServices = tempServices
							.filter((el) => {
								const serviceDate = el.date.toDate();
								return (
									serviceDate.getUTCFullYear() === todayUTC.getUTCFullYear() &&
									serviceDate.getUTCMonth() === todayUTC.getUTCMonth() &&
									serviceDate.getUTCDate() === todayUTC.getUTCDate()
								);
							})
							.sort((a, b) => a.date.toDate() - b.date.toDate());

						console.log("Today services data:", todayServices);
						setTodayService(todayServices);

						if (todayServices.length > 0) {
							await checkTodayService(todayServices);
						} else {
							await checkAllRoutesForTodayServices(generatorData?.id);
						}

						if (serviceCompletionText && todayStartedRoute) {
							console.log(
								"relevant data",
								routeStarted,
								todayStartedRoute,
								generatorWaypointCompleted,
								serviceCompletionText
							);
							await checkStopsRemaing(todayStartedRoute);
						}
					} catch (error) {
						console.log("Error processing services:", error);
					}
				}
			);

			unsubscribers.push(servicesUnsubscribe);
			return () => {
				unsubscribers.forEach((unsubscribe) => unsubscribe());
			};
		} catch (error) {
			console.log("Error setting up snapshot listener:", error);
		}
	}, [generatorData?.id, serviceCompletionText]);

	async function checkTodayService(tservice) {
		const today = new Date();
		const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0));
		const totalService = tservice.length;
		const completedServices = tservice.filter((service) => {
			const isMarkedAsClosed = service.markedAsClosedAt && service.markedAsClosedAt.toDate instanceof Function;
			return service.status === SERVICE_STATUS.COMPLETE || isMarkedAsClosed;
		}).length;
		const completionText = `${completedServices} of ${totalService} services completed`;
		let routeIsStarted = false;
		let selectedServiceObj = null;

		const routeIds = [...new Set(tservice.map((s) => s.routeId))].filter(Boolean);
		console.log("routeIDs", routeIds);

		for (const routeId of routeIds) {
			if (!routeId) continue;

			try {
				const routeRef = doc(db, COLLECTIONS.routes, routeId);
				const dailyRouteRef = doc(routeRef, "dailyRoutes", todayUTC.toISOString());
				const dailyRouteData = await getDoc(dailyRouteRef);

				if (dailyRouteData.exists()) {
					const routeData = dailyRouteData.data();
					console.log("routeData", routeData, todayUTC);

					if (routeData.assignedDriverId && routeData.assignedServiceVehicleId) {
						const routeServices = tservice.filter((s) => s.routeId === routeId);
						const inProgressService = routeServices.find(
							(s) =>
								s.status === SERVICE_STATUS.INPROGRESS &&
								s.status !== SERVICE_STATUS.CANCELLED &&
								s.status !== SERVICE_STATUS.DELETED
						);

						if (inProgressService) {
							selectedServiceObj = { service: inProgressService, routeData };
							routeIsStarted = true;
							break;
						}

						const pendingService = routeServices.find(
							(s) =>
								s.status === SERVICE_STATUS.PENDING &&
								s.status !== SERVICE_STATUS.CANCELLED &&
								s.status !== SERVICE_STATUS.DELETED
						);

						if (pendingService) {
							selectedServiceObj = { service: pendingService, routeData };
							routeIsStarted = true;
							break;
						}
					}
				}
			} catch (error) {
				console.error(`Error checking route ${routeId} during initial status check:`, error);
			}
		}

		if (routeIsStarted && selectedServiceObj) {
			setTodayStartedRoute(selectedServiceObj);
			setRouteStarted(true);
		} else {
			setRouteStarted(false);
		}
		setServiceCompletionText(completionText);
		await checkTodayServicesCompletion(generatorData?.id, tservice);
	}

	async function checkTodayServicesCompletion(generatorId, todayServices) {
		if (!generatorId) return false;

		try {
			const incompleteDirectServices = todayServices.filter((service) => {
				const isMarkedAsClosed = service.markedAsClosedAt && service.markedAsClosedAt.toDate instanceof Function;
				return (
					service.status !== SERVICE_STATUS.COMPLETE &&
					service.status !== SERVICE_STATUS.CANCELLED &&
					service.status !== SERVICE_STATUS.DELETED &&
					!isMarkedAsClosed
				);
			});

			if (incompleteDirectServices.length > 0) {
				console.log("Incomplete services detected:", incompleteDirectServices);
				setGeneratorWaypointCompleted(false);
				return false;
			}

			const today = new Date();
			const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0));
			const routeIds = [...new Set(todayServices.map((s) => s.routeId))].filter(Boolean);

			for (const routeId of routeIds) {
				try {
					const routeRef = doc(db, COLLECTIONS.routes, routeId);
					const dailyRouteRef = doc(routeRef, "dailyRoutes", todayUTC.toISOString());
					const dailyRouteData = await getDoc(dailyRouteRef);

					if (dailyRouteData.exists()) {
						const routeData = dailyRouteData.data();
						const waypoints = routeData.waypoints || [];
						const generatorWaypoints = waypoints.filter((wp) => wp.id === generatorId);

						for (const waypoint of generatorWaypoints) {
							if (!waypoint.serviceId) continue;
							const existingService = todayServices.find((s) => s.id === waypoint.serviceId);

							if (!existingService) {
								const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, waypoint.serviceId));
								if (serviceDoc.exists()) {
									const serviceData = serviceDoc.data();
									const serviceDate = serviceData.date.toDate();
									const isToday =
										serviceDate.getUTCFullYear() === todayUTC.getUTCFullYear() &&
										serviceDate.getUTCMonth() === todayUTC.getUTCMonth() &&
										serviceDate.getUTCDate() === todayUTC.getUTCDate();
									const isMarkedAsClosed =
										serviceData.markedAsClosedAt && serviceData.markedAsClosedAt.toDate instanceof Function;

									if (
										isToday &&
										serviceData.status !== SERVICE_STATUS.COMPLETE &&
										serviceData.status !== SERVICE_STATUS.CANCELLED &&
										serviceData.status !== SERVICE_STATUS.DELETED &&
										!isMarkedAsClosed
									) {
										console.log(
											`Incomplete service found in waypoint: ${waypoint.serviceId}, status: ${serviceData.status}`
										);
										setGeneratorWaypointCompleted(false);
										return false;
									}
								}
							}
						}
					}
				} catch (error) {
					console.error(`Error checking waypoints for route ${routeId}:`, error);
					setGeneratorWaypointCompleted(false);
					return false;
				}
			}

			console.log(`All services for generator ${generatorId} are completed.`);
			setGeneratorWaypointCompleted(true);
			return true;
		} catch (error) {
			console.error("Error in checkTodayServicesCompletion:", error);
			setGeneratorWaypointCompleted(false);
			return false;
		}
	}

	async function checkAllRoutesForTodayServices(generatorId) {
		try {
			const today = new Date();
			const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0));
			const todayISOString = todayUTC.toISOString();
			const routesQuery = query(collection(db, COLLECTIONS.routes));
			const routesSnapshot = await getDocs(routesQuery);
			const routes = routesSnapshot.docs.map((doc) => doc.id);

			let hasAnyServices = false;

			for (const routeId of routes) {
				try {
					const routeRef = doc(db, COLLECTIONS.routes, routeId);
					const dailyRouteRef = doc(routeRef, "dailyRoutes", todayISOString);
					const dailyRouteSnapshot = await getDoc(dailyRouteRef);

					if (dailyRouteSnapshot.exists()) {
						const dailyRouteData = dailyRouteSnapshot.data();
						const waypoints = dailyRouteData.waypoints || [];
						const generatorWaypoints = waypoints.filter((wp) => wp.id === generatorId);

						if (generatorWaypoints.length > 0) {
							hasAnyServices = true;
							for (const waypoint of generatorWaypoints) {
								if (!waypoint.serviceId) continue;

								const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, waypoint.serviceId));

								if (serviceDoc.exists()) {
									const serviceData = serviceDoc.data();
									const isMarkedAsClosed =
										serviceData.markedAsClosedAt && serviceData.markedAsClosedAt.toDate instanceof Function;
									if (
										serviceData.status !== SERVICE_STATUS.COMPLETE &&
										serviceData.status !== SERVICE_STATUS.CANCELLED &&
										serviceData.status !== SERVICE_STATUS.DELETED &&
										!isMarkedAsClosed
									) {
										console.log(
											`Found incomplete service ${waypoint.serviceId} in route ${routeId}, status: ${serviceData.status}`
										);
										setGeneratorWaypointCompleted(false);
										return false;
									}
								} else {
									console.log(`Service ${waypoint.serviceId} does not exist in route ${routeId}`);
									setGeneratorWaypointCompleted(false);
									return false;
								}
							}
						}
					}
				} catch (error) {
					console.error(`Error checking route ${routeId}:`, error);
					setGeneratorWaypointCompleted(false);
					return false;
				}
			}

			if (hasAnyServices) {
				console.log(`All services for generator ${generatorId} across all routes are completed`);
				setGeneratorWaypointCompleted(true);
				return true;
			}

			console.log(`No services found for generator ${generatorId} across all routes`);
			setGeneratorWaypointCompleted(false);
			return false;
		} catch (error) {
			console.error("Error checking all routes:", error);
			setGeneratorWaypointCompleted(false);
			return false;
		}
	}

	async function checkStopsRemaing(data) {
		console.log("waypoint", data.routeData.waypoints);
		const waypointData = data.routeData.waypoints;
		let generatorWaypointIndex = -1;
		let inProgressIndex = -1;
		let firstOccurrenceIndex = -1;
		const generatorWaypoints = waypointData.filter((wp) => wp.id === generatorData.id);

		if (waypointData) {
			const totalStops = waypointData.length;
			for (let index = 0; index < totalStops; index++) {
				const waypoint = waypointData[index];
				if (waypoint.id === generatorData.id) {
					if (firstOccurrenceIndex === -1) {
						firstOccurrenceIndex = index;
					}

					try {
						const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, waypoint.serviceId));

						if (!serviceDoc.exists()) continue;

						const serviceData = serviceDoc.data();
						console.log(`Service ${waypoint.serviceId} status: ${serviceData.status}`);

						if (serviceData.status === SERVICE_STATUS.INPROGRESS) {
							inProgressIndex = index;
							console.log(`Found INPROGRESS service at index ${index}`);
						} else if (serviceData.status === SERVICE_STATUS.PENDING && generatorWaypointIndex === -1) {
							generatorWaypointIndex = index;
							console.log(`Found PENDING service at index ${index}`);
						} else if (serviceData.status === SERVICE_STATUS.COMPLETE) {
							console.log(`Found COMPLETE service at index ${index}`);
						}
					} catch (error) {
						console.error(`Error getting service data for waypoint at index ${index}:`, error);
					}
				}
			}

			if (inProgressIndex !== -1) {
				generatorWaypointIndex = inProgressIndex;
			} else if (generatorWaypointIndex === -1) {
				generatorWaypointIndex = firstOccurrenceIndex;
			}

			const serviceIds = waypointData
				.slice(0, generatorWaypointIndex + 1)
				.map((waypoint) => waypoint.serviceId)
				.filter((id) => id);

			let pendingCount = 0;
			let currentGenStatus = null;

			for (const serviceId of serviceIds) {
				try {
					const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, serviceId));

					if (!serviceDoc.exists()) continue;

					const serviceData = serviceDoc.data();

					if (serviceData?.status === SERVICE_STATUS.COMPLETE) {
						pendingCount++;
					}

					if (serviceId === waypointData[generatorWaypointIndex].serviceId) {
						currentGenStatus = serviceDoc;
						console.log(`Found current generator's service: ${serviceId}, status: ${serviceData.status}`);
					}
				} catch (error) {
					console.error(`Error checking service status for ${serviceId}:`, error);
				}
			}

			if (!currentGenStatus) {
				try {
					const serviceId = waypointData[generatorWaypointIndex].serviceId;
					console.log(`Fetching current generator's service directly: ${serviceId}`);

					currentGenStatus = await getDoc(doc(db, COLLECTIONS.scheduledServices, serviceId));
				} catch (error) {
					console.error(`Error getting current generator status directly:`, error);
				}
			}

			let progress =
				firstOccurrenceIndex > 0
					? ((generatorWaypointIndex + 1 - pendingCount) / (generatorWaypointIndex + 1)) * 100
					: 0;

			let progressbarValue = progress;

			if (currentGenStatus && currentGenStatus.exists()) {
				const status = currentGenStatus.data().status;

				console.log(`Current generator service status: ${status}`);

				if (status === SERVICE_STATUS.COMPLETE) {
					progressbarValue = 100;
					console.log(`Service is COMPLETE, setting progress to 100%`);
				} else if (status === SERVICE_STATUS.INPROGRESS || pendingCount === 0) {
					progressbarValue = 90;
					console.log(`Service is INPROGRESS or no pending services, setting progress to 90%`);
				} else {
					progressbarValue = progress === 100 ? 90 : progress;
					console.log(`Setting progress to ${progressbarValue}%`);
				}
			}

			let waypointsRemainingText = "Stops Remaining";

			if (currentGenStatus && currentGenStatus.exists()) {
				const status = currentGenStatus.data().status;

				if (status !== SERVICE_STATUS.PENDING) {
					waypointsRemainingText = "Arriving Next";
					console.log("Service in progress, setting text to 'Arriving Next'");
				}
			}

			setProgressbar(progressbarValue);
			setStopsRemaining(pendingCount);
			setWaypointsRemaining(waypointsRemainingText);
		}

		await checkTodayServicesCompletion(generatorData?.id, todayService);
	}

	const [selectedValue, setSelectedValue] = useState("");
	const [size, setSize] = useState(1);

	useEffect(() => {
		if (childrenData && childrenData.length > 0 && !generatorData.parentAccount) {
			setSelectedValue("");
		} else {
			setSelectedValue(generatorData?.id || "");
		}
	}, [generatorData, childrenData]);

	const handleSelectChange = async (event) => {
		const selectedId = event.target.value;
		if (selectedId) {
			const gendata = await getGeneratorById(selectedId);
			//console.log("checks",selectedId,generatorData,childrenData,childrenData.filter((child)=>child.id==selectedId));
			setGeneratorData(gendata);
		}
	};
	const handleChildChange = (event) => {
		const id = event.target.value;
		if (id) {
			navigate(`/admin/generators/${id}/generator-dashboard`);
			setSize(1);
		}
	};
	function formatUtcDateString(utcDateString) {
		const date = new Date(utcDateString);
		const formatter = new Intl.DateTimeFormat("en-US", {
			weekday: "short",
			month: "2-digit",
			day: "2-digit",
			year: "numeric",
			timeZone: "UTC",
		});

		return formatter.format(date);
	}

	const renderWorkHours = () => {
		if (!generatorData?.workingHours) return "N/A";

		if (nextService?.length > 0 && nextService[0]?.date) {
			const serviceDate = nextService[0].date?.toDate?.();
			if (!serviceDate) return "N/A"; // Ensure serviceDate is valid
			const serviceDateUTC = formatUtcDateString(serviceDate.toISOString());
			const dayOfWeek = daysOfWeek[new Date(serviceDateUTC).getDay()];
			const todaysWorkHours = generatorData.workingHours?.[dayOfWeek];

			if (!todaysWorkHours) return "N/A";

			console.log("todayWH", todaysWorkHours, dayOfWeek);

			return todaysWorkHours.closed ? "Closed" : `${todaysWorkHours.open ?? "N/A"} - ${todaysWorkHours.close ?? "N/A"}`;
		}

		return "N/A";
	};

	const isParentWithChildren = isParent && childrenData && childrenData.length > 0;
	const createdAtFormatted = generatorData.createdAt ? formattedDate(generatorData.createdAt) : "--";
	const fetchTransporter = async (transporterId) => {
		let snapRef = doc(db, COLLECTIONS.transporters, transporterId);
		let snapDoc = await getDoc(snapRef);
		let snapData = { id: snapDoc.id, ...snapDoc.data() };
		console.log({ snapData });
		setTransporterName(snapData?.companyDisplayName ?? snapData?.transporterName);
	};
	useEffect(() => {
		if (user?.uid == generatorData?.transporterId && generatorData?.isSubContracted) {
			fetchTransporter(generatorData?.subContractors?.[0]?.id);
		}
	}, [user, generatorData]);

	// Memoized calculation for terminated/accepted status from SSR data
	const isTerminatedAccepted = useMemo(() => {
		if (!ssrDataLoaded || !activeSentSSRs || activeSentSSRs.length === 0) {
			return false;
		}
		return activeSentSSRs.some(ssr => 
			ssr.status === "TERMINATEACCEPTED" || ssr.status === "TERMINATED"
		);
	}, [ssrDataLoaded, activeSentSSRs]);

	// Memoized tag configuration to prevent unnecessary re-renders
	const tagConfig = useMemo(() => {
		if (!generatorData?.isSubContracted || !ssrDataLoaded) {
			return null;
		}

		const isIncoming = generatorData?.transporterId !== user?.uid;
		const bgColor = isTerminatedAccepted ? "bg-gray-500" : (isIncoming ? "bg-primary" : "bg-primaryGreen");
		const size = isIncoming ? "h-7 w-7" : "h-9 w-9";
		const text = isIncoming ? "IN" : "OUT";

		return {
			bgColor,
			size, 
			text,
			className: `text-white text-sm p-2 flex items-center justify-center rounded-full transition-colors duration-300 ${bgColor} ${size}`
		};
	}, [generatorData?.isSubContracted, generatorData?.transporterId, user?.uid, isTerminatedAccepted, ssrDataLoaded]);

	return (
		<div className="bg-bgDefaultColor px-32 py-5 flex flex-col gap-5">
			<div className="grid grid-cols-3 gap-5 items-center  ">
				<ParentDropdown
					isParent={isParent}
					generatorData={generatorData}
					parentGenerator={parentGenerator}
					handleChildChange={handleChildChange}
				/>

				<ChildDropdown
					selectedValue={selectedValue}
					setSelectedValue={setSelectedValue}
					isParentWithChildren={isParentWithChildren}
					isparent={isParent}
					generatorData={generatorData}
					parentGenerator={parentGenerator}
					childrenData={childrenData}
					sameParentGenerators={sameParentGenerators}
					getGeneratorById={getGeneratorById}
					setGeneratorData={setGeneratorData}
					setGeneratorWaypointCompleted={setGeneratorWaypointCompleted}
				/>

				{/* <button className="bg-lightBlue hover:bg-cardTextBlue text-white rounded-full py-3 px-4 shadow-lg transition-all duration-300 flex justify-between items-center space-x-2">
					<span>Add Service Location</span>
					<span>
						<Plus />
					</span>
				</button> */}

				<div className="flex flex-col justify-between items-end h-full gap-5">
					<div className="flex items-center gap-2">
						<h6 className="font-semibold text-end text-2xl text-nowrap">
							{generatorData?.subContractors?.length > 0 ? (
								<>
									<span>
										{generatorData.subContractors[0].id === user?.uid
											? generatorData.subContractors[0].name
											: generatorData.subContractors[0].subContractorName}
									</span>
									{generatorData.subContractors.length > 1 && (
										<span className="ml-1 text-gray-500">+{generatorData.subContractors.length - 1} more</span>
									)}
								</>
							) : (
								""
							)}
						</h6>
						{/* Only show tag when SSR data is loaded and generator is subcontracted */}
						{tagConfig && (
							<div className={tagConfig.className}>
								<p>{tagConfig.text}</p>
							</div>
						)}
					</div>
					<h6 className="font-medium text-lg ">
						Created Date: <span className="text-cardTextGray ">{createdAtFormatted}</span>
					</h6>
				</div>
			</div>

			<div className="bg-white w-full rounded-xl flex flex-col items-start justify-evenly p-5 shadow-sm">
				<p className="font-semibold">{generatorData?.generatorName}</p>
				<p className="font-semibold">{octoFormatter(generatorData?.octoNumber)}</p>
				<p className="font-semibold">{renderAddress(generatorData?.serviceAddress)}</p>
			</div>

			<div className="flex justify-between gap-5">
				<div className="bg-white p-10 flex items-center gap-5 flex-col w-full text-center rounded-xl shadow-md">
					<h1 className="font-bold text-3xl">Service</h1>

					<div className="">
						<h2 className="font-semibold text-lg">Next Service</h2>
						{console.log("user", user)}
						<h1 className="text-[#4CD964] text-xl">
							{nextService?.length > 0 && nextService[0]?.date
								? formatUtcDateString(nextService[0].date.toDate())
								: "N/A"}
						</h1>
					</div>

					<div className="grid gap-2 w-full max-w-80">
						<button
							className="w-full  bg-thatblue hover:bg-blue-500 rounded-full text-white p-3"
							onClick={() => {
								generatorData?.generatorStatus == "CANCELED"
									? navigate(`/admin/reports/service?id=${generatorData?.octoNumber}`, { replace: true })
									: navigate(`/admin/generators/${generatorData?.id}/routes?section=history`);
							}}
						>
							Manage Service History
						</button>
						<button
							className="w-full  bg-white hover:bg-[#DEDEDE] rounded-full text-[#666666] border border-[#DEDEDE] p-3"
							onClick={() => {
								navigate(`/admin/generators/${generatorData?.id}/routes`);
							}}
						>
							Manage Future Services
						</button>
					</div>

					<div className="w-full bg-thatblue text-white  rounded-xl p-5 grid  gap-2">
						<h1 className="font-semibold text-center">Service Summary</h1>
						<hr className="" />

						<div className="grid gap-1">
							<div className="grid grid-cols-2">
								<span className="text-left">Service Address:</span>
								<span className="text-left">{renderAddress(generatorData?.serviceAddress)}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Next Service:</span>

								<span className="text-left">
									{nextService?.length > 0 && nextService[0]?.date
										? formatUtcDateString(nextService[0].date.toDate())
										: "N/A"}
								</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Office Hours:</span>
								<span className="text-left">{renderWorkHours() ? renderWorkHours() : "N/A"}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Service Type:</span>
								<span className="text-left">{value ? value : "N/A"}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Last Completed Service:</span>
								<span className="text-left">
									{lastCompleted?.[0]?.completedAt || lastCompleted?.[0]?.markedAsClosedAt
										? formatDateString(
												lastCompleted[0].completedAt?.toDate().toISOString() ||
													lastCompleted[0]?.markedAsClosedAt?.toDate().toISOString(),
												generatorData?.workingHours?.timeZone
										  )
										: "--"}
								</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Service Frequency:</span>
								<span className="text-left">
									{console.log("serviceFrequency", serviceFrequency)}
									{serviceFrequency?.length > 0
										? serviceFrequency
												.map((service) => allServiceFrequencies.find((el) => el.value === service)?.label ?? "N/A")
												.join(", ")
										: "N/A"}
								</span>
							</div>
						</div>
					</div>
				</div>

				<div className="bg-white p-10 flex items-center gap-5 flex-col w-full text-center rounded-xl shadow-md">
					<h1 className="font-bold text-3xl">Billing</h1>

					<div className="">
						<h2 className="font-semibold text-lg">Open balance</h2>
						<h1 className="text-[#4CD964] text-xl">${dummyBillingData.openBalance}</h1>
					</div>

					<div className="grid gap-2 w-full max-w-80">
						<button
							className="w-full p-3 bg-thatblue hover:bg-blue-500 rounded-full text-white"
							onClick={() => {
								//navigate("/generator-dashboard/invoices-and-payments");
								navigate(`/admin/generators/${generatorData?.id}/invoices-and-payments`);
							}}
						>
							Manage Invoices
						</button>
						<button
							className="w-full p-3 bg-white hover:bg-[#DEDEDE] rounded-full text-[#666666] border border-[#DEDEDE]"
							onClick={() => {
								//navigate("/generator-dashboard/saved-payment-methods");
								navigate(`/admin/generators/${generatorData?.id}/saved-payment-methods`);
							}}
						>
							Manage Payment Options
						</button>
					</div>

					<div className="w-full bg-thatblue text-white  rounded-xl p-5 grid  gap-2">
						<h1 className="font-semibold text-center">Billing Summary</h1>

						<hr />

						<div className="grid gap-1">
							<div className="grid grid-cols-2">
								<span className="text-left">Billing Address:</span>
								<span className="text-left">{renderAddress(generatorData?.billingAddress)}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Last Payment:</span>
								<span className="text-left">{dummyBillingData?.lastPayment}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Overdue Balance:</span>
								<span className="text-left">{dummyBillingData.overdueBalance}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Unpaid Invoices:</span>
								<span className="text-left">{dummyBillingData.unpaidInvoices}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Billing Frequency:</span>
								<span className="text-left">{dummyBillingData.billingFrequency}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Payment Type</span>
								<span className="text-left">{dummyBillingData.paymentType}</span>
							</div>
						</div>
					</div>
				</div>
			</div>

			<div className="bg-white rounded-xl shadow-md p-5 w-full">
				<div className="grid grid-cols-1 md:grid-cols-3 gap-5">
					{/* Generator Notes */}
					<div
						className="border border-gray-200 rounded-lg p-4 bg-gray-50 hover:cursor-pointer"
						onClick={() => {
							navigate(`/admin/generators/${generatorData?.id}/generator-profile`);
						}}
					>
						<h3 className="text-md font-semibold text-gray-700 mb-2">Generator Notes:</h3>
						<p className="text-gray-600 whitespace-pre-wrap">
							{generatorData?.generatorNote || "No generator notes available."}
						</p>
					</div>

					{/* Billing Notes */}
					<div
						className="border border-gray-200 rounded-lg p-4 bg-gray-50 hover:cursor-pointer"
						onClick={() => {
							navigate(`/admin/generators/${generatorData?.id}/generator-billing`);
						}}
					>
						<h3 className="text-md font-semibold text-gray-700 mb-2">Billing Notes:</h3>

						<p className="text-gray-600 whitespace-pre-wrap">
							{generatorData?.internalBillingNote || "No billing notes available."}
						</p>
					</div>

					{/* Service Notes */}
					<div
						className="border border-gray-200 rounded-lg p-4 bg-gray-50 hover:cursor-pointer"
						onClick={() => {
							navigate(`/admin/generators/${generatorData?.id}/routes`);
						}}
					>
						<h3 className="text-md font-semibold text-gray-700 mb-2">Service Notes:</h3>
						<p className="text-gray-600 whitespace-pre-wrap">
							{generatorData?.serviceInstructions || "No service notes available."}
						</p>
					</div>
				</div>
			</div>

			<div className="w-full grid grid-cols-2 gap-5 ">
				<div className="bg-white rounded-cardRadii shadow-md p-5 grid grid-cols-1 gap-2">
					<h2 className="text-lg font-bold text-left">Upcoming Service Schedules</h2>
					<div className="grid grid-cols-3 gap-2">
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 border-red-500 bg-white border-[3px] rounded-none mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Today's Date</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 bg-red-500 rounded-full mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Medical Waste</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 bg-green-500 rounded-full mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Paper Shredding Schedule</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="flex w-6 h-6 col-span-2">
								<div className="w-3 h-6 bg-green-500 rounded-r-full rotate-180"></div>
								<div className="w-3 h-6 bg-red-500 rounded-l-full rotate-180"></div>
							</div>
							<span className="text-gray-700 col-span-6">Medical Waste & Paper Shredding</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 bg-yellow-500 rounded-full mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Holiday (No services on this day)</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 bg-gray-500 rounded-full mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Completed (Past) Service dates</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 col-span-2 rounded-full bg-white border border-gray-500 mr-2" />
							<span className="text-gray-700 col-span-6">Unlogged (Past) Service dates</span>
						</div>
					</div>
				</div>
				<div className="bg-white rounded-xl shadow-md flex flex-col gap-5 relative p-5 justify-center h-full">
					{console.log(
						"all datats",
						serviceCompletionText,
						completed,
						generatorWaypointCompleted,
						waypointsRemaining,
						routeStarted,
						progressBar,
						stopsRemaining,
						lastCompleted
					)}
					{console.log(
						"date data",
						todayService?.[0]?.date ? formatUtcDateString(todayService[0].date.toDate()) : null,
						nextService?.[0]?.date ? formatUtcDateString(nextService[0].date.toDate()) : "not defined"
					)}

					<div className="absolute top-0 right-0 text-sm">
						<p className="p-5">{serviceCompletionText}</p>
					</div>
					<div>
						<h2 className="text-lg font-bold text-left">Live Track</h2>
					</div>
					<div className="text-lg font-bold h-1/2 mt-auto flex items-end">
						{nextService?.[0]?.date &&
						todayService?.[0]?.date &&
						formatUtcDateString(todayService[0]?.date.toDate()) === formatUtcDateString(nextService[0]?.date.toDate())
							? "Tracking "
							: "Check Back On: "}
						(
						{nextService?.[0]?.date && nextService[0].date.toDate() instanceof Date
							? formatUtcDateString(nextService[0].date.toDate())
							: "N/A"}
						)
					</div>

					<div className="h-1/2">
						<div className="relative w-full bg-gray-200 rounded-full h-3 ">
							<div
								className={`${!generatorWaypointCompleted ? "bg-blue-500" : "bg-green-500"} h-3 rounded-full`}
								style={{
									width: generatorWaypointCompleted
										? "100%"
										: waypointsRemaining && routeStarted === "Arriving Next"
										? "90%"
										: routeStarted
										? `${progressBar}%`
										: "0%",
								}}
							/>
							<div className="flex justify-between items-center absolute w-full top-4 -translate-y-1/2">
								{/* Route Started Icon */}
								<div className="flex flex-col ">
									<CheckCircleIcon
										className={`w-7 h-7 ${
											routeStarted
												? "bg-blue-500 text-white"
												: generatorWaypointCompleted
												? "bg-green-500 text-white"
												: "text-gray-300 bg-gray-200"
										} rounded-full `}
									/>
									<span
										className={`${routeStarted || generatorWaypointCompleted ? "text-blue-500" : "text-gray-700"}  `}
									>
										Route Started
									</span>
								</div>
								{/* Waypoints Remaining Circle */}
								<div className="flex flex-col items-center">
									<div
										className={`w-7 h-7 ${
											routeStarted ? "bg-blue-500" : generatorWaypointCompleted ? "bg-green-500 " : "bg-gray-200"
										} rounded-full flex items-center justify-center text-white`}
									>
										{routeStarted && waypointsRemaining !== "Arriving Next" && !generatorWaypointCompleted && (
											<p>{stopsRemaining}</p>
										)}
									</div>
									<span className={`${routeStarted || generatorWaypointCompleted ? "text-blue-500" : "text-gray-700"}`}>
										{routeStarted ? waypointsRemaining : "Stops Remaining"}
									</span>
								</div>
								{/* Service Completed Icon */}
								<div className="flex flex-col items-end ">
									<div
										className={`w-7 h-7 ${generatorWaypointCompleted ? "bg-green-500" : "bg-gray-200"} rounded-full`}
									></div>
									<span className={`${generatorWaypointCompleted ? "text-blue-500" : "text-gray-700"}`}>
										Service Completed
									</span>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>

			<div className="w-full grid grid-cols-2 gap-5">
				<div className="bg-white p-3 rounded-cardRadii shadow-md flex-1 flex flex-col">
					<h2 className="font-bold text-lg ml-1 pb-2">Service Calendar</h2>
					<CalendarWithTimeSlots
						allServices={allServices}
						wholeCalender={true}
						startDate={new Date()}
						timezone={generatorData?.workingHours?.timeZone}
					/>
					<p
						className="text-thatblue text-md py-2 text-end hover:cursor-pointer"
						onClick={() => {
							navigate(`/admin/generators/${genId}/service-calendar?child=${generatorData.id}`, {
								state: { generatorData },
							});
						}}
					>
						View Service Calendar
					</p>
				</div>
				<div className="shadow-sm w-full  bg-white rounded-xl">
					<AzureMapsProvider>
						{generatorData?.serviceAddCoordinates?.lat &&
						generatorData?.serviceAddCoordinates?.lng &&
						randomCoordinates?.lat &&
						randomCoordinates?.lng ? (
							<CustomAzureGeneratorDashboardMap
								generatorData={generatorData}
								randomCoordinates={randomCoordinates}
								showPointer={generatorData?.transporterId == user?.uid}
							/>
						) : (
							<p>Generator Data not flow</p>
						)}
					</AzureMapsProvider>
				</div>
			</div>

			{/*<GeneratorDetailsForm
				billingAddress={generatorData?.billingAddress}
				serviceAddress={generatorData?.serviceAddress}
				name={generatorData?.generatorName}
				changeRequestHandler={() => {
					contactFormRef.current.scrollIntoView({ behavior: "smooth" });
				}}
			/>*/}
			<GeneratorOfficeHours
				workingHours={generatorData?.workingHours}
				genTimeZone={generatorData?.workingHours?.timeZone}
			/>
		</div>
	);
};

export default GeneratorDashboardAdmin;

const dummyBillingData = {
	openBalance: "N/A",
	billingAddress: "N/A",
	lastPayment: "N/A",
	overdueBalance: "N/A",
	unpaidInvoices: "N/A",
	billingFrequency: "N/A",
	paymentType: "N/A",
};
