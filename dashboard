import { useEffect, useRef, useState } from "react";
import { CheckCircleIcon, ClockIcon, ArrowRightIcon } from "lucide-react";
import {
	onSnapshot,
	query,
	collection,
	where,
	orderBy,
	doc,
	getDoc,
	Timestamp,
	limit,
	getDocs,
} from "firebase/firestore";
import { db, COLLECTIONS } from "../../../config/firebase";
import GeneratorDetailsForm from "./components/GeneratorDetailsForm/GeneratorDetailsForm";
import GeneratorOfficeHours from "../../admin/generator-management/components/generators/components/detail-forms/components/GeneratorOfficeHours/GeneratorOfficeHours";
import ContactUsForm from "./components/ContactUsForm/ContactUsForm";
import { useGeneratorUser } from "../../../context/GeneratorUserContext";
import { useNavigate } from "react-router-dom";
import Loader from "../../../components/UI/loaders/Loader";
import {
	dateFormatter,
	daysOfWeek,
	formatDateString,
	randomizeCoordinates,
	renderAddress,
} from "../../../utils/helpers";
import {
	frequencyPrimaryOptions,
	frequencySecondaryOptions,
	SERVICE_STATUS,
	serviceTypes,
} from "../../../utils/constants";
import CustomAzureGeneratorDashboardMap from "./CustomAzureGeneratorDashboardMap";
import { AzureMapsProvider } from "react-azure-maps";
import CalendarWithTimeSlots from "../../admin/generator-management/components/generators/components/detail-forms/components/open-calendar/GeneratorCalendarComponent";
import { getGeneratorById } from "../../../utils/firebaseOperations";
import { useGeneratorData } from "./components/GeneratorDataContext";
import ChildDropdown from "./components/dropDowns/childDropdown";
import ParentDropdown from "./components/dropDowns/parentDropdown";
import GeneratorUserAccBtn from "../GenUserAccountButton/GeneratorUserAccountButton";

const GeneratorDashboard = () => {
	const { user, authLoading, generatorData: data, allServices: genService } = useGeneratorUser();
	const [parentAccount, setParentAccount] = useState(null);
	const navigate = useNavigate();
	const [nextService, setNextService] = useState(null);
	const [lastCompleted, setLastCompleted] = useState(null);
	const contactFormRef = useRef();
	const [randomCoordinates, setRandomCoordinates] = useState({ lat: 0, lng: 0 });
	const [waypointsRemaining, setWaypointsRemaining] = useState("Stops Remaining");
	const [completed, setCompleted] = useState(false);
	const [generatorWaypointCompleted, setGeneratorWaypointCompleted] = useState(false);
	const [sameParentGenerators, setSameParentGenerators] = useState(null);
	const [routeStarted, setRouteStarted] = useState(null);
	const [progressBar, setProgressbar] = useState("0%");
	const [stopsRemaining, setStopsRemaining] = useState(0);
	const [value, setValue] = useState("");
	const [serviceFrequency, setServiceFrequency] = useState("");
	const [parentGenerator, setParentGenerator] = useState(null);
	const [childrenData, setChildrenData] = useState(null);
	const [selectedValue, setSelectedValue] = useState(null);
	const { generatorData, setGeneratorData } = useGeneratorData();
	const [todayService, setTodayService] = useState(null);
	const [allServices, setAllServices] = useState([]);
	const [allServiceFrequencies, setAllServiceFrequencies] = useState([
		...frequencyPrimaryOptions,
		...frequencySecondaryOptions,
	]);
	const [serviceCompletionText, setServiceCompletionText] = useState("");
	const [todayStartedRoute, setTodayStartedRoute] = useState();
	const [isLoadingTracking, setIsLoadingTracking] = useState(false);
	const [transporterData, setTransporterData] = useState({});
	const [driverId, setDriverId] = useState("");
	const [allGenerators, setAllGenerators] = useState([]);
	const [rootGeneratorIds, setRootGeneratorIds] = useState([]);
	const [rootGeneratorId, setRootGeneratorId] = useState(null);

	useEffect(() => {
		if (
			data?.id &&
			(!generatorData || (generatorData?.id === data?.id && JSON.stringify(data) !== JSON.stringify(generatorData)))
		) {
			console.log("Syncing generatorData between contexts");
			setGeneratorData(data);
			setIsLoadingTracking(false);
		}
	}, [data?.id]);
	useEffect(() => {
		if (user?.generatorIds && data?.id && rootGeneratorIds.length === 0) {
			setRootGeneratorIds(Array.from(new Set([data.id, ...user.generatorIds])));
			setRootGeneratorId(data.id);
			console.log("Root generator IDs set:", rootGeneratorIds,user.generatorIds);
		}
	}, [data, rootGeneratorIds.length]);

	useEffect(() => {
		if (!generatorData?.id) return;

		try {
			if (typeof generatorData.id !== "string" || generatorData.id.trim() === "") {
				console.warn("Invalid generator ID for query:", generatorData.id);
				return;
			}
			const q = query(collection(db, COLLECTIONS.serviceSchedules), where("generatorId", "==", generatorData.id));
			const unsubscribe = onSnapshot(q, async (snap) => {
				console.log("Snapshot received:", snap);
				const tempSchedules = await Promise.all(
					snap.docs.map(async (el) => {
						if (!el.exists()) return null;

						const data = { ...el.data(), id: el.id };
						if (Array.isArray(data.serviceType)) {
							data.serviceType = data.serviceType[0];
						}
						if (data.isDeleted) return null;
						let createdAt = null;
						if (data.createdAt?.seconds || data.createdAt?.nanoseconds) {
							createdAt = new Timestamp(data.createdAt.seconds, data.createdAt.nanoseconds).toDate();
						} else if (data.createdAt?.toDate) {
							createdAt = data.createdAt.toDate();
						} else {
							createdAt = new Date();
						}

						return { ...data, createdAt };
					})
				);
				const filteredSchedules = tempSchedules.filter(Boolean);
				filteredSchedules.sort((a, b) => a.createdAt - b.createdAt);

				const formattedServiceTypes = [...new Set(filteredSchedules.map((item) => item.serviceType))]
					.map((service) => {
						const matchedService = serviceTypes.find((type) => type.value === service);
						return matchedService ? matchedService.label : service;
					})
					.join(", ");

				console.log(formattedServiceTypes);
				const uniqueServiceTypes = [
					...new Set(
						filteredSchedules.map((item) => {
							const type = item.serviceFrequency?.type;
							return type;
						})
					),
				];
				uniqueServiceTypes.filter(Boolean);
				setValue(formattedServiceTypes);
				setServiceFrequency(uniqueServiceTypes);
				console.log("Final schedules:", filteredSchedules);
			});
			return () => {
				console.log("Unsubscribing from snapshot listener");
				unsubscribe();
			};
		} catch (error) {
			console.error("Error processing snapshot:", error);
		}
	}, [generatorData?.id]);

	useEffect(() => {
		if (!generatorData?.id) return;

		try {
			const parentAccountId = generatorData?.id;
			if (typeof parentAccountId !== "string" || parentAccountId.trim() === "") {
				console.warn("Invalid parent account ID for query", parentAccountId);
				return;
			}

			const unsubscribe = onSnapshot(
				query(collection(db, COLLECTIONS.generators), where("parentAccount", "==", parentAccountId)),
				async (snap) => {
					try {
						const fetchedData = snap.docs.map((doc) => ({ ...doc.data(), id: doc.id }));
						setChildrenData(fetchedData);
					} catch (error) {
						console.error("Error processing snapshot:", error);
					}
				}
			);

			const parentAccountValue = generatorData.parentAccount;
			let unsubscribe2, unsubscribe3;

			if (parentAccountValue && typeof parentAccountValue === "string" && parentAccountValue.trim() !== "") {
				unsubscribe2 = onSnapshot(
					query(collection(db, COLLECTIONS.generators), where("parentAccount", "==", parentAccountValue)),
					async (snap) => {
						try {
							const data = snap.docs.map((doc) => ({ ...doc.data(), id: doc.id }));
							setSameParentGenerators(data);
						} catch (error) {
							console.error("Error processing snapshot:", error);
						}
					}
				);

				unsubscribe3 = onSnapshot(
					query(collection(db, COLLECTIONS.generators), where("id", "==", parentAccountValue)),
					async (snap) => {
						try {
							const data = snap.docs.map((doc) => ({ ...doc.data(), id: doc.id }));
							setParentGenerator(data);
						} catch (error) {
							console.error("Error processing snapshot:", error);
						}
					}
				);
			}

			return () => {
				if (unsubscribe) unsubscribe();
				if (unsubscribe2) unsubscribe2();
				if (unsubscribe3) unsubscribe3();
			};
		} catch (error) {
			console.error("Error setting up generators query:", error);
		}
	}, [generatorData?.id, generatorData?.parentAccount, data?.id]);

	useEffect(() => {
		if (!authLoading && !user) {
			navigate("/generator-portal-auth");
		}
	}, [authLoading, user, navigate, generatorData]);

	useEffect(() => {
		console.log({ generatorData });
		if (!generatorData) return;
		if (
			generatorData?.serviceAddCoordinates &&
			generatorData.serviceAddCoordinates?.lat &&
			generatorData.serviceAddCoordinates?.lng
		) {
			setRandomCoordinates(
				randomizeCoordinates(generatorData.serviceAddCoordinates?.lat, generatorData.serviceAddCoordinates?.lng)
			);
		}

		return () => {};
	}, [generatorData]);

	useEffect(() => {
		if (!allServices?.length) return;
		const today = new Date();
		today.setHours(0, 0, 0, 0);

		const filteredDate = allServices?.filter((el) => {
			const serviceDate = el.date.toDate();
			return serviceDate.getTime() >= today.getTime();
		});

		const filteredCompleted = allServices?.filter((el) => el.status === SERVICE_STATUS.COMPLETE);
		if (filteredCompleted) {
			console.log("completed service", filteredCompleted, "yguyg", filteredCompleted[filteredCompleted.length - 1]);

			//setLastCompleted(filteredCompleted[filteredCompleted.length - 1]);
		} else {
			//setLastCompleted(null);
		}
		setCompleted(false);
		if (filteredDate.length) {
			//	setNextService(filteredDate[0]);
		}
	}, [allServices]);

	const startDate = new Date();
	startDate.setDate(startDate.getDate() - 30);
	const endDate = new Date();
	endDate.setDate(endDate.getDate() + 30);
	useEffect(() => {
		setServiceCompletionText("");
		setCompleted(false);
		setGeneratorWaypointCompleted(false);
		setWaypointsRemaining("Stops Remaining");
		setRouteStarted(false);
		setProgressbar("0%");
		setStopsRemaining(0);
	}, [generatorData?.id]);

	useEffect(() => {
		if (!generatorData?.id) return;

		const unsubscribers = [];
		const date = new Date();
		const todayUTC = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0));

		try {
			const servicesUnsubscribe = onSnapshot(
				query(
					collection(db, COLLECTIONS.scheduledServices),
					where("generatorId", "==", generatorData?.id),
					where("status", "not-in", [SERVICE_STATUS.CANCELLED, SERVICE_STATUS.DELETED]),
					where("date", ">=", Timestamp.fromDate(startDate)),
					where("date", "<=", Timestamp.fromDate(endDate)),
					orderBy("date", "asc")
				),
				async (snap) => {
					try {
						let tempServices = [];
						const jobs = snap.docs.map(async (el) => {
							if (el.exists()) {
								const data = { ...el.data(), id: el.id };
								if (data?.routeId?.length > 0) {
									const routeRes = await getDoc(doc(db, COLLECTIONS.routes, data.routeId));
									if (routeRes.exists()) {
										data.routeData = { ...routeRes.data(), id: routeRes.id };
									}
								}
								if (data?.serviceScheduleId?.length > 0) {
									const serviceScheduleRes = await getDoc(
										doc(db, COLLECTIONS.serviceSchedules, data.serviceScheduleId)
									);
									if (serviceScheduleRes.exists()) {
										data.serviceScheduleData = { ...serviceScheduleRes.data(), id: serviceScheduleRes.id };
									}
								}
								tempServices.push(data);
							}
						});

						await Promise.all(jobs);

						tempServices = tempServices.filter(
							(el) => el.status !== SERVICE_STATUS.DELETED && el.status !== SERVICE_STATUS.CANCELLED
						);

						const today = new Date();
						const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0));
						console.log("todayUTC", todayUTC);

						// if (user.uid && generatorData?.transporterId != user?.transporterId) {
						// 	tempServices = tempServices.filter((service) => service.routeData.transporterId === user.uid);
						// }
						setNextService(
							tempServices
								.filter((el) => {
									const isMarkedAsClosed = el.markedAsClosedAt && el.markedAsClosedAt.toDate instanceof Function;
									if (
										el.date.toDate().getTime() >= todayUTC.getTime() &&
										el.status !== SERVICE_STATUS.COMPLETE &&
										!isMarkedAsClosed
									) {
										return true;
									} else {
										return false;
									}
								})
								.sort((a, b) => a.date.toDate() - b.date.toDate())
						);
						const lastComplet = tempServices
							.filter((el) => {
								const isCompleted = el.date.toDate() <= todayUTC && el.status === SERVICE_STATUS.COMPLETE;

								const isMarkedAsClosed = el.markedAsClosedAt && el.markedAsClosedAt.toDate instanceof Function;
								return isCompleted || isMarkedAsClosed;
							})
							.sort((a, b) => {
								let aEffectiveDate;
								if (a.markedAsClosedAt && a.markedAsClosedAt.toDate instanceof Function) {
									aEffectiveDate = a.markedAsClosedAt.toDate();
								} else if (a.completedAt?.toDate() && a.completedAt.toDate() > a.date.toDate()) {
									aEffectiveDate = a.completedAt.toDate();
								} else {
									aEffectiveDate = a.date.toDate();
								}
								let bEffectiveDate;
								if (b.markedAsClosedAt && b.markedAsClosedAt.toDate instanceof Function) {
									bEffectiveDate = b.markedAsClosedAt.toDate();
								} else if (b.completedAt?.toDate() && b.completedAt.toDate() > b.date.toDate()) {
									bEffectiveDate = b.completedAt.toDate();
								} else {
									bEffectiveDate = b.date.toDate();
								}
								return bEffectiveDate - aEffectiveDate;
							});
						console.log("lastComplete");
						setLastCompleted(lastComplet);

						const todayServices = tempServices
							.filter((el) => {
								const serviceDate = el.date.toDate();
								return (
									serviceDate.getUTCFullYear() === todayUTC.getUTCFullYear() &&
									serviceDate.getUTCMonth() === todayUTC.getUTCMonth() &&
									serviceDate.getUTCDate() === todayUTC.getUTCDate()
								);
							})
							.sort((a, b) => a.date.toDate() - b.date.toDate());

						console.log("Today services data:", todayServices);
						setTodayService(todayServices);

						if (todayServices.length > 0) {
							await checkTodayService(todayServices);
						} else {
							await checkAllRoutesForTodayServices(generatorData?.id);
						}

						if (serviceCompletionText && todayStartedRoute) {
							console.log(
								"relevant data",
								routeStarted,
								todayStartedRoute,
								generatorWaypointCompleted,
								serviceCompletionText
							);
							await checkStopsRemaing(todayStartedRoute);
						}
					} catch (error) {
						console.log("Error processing services:", error);
					}
				}
			);

			unsubscribers.push(servicesUnsubscribe);
			return () => {
				unsubscribers.forEach((unsubscribe) => unsubscribe());
			};
		} catch (error) {
			console.log("Error setting up snapshot listener:", error);
		}
	}, [generatorData?.id, serviceCompletionText]);

	async function checkTodayService(tservice) {
		const date = new Date();
		const todayUTC = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0));
		const totalService = tservice.length;
		const completedServices = tservice.filter((service) => {
			const isMarkedAsClosed = service.markedAsClosedAt && service.markedAsClosedAt.toDate instanceof Function;
			if (service.status == SERVICE_STATUS.COMPLETE || isMarkedAsClosed) {
				return true;
			} else {
				return false;
			}
		}).length;
		const completionText = `${completedServices} of ${totalService} services completed`;
		let routeIsStarted = false;
		let selectedServiceObj = null;

		const routeIds = [...new Set(tservice.map((s) => s.routeId))].filter(Boolean);
		console.log("routeIDs", routeIds);

		for (const routeId of routeIds) {
			if (!routeId) continue;

			try {
				const routeRef = doc(db, COLLECTIONS.routes, routeId);
				const dailyRouteRef = doc(routeRef, "dailyRoutes", todayUTC.toISOString());
				const dailyRouteData = await getDoc(dailyRouteRef);

				if (dailyRouteData.exists()) {
					const routeData = dailyRouteData.data();

					if (routeData.assignedDriverId && routeData.assignedServiceVehicleId) {
						setDriverId(routeData.assignedDriverId);
						const routeServices = tservice.filter((s) => s.routeId === routeId);
						const inProgressService = routeServices.find(
							(s) =>
								s.status === SERVICE_STATUS.INPROGRESS &&
								s.status !== SERVICE_STATUS.CANCELLED &&
								s.status !== SERVICE_STATUS.DELETED
						);

						if (inProgressService) {
							selectedServiceObj = { service: inProgressService, routeData };
							routeIsStarted = true;
							break;
						}

						const pendingService = routeServices.find(
							(s) =>
								s.status === SERVICE_STATUS.PENDING &&
								s.status !== SERVICE_STATUS.CANCELLED &&
								s.status !== SERVICE_STATUS.DELETED
						);

						if (pendingService) {
							selectedServiceObj = { service: pendingService, routeData };
							routeIsStarted = true;
							break;
						}
					}
				}
			} catch (error) {
				console.error(`Error checking route ${routeId} during initial status check:`, error);
			}
		}

		if (routeIsStarted && selectedServiceObj) {
			setTodayStartedRoute(selectedServiceObj);
			setRouteStarted(true);
		} else {
			setRouteStarted(false);
		}
		setServiceCompletionText(completionText);
		await checkTodayServicesCompletion(generatorData?.id, tservice);
	}

	async function checkTodayServicesCompletion(generatorId, todayServices) {
		if (!generatorId) return false;

		try {
			const incompleteDirectServices = todayServices.filter((service) => {
				const isMarkedAsClosed = service.markedAsClosedAt && service.markedAsClosedAt.toDate instanceof Function;
				return (
					service.status !== SERVICE_STATUS.COMPLETE &&
					service.status !== SERVICE_STATUS.CANCELLED &&
					service.status !== SERVICE_STATUS.DELETED &&
					!isMarkedAsClosed
				);
			});

			if (incompleteDirectServices.length > 0) {
				console.log("Incomplete services detected:", incompleteDirectServices);
				setGeneratorWaypointCompleted(false);
				return false;
			}

			const today = new Date();
			const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0));
			const routeIds = [...new Set(todayServices.map((s) => s.routeId))].filter(Boolean);

			for (const routeId of routeIds) {
				try {
					const routeRef = doc(db, COLLECTIONS.routes, routeId);
					const dailyRouteRef = doc(routeRef, "dailyRoutes", todayUTC.toISOString());
					const dailyRouteData = await getDoc(dailyRouteRef);

					if (dailyRouteData.exists()) {
						const routeData = dailyRouteData.data();
						const waypoints = routeData.waypoints || [];
						const generatorWaypoints = waypoints.filter((wp) => wp.id === generatorId);

						for (const waypoint of generatorWaypoints) {
							if (!waypoint.serviceId) continue;
							const existingService = todayServices.find((s) => s.id === waypoint.serviceId);

							if (!existingService) {
								const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, waypoint.serviceId));
								if (serviceDoc.exists()) {
									const serviceData = serviceDoc.data();
									const serviceDate = serviceData.date.toDate();
									const isToday =
										serviceDate.getUTCFullYear() === todayUTC.getUTCFullYear() &&
										serviceDate.getUTCMonth() === todayUTC.getUTCMonth() &&
										serviceDate.getUTCDate() === todayUTC.getUTCDate();
									const isMarkedAsClosed =
										serviceData.markedAsClosedAt && serviceData.markedAsClosedAt.toDate instanceof Function;

									if (
										isToday &&
										serviceData.status !== SERVICE_STATUS.COMPLETE &&
										serviceData.status !== SERVICE_STATUS.CANCELLED &&
										serviceData.status !== SERVICE_STATUS.DELETED &&
										!isMarkedAsClosed
									) {
										console.log(
											`Incomplete service found in waypoint: ${waypoint.serviceId}, status: ${serviceData.status}`
										);
										setGeneratorWaypointCompleted(false);
										return false;
									}
								}
							}
						}
					}
				} catch (error) {
					console.error(`Error checking waypoints for route ${routeId}:`, error);
					setGeneratorWaypointCompleted(false);
					return false;
				}
			}

			console.log(`All services for generator ${generatorId} are completed.`);
			setGeneratorWaypointCompleted(true);
			return true;
		} catch (error) {
			console.error("Error in checkTodayServicesCompletion:", error);
			setGeneratorWaypointCompleted(false);
			return false;
		}
	}

	async function checkAllRoutesForTodayServices(generatorId) {
		try {
			const date = new Date();
			const todayUTC = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0));
			const todayISOString = todayUTC.toISOString();
			const routesQuery = query(collection(db, COLLECTIONS.routes));
			const routesSnapshot = await getDocs(routesQuery);
			const routes = routesSnapshot.docs.map((doc) => doc.id);

			let hasAnyServices = false;

			for (const routeId of routes) {
				try {
					const routeRef = doc(db, COLLECTIONS.routes, routeId);
					const dailyRouteRef = doc(routeRef, "dailyRoutes", todayISOString);
					const dailyRouteSnapshot = await getDoc(dailyRouteRef);

					if (dailyRouteSnapshot.exists()) {
						const dailyRouteData = dailyRouteSnapshot.data();
						const waypoints = dailyRouteData.waypoints || [];
						const generatorWaypoints = waypoints.filter((wp) => wp.id === generatorId);

						if (generatorWaypoints.length > 0) {
							hasAnyServices = true;
							for (const waypoint of generatorWaypoints) {
								if (!waypoint.serviceId) continue;

								const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, waypoint.serviceId));

								if (serviceDoc.exists()) {
									const serviceData = serviceDoc.data();
									const isMarkedAsClosed =
										serviceData.markedAsClosedAt && serviceData.markedAsClosedAt.toDate instanceof Function;
									if (
										serviceData.status !== SERVICE_STATUS.COMPLETE &&
										serviceData.status !== SERVICE_STATUS.CANCELLED &&
										serviceData.status !== SERVICE_STATUS.DELETED &&
										!isMarkedAsClosed
									) {
										console.log(
											`Found incomplete service ${waypoint.serviceId} in route ${routeId}, status: ${serviceData.status}`
										);
										setGeneratorWaypointCompleted(false);
										return false;
									}
								} else {
									console.log(`Service ${waypoint.serviceId} does not exist in route ${routeId}`);
									setGeneratorWaypointCompleted(false);
									return false;
								}
							}
						}
					}
				} catch (error) {
					console.error(`Error checking route ${routeId}:`, error);
					setGeneratorWaypointCompleted(false);
					return false;
				}
			}

			if (hasAnyServices) {
				console.log(`All services for generator ${generatorId} across all routes are completed`);
				setGeneratorWaypointCompleted(true);
				return true;
			}

			console.log(`No services found for generator ${generatorId} across all routes`);
			setGeneratorWaypointCompleted(false);
			return false;
		} catch (error) {
			console.error("Error checking all routes:", error);
			setGeneratorWaypointCompleted(false);
			return false;
		}
	}

	async function checkStopsRemaing(data) {
		console.log("waypoint", data.routeData.waypoints);
		const waypointData = data.routeData.waypoints;
		let generatorWaypointIndex = -1;
		let inProgressIndex = -1;
		let firstOccurrenceIndex = -1;
		const generatorWaypoints = waypointData.filter((wp) => wp.id === generatorData.id);

		if (waypointData) {
			const totalStops = waypointData.length;
			for (let index = 0; index < totalStops; index++) {
				const waypoint = waypointData[index];
				if (waypoint.id === generatorData.id) {
					if (firstOccurrenceIndex === -1) {
						firstOccurrenceIndex = index;
					}

					try {
						const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, waypoint.serviceId));

						if (!serviceDoc.exists()) continue;

						const serviceData = serviceDoc.data();
						console.log(`Service ${waypoint.serviceId} status: ${serviceData.status}`);

						if (serviceData.status === SERVICE_STATUS.INPROGRESS) {
							inProgressIndex = index;
							console.log(`Found INPROGRESS service at index ${index}`);
						} else if (serviceData.status === SERVICE_STATUS.PENDING && generatorWaypointIndex === -1) {
							generatorWaypointIndex = index;
							console.log(`Found PENDING service at index ${index}`);
						} else if (serviceData.status === SERVICE_STATUS.COMPLETE) {
							console.log(`Found COMPLETE service at index ${index}`);
						}
					} catch (error) {
						console.error(`Error getting service data for waypoint at index ${index}:`, error);
					}
				}
			}

			if (inProgressIndex !== -1) {
				generatorWaypointIndex = inProgressIndex;
			} else if (generatorWaypointIndex === -1) {
				generatorWaypointIndex = firstOccurrenceIndex;
			}

			const serviceIds = waypointData
				.slice(0, generatorWaypointIndex + 1)
				.map((waypoint) => waypoint.serviceId)
				.filter((id) => id);

			let pendingCount = 0;
			let currentGenStatus = null;

			for (const serviceId of serviceIds) {
				try {
					const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, serviceId));

					if (!serviceDoc.exists()) continue;

					const serviceData = serviceDoc.data();

					if (serviceData?.status === SERVICE_STATUS.PENDING) {
						pendingCount++;
					}

					if (serviceId === waypointData[generatorWaypointIndex].serviceId) {
						currentGenStatus = serviceDoc;
						console.log(`Found current generator's service: ${serviceId}, status: ${serviceData.status}`);
					}
				} catch (error) {
					console.error(`Error checking service status for ${serviceId}:`, error);
				}
			}

			if (!currentGenStatus) {
				try {
					const serviceId = waypointData[generatorWaypointIndex].serviceId;
					console.log(`Fetching current generator's service directly: ${serviceId}`);

					currentGenStatus = await getDoc(doc(db, COLLECTIONS.scheduledServices, serviceId));
				} catch (error) {
					console.error(`Error getting current generator status directly:`, error);
				}
			}

			let progress =
				firstOccurrenceIndex > 0
					? ((generatorWaypointIndex + 1 - pendingCount) / (generatorWaypointIndex + 1)) * 100
					: 0;

			let progressbarValue = progress;

			if (currentGenStatus && currentGenStatus.exists()) {
				const status = currentGenStatus.data().status;

				console.log(`Current generator service status: ${status}`);

				if (status === "COMPLETE") {
					progressbarValue = 100;
					console.log(`Service is COMPLETE, setting progress to 100%`);
				} else if (status === SERVICE_STATUS.INPROGRESS || pendingCount === 0) {
					progressbarValue = 90;
					console.log(`Service is INPROGRESS or no pending services, setting progress to 90%`);
				} else {
					progressbarValue = progress === 100 ? 90 : progress;
					console.log(`Setting progress to ${progressbarValue}%`);
				}
			}

			let waypointsRemainingText = "Stops Remaining";

			if (currentGenStatus && currentGenStatus.exists()) {
				const status = currentGenStatus.data().status;

				if (status !== SERVICE_STATUS.PENDING) {
					waypointsRemainingText = "Arriving Next";
					console.log("Service in progress, setting text to 'Arriving Next'");
				}
			}

			setProgressbar(progressbarValue);
			setStopsRemaining(pendingCount);
			setWaypointsRemaining(waypointsRemainingText);
		}

		await checkTodayServicesCompletion(generatorData?.id, todayService);
	}

	useEffect(() => {
		if (childrenData && childrenData.length > 0 && !generatorData.parentAccount) {
			setSelectedValue("");
		} else {
			setSelectedValue(generatorData?.id || "");
		}
	}, [generatorData, childrenData]);
	useEffect(() => {
		const fetchGenerators = async () => {
			if (rootGeneratorIds && Array.isArray(rootGeneratorIds) && rootGeneratorIds.length > 0) {
				const batchSize = 30;
				let results = [];
				for (let i = 0; i < rootGeneratorIds.length; i += batchSize) {
					const batchIds = rootGeneratorIds.slice(i, i + batchSize);
					const q = query(collection(db, COLLECTIONS.generators), where("__name__", "in", batchIds));
					const snapshot = await getDocs(q);
					results = results.concat(snapshot.docs.map((doc) => ({ ...doc.data(), id: doc.id })));
				}
				setAllGenerators(results);
			} else {
				setAllGenerators([]);
			}
		};
		fetchGenerators();
	}, [rootGeneratorIds]);

	useEffect(() => {
		if (!generatorData?.id) return;
		const currentDate = new Date();
		const currentYear = currentDate.getFullYear();
		const startOfYear = new Date(Date.UTC(currentYear, 0, 1, 0, 0, 0, 0));
		const endOfYear = new Date(Date.UTC(currentYear, 11, 31, 23, 59, 59, 999));
		const unsubscribe = onSnapshot(
			query(
				collection(db, COLLECTIONS.scheduledServices),
				where("generatorId", "==", generatorData.id),
				where("status", "not-in", [SERVICE_STATUS.DELETED, SERVICE_STATUS.CANCELLED]),
				where("date", ">=", Timestamp.fromDate(startOfYear)),
				where("date", "<=", Timestamp.fromDate(endOfYear)),
				orderBy("date", "asc")
			),
			async (snap) => {
				try {
					let tempServices = [];
					const jobs = snap.docs.map(async (el) => {
						if (el.exists()) {
							const data = { ...el.data(), id: el.id };
							if (data?.routeId?.length > 0) {
								const routeRes = await getDoc(doc(db, COLLECTIONS.routes, data.routeId));
								if (routeRes.exists()) {
									data.routeData = { ...routeRes.data(), id: routeRes.id };
								}
							}
							if (data?.serviceScheduleId?.length > 0) {
								const serviceScheduleRes = await getDoc(doc(db, COLLECTIONS.serviceSchedules, data.serviceScheduleId));
								if (serviceScheduleRes.exists()) {
									data.serviceScheduleData = { ...serviceScheduleRes.data(), id: serviceScheduleRes.id };
								}
							}
							tempServices.push(data);
						}
					});
					await Promise.all(jobs);
					tempServices = tempServices.sort((a, b) => a.date.toDate() - b.date.toDate());

					setAllServices(tempServices);
				} catch (error) {
					console.error("Error processing snapshot:", error);
				}
			}
		);

		return () => {
			console.log("Unsubscribing from snapshot listener");
			unsubscribe();
		};
	}, [generatorData?.id]);

	useEffect(() => {
		if (!allServices.length) return;
		const today = new Date();
		today.setHours(0, 0, 0, 0);
		allServices.forEach((el) => console.log(el.date.toDate().toISOString()));
		const filteredDate = allServices.filter((el) => el.date.toDate() > today);
		const filteredCompleted = allServices.filter((el) => el.status === SERVICE_STATUS.COMPLETE);
		if (filteredCompleted.length) {
			//setLastCompleted(filteredCompleted[filteredCompleted.length - 1]);
		}
		console.log({ filteredDate });
		filteredDate.forEach((el) => console.log(el.date.toDate().toISOString()));
		if (filteredDate.length) {
			//setNextService(filteredDate[0]);
		}
	}, [allServices]);

	const renderWorkHours = () => {
		if (!generatorData?.workingHours) return "N/A";

		if (nextService?.length > 0 && nextService[0]?.date) {
			const serviceDate = nextService[0].date?.toDate?.();
			if (!serviceDate) return "N/A"; // Ensure serviceDate is valid
			const serviceDateUTC = formatUtcDateString(serviceDate.toISOString());
			const dayOfWeek = daysOfWeek[new Date(serviceDateUTC).getDay()];
			const todaysWorkHours = generatorData.workingHours?.[dayOfWeek];

			if (!todaysWorkHours) return "N/A";

			console.log("todayWH", todaysWorkHours, dayOfWeek);

			return todaysWorkHours.closed ? "Closed" : `${todaysWorkHours.open ?? "N/A"} - ${todaysWorkHours.close ?? "N/A"}`;
		}

		return "N/A";
	};

	async function getTransporterById(id) {
		const tranRef = doc(db, COLLECTIONS.transporters, id);
		const result = await getDoc(tranRef);

		if (!result.exists()) {
			throw new Error("Transporter not found.");
		}

		const data = result.data();
		return data;
	}

	useEffect(() => {
		if (!user?.transporterId) return;

		let isMounted = true;

		const fetchData = async () => {
			try {
				const tranData = await getTransporterById(user.transporterId);

				if (isMounted) {
					setTransporterData(tranData);
				}
			} catch (error) {
				console.error("Error fetching transporter data:", error);
			}
		};

		fetchData();

		return () => {
			isMounted = false;
		};
	}, [user?.transporterId]);

	function formatUtcDateString(utcDateString) {
		const date = new Date(utcDateString);
		const formatter = new Intl.DateTimeFormat("en-US", {
			weekday: "short",
			month: "2-digit",
			day: "2-digit",
			year: "numeric",
			timeZone: "UTC",
		});

		return formatter.format(date);
	}

	if (authLoading || !user || !generatorData) {
		return <Loader />;
	}

	const handleChildChange = (e) => {
		const selectedId = e.target.value;
		const selectedGen = parentOptions.find((gen) => gen.id === selectedId);
		if (selectedGen) {
			setGeneratorData(selectedGen);
		}
	};

	const isParentWithChildren = !data?.parentAccount && childrenData && childrenData.length > 0;
	const parentOptions = allGenerators.filter((gen) => rootGeneratorIds?.includes(gen.id));

	return (
		<div className="bg-bgDefaultColor px-32 py-5 flex flex-col gap-5 ">
			{console.log("Generator Data:", allGenerators)}
			<div className="grid grid-cols-3 gap-5 items-center w-full">
				<ParentDropdown
					generatorData={generatorData}
					parentGenerator={parentGenerator}
					parentOptions={parentOptions}
					handleChildChange={handleChildChange}
				/>

				<ChildDropdown
					selectedValue={selectedValue}
					setSelectedValue={setSelectedValue}
					isParentWithChildren={isParentWithChildren}
					isparent={!parentGenerator?.parentAccount}
					generatorData={generatorData}
					parentGenerator={parentGenerator}
					childrenData={childrenData}
					sameParentGenerators={sameParentGenerators}
					getGeneratorById={getGeneratorById}
					setGeneratorData={setGeneratorData}
					setGeneratorWaypointCompleted={setGeneratorWaypointCompleted}
					isLoadingTracking={isLoadingTracking}
				/>

				<div className="flex justify-end items-center">
					<GeneratorUserAccBtn />
				</div>
			</div>

			<div className="bg-white w-full rounded-xl flex flex-col items-start justify-evenly p-5 shadow-sm">
				<p className="font-semibold">{generatorData.generatorName}</p>
				<p className="font-semibold">{generatorData.octoNumber}</p>
				<p className="font-semibold">{renderAddress(generatorData.serviceAddress)}</p>
			</div>

			<div className="flex justify-between gap-5">
				<div className="bg-white p-10 flex items-center gap-5 flex-col w-full text-center rounded-xl shadow-md">
					<h1 className="font-bold text-3xl">Service</h1>

					<div className="">
						<h2 className="font-semibold text-lg">Next Service</h2>
						<h1 className="text-[#4CD964] text-xl">
							{nextService?.length > 0 && nextService[0]?.date
								? formatUtcDateString(nextService[0].date.toDate())
								: "N/A"}
						</h1>
					</div>

					<div className="grid gap-2 w-full max-w-80">
						<button
							className="w-full  bg-thatblue hover:bg-blue-500 rounded-full text-white p-3"
							onClick={() => {
								navigate("/generator-dashboard/service-reports");
							}}
						>
							Manage Service History
						</button>
						<button
							className="w-full  bg-white hover:bg-[#DEDEDE] rounded-full text-[#666666] border border-[#DEDEDE] p-3"
							onClick={() => {
								navigate(`/generator-dashboard/service-calendar?child=${generatorData?.id}`);
							}}
						>
							Manage Future Services
						</button>
					</div>

					<div className="w-full bg-thatblue text-white  rounded-xl p-5 grid  gap-2">
						<h1 className="font-semibold text-center">Service Summary</h1>
						<hr className="" />

						<div className="grid gap-1">
							<div className="grid grid-cols-2">
								<span className="text-left">Service Address:</span>
								<span className="text-left">{renderAddress(generatorData.serviceAddress)}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Next Service:</span>

								<span className="text-left">
									{nextService?.length > 0 && nextService[0]?.date
										? formatUtcDateString(nextService[0].date.toDate())
										: "N/A"}
								</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Office Hours:</span>
								<span className="text-left">{renderWorkHours() ? renderWorkHours() : "N/A"}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Service Type:</span>
								<span className="text-left">{value ? value : "N/A"}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Last Completed Service:</span>
								<span className="text-left">
									{lastCompleted?.[0]?.completedAt || lastCompleted?.[0]?.markedAsClosedAt
										? formatDateString(
												lastCompleted[0].completedAt?.toDate().toISOString() ||
													lastCompleted[0]?.markedAsClosedAt?.toDate().toISOString(),
												generatorData?.workingHours?.timeZone
										  )
										: "--"}
								</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Service Frequency:</span>
								<span className="text-left">
									{Array.isArray(serviceFrequency) && serviceFrequency.length > 0
										? serviceFrequency
												.map((service) => allServiceFrequencies?.find((el) => el.value === service)?.label ?? "N/A")
												.join(", ")
										: "N/A"}
								</span>
							</div>
						</div>
					</div>
				</div>

				<div className="bg-white p-10 flex items-center gap-5 flex-col w-full text-center rounded-xl shadow-md">
					<h1 className="font-bold text-3xl">Billing</h1>

					<div className="">
						<h2 className="font-semibold text-lg">Open balance</h2>
						<h1 className="text-[#4CD964] text-xl">{dummyBillingData.openBalance}</h1>
					</div>

					<div className="grid gap-2 w-full max-w-80">
						<button
							className="w-full p-3 bg-thatblue hover:bg-blue-500 rounded-full text-white"
							onClick={() => {
								generatorData.id == data.id
									? navigate("/generator-dashboard/invoices-and-payments")
									: navigate(`/generator-dashboard/invoices-and-payments?child=${generatorData.id}`);
							}}
						>
							Manage Invoices
						</button>
						<button
							className="w-full p-3 bg-white hover:bg-[#DEDEDE] rounded-full text-[#666666] border border-[#DEDEDE]"
							onClick={() => {
								generatorData.id == data.id
									? navigate("/generator-dashboard/saved-payment-methods")
									: navigate(`/generator-dashboard/saved-payment-methods?child=${generatorData.id}`);
							}}
						>
							Manage Payment Options
						</button>
					</div>

					<div className="w-full bg-thatblue text-white  rounded-xl p-5 grid  gap-2">
						<h1 className="font-semibold text-center">Billing Summary</h1>

						<hr />

						<div className="grid gap-1">
							<div className="grid grid-cols-2">
								<span className="text-left">Billing Address:</span>
								<span className="text-left">{renderAddress(generatorData?.billingAddress)}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Last Payment:</span>
								<span className="text-left">{dummyBillingData.lastPayment}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Overdue Balance:</span>
								<span className="text-left">{dummyBillingData.overdueBalance}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Unpaid Invoices:</span>
								<span className="text-left">{dummyBillingData.unpaidInvoices}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Billing Frequency:</span>
								<span className="text-left">{dummyBillingData.billingFrequency}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Payment Type</span>
								<span className="text-left">{dummyBillingData.paymentType}</span>
							</div>
						</div>
					</div>
				</div>
			</div>

			<div className="w-full grid grid-cols-2 gap-5 ">
				<div className="bg-white rounded-cardRadii shadow-md p-5 grid grid-cols-1 gap-2">
					<h2 className="text-lg font-bold text-left">Upcoming Service Schedules</h2>
					<div className="grid grid-cols-3 gap-2">
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 border-red-500 bg-white  rounded-none border-[3px] mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Today's Date</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 bg-red-500 rounded-full mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Medical Waste</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 bg-green-500 rounded-full mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Paper Shredding Schedule</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="flex w-6 h-6 col-span-2">
								<div className="w-3 h-6 bg-green-500 rounded-r-full rotate-180"></div>
								<div className="w-3 h-6 bg-red-500 rounded-l-full rotate-180"></div>
							</div>
							<span className="text-gray-700 col-span-6">Medical Waste & Paper Shredding</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 border-yellow-500 border-[3px] mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Holiday (No services on this day)</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 bg-gray-500 rounded-full mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Completed (Past) Service dates</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 col-span-2 rounded-full bg-white border border-gray-500 mr-2" />
							<span className="text-gray-700 col-span-6">Unlogged (Past) Service dates</span>
						</div>
					</div>
				</div>
				<div className="bg-white rounded-xl shadow-md flex flex-col gap-5 relative p-5 justify-center h-full">
					{console.log(
						"all datats",
						serviceCompletionText,
						completed,
						generatorWaypointCompleted,
						waypointsRemaining,
						routeStarted,
						progressBar,
						stopsRemaining
					)}
					{console.log(
						"date data",
						todayService?.[0]?.date ? formatUtcDateString(todayService[0].date.toDate()) : null,
						nextService?.[0]?.date ? formatUtcDateString(nextService[0].date.toDate()) : "not defined"
					)}

					<div className="absolute top-0 right-0 text-sm">
						<p className="p-5">{serviceCompletionText}</p>
					</div>
					<div>
						<h2 className="text-lg font-bold text-left">Live Track</h2>
					</div>
					<div className="text-lg font-bold h-1/2 mt-auto flex items-end">
						{nextService?.[0]?.date &&
						todayService?.[0]?.date &&
						formatUtcDateString(todayService[0]?.date.toDate()) === formatUtcDateString(nextService[0]?.date.toDate())
							? "Tracking "
							: "Check Back On: "}
						(
						{nextService?.[0]?.date && nextService[0].date.toDate() instanceof Date
							? formatUtcDateString(nextService[0].date.toDate())
							: "N/A"}
						)
					</div>

					<div className="h-1/2">
						<div className="relative w-full bg-gray-200 rounded-full h-3 ">
							<div
								className={`${!generatorWaypointCompleted ? "bg-blue-500" : "bg-green-500"} h-3 rounded-full`}
								style={{
									width: generatorWaypointCompleted
										? "100%"
										: waypointsRemaining === "Arriving Next" && routeStarted
										? "90%"
										: routeStarted
										? `${progressBar}%`
										: "0%",
								}}
							/>
							<div className="flex justify-between items-center absolute w-full top-4 -translate-y-1/2">
								{/* Route Started Icon */}
								<div className="flex flex-col ">
									<CheckCircleIcon
										className={`w-7 h-7 ${
											routeStarted
												? "bg-blue-500 text-white"
												: generatorWaypointCompleted
												? "bg-green-500 text-white"
												: "text-gray-300 bg-gray-200"
										} rounded-full `}
									/>
									<span
										className={`${routeStarted || generatorWaypointCompleted ? "text-blue-500" : "text-gray-700"}  `}
									>
										Route Started
									</span>
								</div>
								{/* Waypoints Remaining Circle */}
								<div className="flex flex-col items-center">
									<div
										className={`w-7 h-7 ${
											routeStarted ? "bg-blue-500" : generatorWaypointCompleted ? "bg-green-500 " : "bg-gray-200"
										} rounded-full flex items-center justify-center text-white`}
									>
										{routeStarted && waypointsRemaining !== "Arriving Next" && !generatorWaypointCompleted && (
											<p>{stopsRemaining}</p>
										)}
									</div>
									<span className={`${routeStarted || generatorWaypointCompleted ? "text-blue-500" : "text-gray-700"}`}>
										{routeStarted ? waypointsRemaining : "Stops Remaining"}
									</span>
								</div>
								{/* Service Completed Icon */}
								<div className="flex flex-col items-end ">
									<div
										className={`w-7 h-7 ${generatorWaypointCompleted ? "bg-green-500" : "bg-gray-200"} rounded-full`}
									></div>
									<span className={`${generatorWaypointCompleted ? "text-blue-500" : "text-gray-700"}`}>
										Service Completed
									</span>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>

			<div className="w-full grid grid-cols-2 gap-5">
				<div className="bg-white p-3 rounded-cardRadii shadow-md flex-1 flex flex-col">
					<h2 className="font-bold text-lg ml-1 pb-2">Service Calendar</h2>
					<CalendarWithTimeSlots allServices={allServices} wholeCalender={true} />
					<p
						className="text-thatblue text-md py-2 text-end hover:cursor-pointer"
						onClick={() => {
							navigate(`/generator-dashboard/service-calendar?child=${generatorData.id}`);
						}}
					>
						View Service Calendar
					</p>
				</div>

				<div className="shadow-sm w-full  bg-white rounded-xl">
					<AzureMapsProvider>
						{generatorData?.serviceAddCoordinates?.lat &&
						generatorData?.serviceAddCoordinates?.lng &&
						randomCoordinates?.lat &&
						randomCoordinates?.lng ? (
							<CustomAzureGeneratorDashboardMap
								generatorData={generatorData}
								randomCoordinates={randomCoordinates}
								showPointer={true}
								driverId={driverId}
							/>
						) : (
							<p>Generator Data not flow</p>
						)}
					</AzureMapsProvider>
				</div>
			</div>

			<GeneratorDetailsForm
				billingAddress={generatorData.billingAddress}
				serviceAddress={generatorData.serviceAddress}
				name={generatorData.generatorName}
				changeRequestHandler={() => {
					contactFormRef.current.scrollIntoView({ behavior: "smooth" });
				}}
			/>
			<GeneratorOfficeHours workingHours={generatorData?.workingHours} />
			<div ref={contactFormRef}>
				<ContactUsForm transporterData={transporterData} />
			</div>
		</div>
	);
};

export default GeneratorDashboard;

const dummyBillingData = {
	openBalance: "N/A",
	billingAddress: "N/A",
	lastPayment: "N/A",
	overdueBalance: "N/A",
	unpaidInvoices: "N/A",
	billingFrequency: "N/A",
	paymentType: "N/A",
};
