import { useEffect, useRef, useState } from "react";
import { CheckCircleIcon, ClockIcon, ArrowRightIcon } from "lucide-react";
import {
	onSnapshot,
	query,
	collection,
	where,
	orderBy,
	doc,
	getDoc,
	Timestamp,
	limit,
	getDocs,
} from "firebase/firestore";
import { db, COLLECTIONS } from "../../../config/firebase";
import GeneratorDetailsForm from "./components/GeneratorDetailsForm/GeneratorDetailsForm";
import GeneratorOfficeHours from "../../admin/generator-management/components/generators/components/detail-forms/components/GeneratorOfficeHours/GeneratorOfficeHours";
import ContactUsForm from "./components/ContactUsForm/ContactUsForm";
import { useGeneratorUser } from "../../../context/GeneratorUserContext";
import { useNavigate } from "react-router-dom";
import Loader from "../../../components/UI/loaders/Loader";
import { dateFormatter, daysOfWeek, randomizeCoordinates, renderAddress } from "../../../utils/helpers";
import {
	frequencyPrimaryOptions,
	frequencySecondaryOptions,
	SERVICE_STATUS,
	serviceTypes,
} from "../../../utils/constants";
import CustomAzureGeneratorDashboardMap from "./CustomAzureGeneratorDashboardMap";
import { AzureMapsProvider } from "react-azure-maps";
import CalendarWithTimeSlots from "../../admin/generator-management/components/generators/components/detail-forms/components/open-calendar/GeneratorCalendarComponent";
import { getGeneratorById } from "../../../utils/firebaseOperations";
import { useGeneratorData } from "./components/GeneratorDataContext";
import ChildDropdown from "./components/dropDowns/childDropdown";
import ParentDropdown from "./components/dropDowns/parentDropdown";
import GeneratorUserAccBtn from "../GenUserAccountButton/GeneratorUserAccountButton";
import { flushSync } from 'react-dom';

const GeneratorDashboard = () => {
	const { user, authLoading, generatorData: data, allServices: genService } = useGeneratorUser();
	const [parentAccount, setParentAccount] = useState(null);
	const navigate = useNavigate();
	const [nextService, setNextService] = useState(null);
	const [lastCompleted, setLastCompleted] = useState(null);
	const contactFormRef = useRef();
	const [randomCoordinates, setRandomCoordinates] = useState({ lat: 0, lng: 0 });
	const [waypointsRemaining, setWaypointsRemaining] = useState("Stops Remaining");
	const [completed, setCompleted] = useState(false);
	const [generatorWaypointCompleted, setGeneratorWaypointCompleted] = useState(false);
	const [sameParentGenerators, setSameParentGenerators] = useState(null);
	const [routeStarted, setRouteStarted] = useState(null);
	const [progressBar, setProgressbar] = useState("0%");
	const [stopsRemaining, setStopsRemaining] = useState(0);
	const [value, setValue] = useState("");
	const [serviceFrequency, setServiceFrequency] = useState("");
	const [parentGenerator, setParentGenerator] = useState(null);
	const [childrenData, setChildrenData] = useState(null);
	const [selectedValue, setSelectedValue] = useState(null);
	const { generatorData, setGeneratorData } = useGeneratorData();
	const [todayService, setTodayService] = useState(null);
	const [allServices, setAllServices] = useState([]);
	const [allServiceFrequencies, setAllServiceFrequencies] = useState([
		...frequencyPrimaryOptions,
		...frequencySecondaryOptions,
	]);
	const [serviceCompletionText, setServiceCompletionText] = useState("");
	const [todayStartedRoute, setTodayStartedRoute] = useState();
	const [isLoadingTracking, setIsLoadingTracking] = useState(false);


	useEffect(() => {
		if (!data?.id) return;
		
		setIsLoadingTracking(true);
		setGeneratorData(data);
		setAllServices(genService);
		
		if (generatorData?.parentAccount) {
		  setParentAccount(false);
		} else {
		  setParentAccount(true);
		}
		
		setTimeout(() => {
		  setIsLoadingTracking(false);
		}, 300);
	  }, [data?.id]);
	  
	  // State persistence helpers
const getPersistedState = (genId, key, defaultValue) => {
	try {
	  const stateKey = `gen_${genId}_${key}`;
	  const storedValue = sessionStorage.getItem(stateKey);
	  return storedValue !== null ? JSON.parse(storedValue) : defaultValue;
	} catch (e) {
	  console.error(`Error retrieving persisted state for ${key}:`, e);
	  return defaultValue;
	}
  };
  
  const persistState = (genId, key, value) => {
	try {
	  const stateKey = `gen_${genId}_${key}`;
	  sessionStorage.setItem(stateKey, JSON.stringify(value));
	  console.log(`Persisted ${key} for generator ${genId}: ${value}`);
	} catch (e) {
	  console.error(`Error persisting state for ${key}:`, e);
	}
  };
  
  const clearPersistedState = (genId) => {
	try {
	  Object.keys(sessionStorage).forEach(key => {
		if (key.startsWith(`gen_${genId}_`)) {
		  sessionStorage.removeItem(key);
		}
	  });
	  console.log(`Cleared persisted state for generator ${genId}`);
	} catch (e) {
	  console.error(`Error clearing persisted state:`, e);
	}
  };

	useEffect(() => {
		if (!generatorData?.id) return;
		const q = query(collection(db, COLLECTIONS.serviceSchedules), where("generatorId", "==", generatorData.id));
		const unsubscribe = onSnapshot(q, async (snap) => {
			try {
				console.log("Snapshot received:", snap);
				const tempSchedules = await Promise.all(
					snap.docs.map(async (el) => {
						if (!el.exists()) return null;

						const data = { ...el.data(), id: el.id };
						if (Array.isArray(data.serviceType)) {
							data.serviceType = data.serviceType[0];
						}
						if (data.isDeleted) return null;
						let createdAt = null;
						if (data.createdAt?.seconds || data.createdAt?.nanoseconds) {
							createdAt = new Timestamp(data.createdAt.seconds, data.createdAt.nanoseconds).toDate();
						} else if (data.createdAt?.toDate) {
							createdAt = data.createdAt.toDate();
						} else {
							createdAt = new Date();
						}

						return { ...data, createdAt };
					})
				);
				const filteredSchedules = tempSchedules.filter(Boolean);
				filteredSchedules.sort((a, b) => a.createdAt - b.createdAt);

				const formattedServiceTypes = [...new Set(filteredSchedules.map((item) => item.serviceType))]
					.map((service) => {
						const matchedService = serviceTypes.find((type) => type.value === service);
						return matchedService ? matchedService.label : service;
					})
					.join(", ");

				console.log(formattedServiceTypes);
				const uniqueServiceTypes = [
					...new Set(
						filteredSchedules.map((item) => {
							const type = item.serviceFrequency?.type;
							return type;
						})
					),
				];
				uniqueServiceTypes.filter(Boolean);
				setValue(formattedServiceTypes);
				setServiceFrequency(uniqueServiceTypes);
				console.log("Final schedules:", filteredSchedules);
			} catch (error) {
				console.error("Error processing snapshot:", error);
			}
		});
		return () => {
			console.log("Unsubscribing from snapshot listener");
			unsubscribe();
		};
	}, [generatorData?.id]);

	useEffect(() => {
		if (!generatorData?.id) return;

		const unsubscribe = onSnapshot(
			query(collection(db, COLLECTIONS.generators), where("parentAccount", "==", data?.id)),
			async (snap) => {
				try {
					const data = snap.docs.map((doc) => doc.data());
					setChildrenData(data);
				} catch (error) {
					console.error("Error processing snapshot:", error);
				}
			}
		);
		const unsubscribe2 = onSnapshot(
			query(collection(db, COLLECTIONS.generators), where("parentAccount", "==", generatorData.parentAccount)),
			async (snap) => {
				try {
					const data = snap.docs.map((doc) => doc.data());
					setSameParentGenerators(data);
				} catch (error) {
					console.error("Error processing snapshot:", error);
				}
			}
		);
		const unsubscribe3 = onSnapshot(
			query(collection(db, COLLECTIONS.generators), where("id", "==", generatorData?.parentAccount)),
			async (snap) => {
				try {
					const data = snap.docs.map((doc) => doc.data());
					setParentGenerator(data);
					console.log("psrentgen", data);
				} catch (error) {
					console.error("Error processing snapshot:", error);
				}
			}
		);
		return () => {
			console.log("Unsubscribing from snapshot listener");
			unsubscribe();
			unsubscribe2();
			unsubscribe3();
		};
	}, [generatorData?.id, generatorData?.parentAccount]);

	useEffect(() => {
		if (!authLoading && !user) {
			navigate("/generator-portal-auth");
		}
	}, [authLoading, user, navigate, generatorData]);
	
	useEffect(() => {
		console.log({ generatorData });
		if (!generatorData) return;
		if (
			generatorData?.serviceAddCoordinates &&
			generatorData.serviceAddCoordinates?.lat &&
			generatorData.serviceAddCoordinates?.lng
		) {
			setRandomCoordinates(
				randomizeCoordinates(generatorData.serviceAddCoordinates?.lat, generatorData.serviceAddCoordinates?.lng)
			);
		}

		return () => {};
	}, [generatorData]);

	useEffect(() => {
		if (!allServices?.length) return;
		const today = new Date();
		today.setHours(0, 0, 0, 0);

		const filteredDate = allServices?.filter((el) => {
			const serviceDate = el.date.toDate();
			return serviceDate.getTime() >= today.getTime();
		});

		const filteredCompleted = allServices?.filter((el) => el.status === "COMPLETE");
		if (filteredCompleted) {
			console.log("completed service", filteredCompleted, "yguyg", filteredCompleted[filteredCompleted.length - 1]);

			//setLastCompleted(filteredCompleted[filteredCompleted.length - 1]);
		} else {
			//setLastCompleted(null);
		}
		setCompleted(false);
		if (filteredDate.length) {
			//	setNextService(filteredDate[0]);
		}
	}, [allServices]);

	async function fetchAvailableServices(snap) {
		console.log(`Fetching available services, snapshot size: ${snap.docs.length}`);
		
		try {
		  let tempServices = [];
		  
		  // Process all documents in the snapshot
		  await Promise.all(snap.docs.map(async (el) => {
			if (!el.exists()) return;
			
			const data = { ...el.data(), id: el.id };
			
			// Fetch related route data if available
			if (data?.routeId?.length > 0) {
			  try {
				const routeRes = await getDoc(doc(db, COLLECTIONS.routes, data.routeId));
				if (routeRes.exists()) {
				  data.routeData = { ...routeRes.data(), id: routeRes.id };
				}
			  } catch (error) {
				console.error(`Error fetching route data for service ${data.id}:`, error);
			  }
			}
			
			// Fetch related service schedule data if available
			if (data?.serviceScheduleId?.length > 0) {
			  try {
				const serviceScheduleRes = await getDoc(doc(db, COLLECTIONS.serviceSchedules, data.serviceScheduleId));
				if (serviceScheduleRes.exists()) {
				  data.serviceScheduleData = { ...serviceScheduleRes.data(), id: serviceScheduleRes.id };
				}
			  } catch (error) {
				console.error(`Error fetching schedule data for service ${data.id}:`, error);
			  }
			}
			
			tempServices.push(data);
		  }));
		  
		  // Filter out deleted or cancelled services
		  tempServices = tempServices.filter(
			(el) => el.status !== SERVICE_STATUS.DELETED && el.status !== SERVICE_STATUS.CANCELLED
		  );
		  
		  // Define today's date in UTC
		  const today = new Date();
		  const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0));
		  
		  // Set next services (future, non-completed services)
		  const nextServices = tempServices
			.filter((el) => {
			  return el.date.toDate() >= todayUTC && 
					 el.status !== SERVICE_STATUS.COMPLETE && 
					 el.status !== SERVICE_STATUS.CANCELLED;
			})
			.sort((a, b) => a.date.toDate() - b.date.toDate());
		  
		  console.log(`Found ${nextServices.length} next services`);
		  setNextService(nextServices);
		  
		  // Set last completed services
		  const lastCompletedServices = tempServices
			.filter((el) => el.status === SERVICE_STATUS.COMPLETE)
			.sort((a, b) => b.date.toDate() - a.date.toDate());
		  
		  console.log(`Found ${lastCompletedServices.length} completed services`);
		  setLastCompleted(lastCompletedServices);
		  
		  // Set today's services
		  const todayServices = tempServices
			.filter((el) => {
			  const serviceDate = el.date.toDate();
			  return serviceDate.getUTCFullYear() === todayUTC.getUTCFullYear() &&
					 serviceDate.getUTCMonth() === todayUTC.getUTCMonth() &&
					 serviceDate.getUTCDate() === todayUTC.getUTCDate();
			})
			.sort((a, b) => a.date.toDate() - b.date.toDate());
		  
		  console.log(`Found ${todayServices.length} services for today`);
		  setTodayService(todayServices);
		  
		} catch (error) {
		  console.error("Error in fetchAvailableServices:", error);
		}
	  }

	const nextServiceDateString = todayService?.[0]?.date ? todayService[0].date.toDate().toISOString() : null;
	const startDate = new Date();
	const endDate = new Date();
	startDate.setDate(startDate.getDate() - 30);
	const currentGeneratorRef = useRef(null);
const subscriptionsRef = useRef([]);

// First, let's fix the useEffect hook
useEffect(() => {
	if (!generatorData?.id) return;
	
	console.log(`=== Generator changed to: ${generatorData.id} ===`);
	
	// Track the previous generator ID for debugging
	const prevGenId = currentGeneratorRef.current;
	currentGeneratorRef.current = generatorData.id;
	
	console.log(`Previous generator: ${prevGenId}, New generator: ${generatorData.id}`);
	
	// Set loading state at the beginning
	setIsLoadingTracking(true);
	
	// Reset display states, but not the route started state
	setTodayStartedRoute(null);
	setGeneratorWaypointCompleted(false);
	setProgressbar(0);
	setStopsRemaining(0);
	setWaypointsRemaining("Stops Remaining");
	setServiceCompletionText("");
	
	// Store the current generator ID for cancellation checks
	const currentGenId = generatorData.id;
	
	// Clear all subscriptions on generator change
	const unsubscribers = [];
	
	const date = new Date();
	const todayUTC = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0));
	const timestampId = todayUTC.toISOString();
	
	// Use a timeout to allow the state to settle before querying Firebase
	setTimeout(() => {
	  // One consolidated query for services
	  const servicesUnsubscribe = onSnapshot(
		query(
		  collection(db, COLLECTIONS.scheduledServices),
		  where("generatorId", "==", currentGenId),
		  where("status", "not-in", [SERVICE_STATUS.CANCELLED, SERVICE_STATUS.DELETED]),
		  where("date", ">=", Timestamp.fromDate(startDate)),
		  where("date", "<=", Timestamp.fromDate(endDate)),
		  orderBy("date", "asc"),
		),
		async (snap) => {
		  console.log(`Services snapshot received for generator ${currentGenId}`);
		  console.log(`Current generator in state: ${generatorData.id}`);
		  
		  // Check if the generator has changed
		  if (generatorData.id !== currentGenId) {
			console.log(`Ignoring services snapshot for different generator (current: ${generatorData.id}, expected: ${currentGenId})`);
			return;
		  }
		  
		  try {
			// First, fetch the basic service data
			await fetchAvailableServices(snap);
			
			// If no services today, exit early
			if (!todayService || todayService.length === 0) {
			  console.log(`No today services found for generator ${currentGenId}`);
			  setRouteStarted(false);
			  setIsLoadingTracking(false);
			  return;
			}
			
			console.log(`Processing routes for generator ${currentGenId}`);
			// Process routes with a clear approach - pass the current generator ID
			await processRoutesForTracking(todayService, timestampId, currentGenId);
		  } catch (error) {
			console.error(`Error processing services for generator ${currentGenId}:`, error);
			setIsLoadingTracking(false);
		  }
		}
	  );
	  
	  unsubscribers.push(servicesUnsubscribe);
	  
	  // Store the unsubscribers for cleanup
	  subscriptionsRef.current = unsubscribers;
	}, 100); // Small delay to ensure React state has been updated
	
	// Return a clean-up function that properly removes all subscriptions
	return () => {
	  console.log(`Cleaning up subscriptions for generator ${currentGenId}`);
	  
	  // Clear any stored unsubscribers
	  if (subscriptionsRef.current) {
		subscriptionsRef.current.forEach((unsub) => {
		  if (typeof unsub === 'function') {
			try {
			  unsub();
			} catch (e) {
			  console.error("Error unsubscribing:", e);
			}
		  }
		});
		subscriptionsRef.current = [];
	  }
	};
  }, [ generatorData]);

	  // Add this function to your component
function createCancellableSubscription(subscriptionFn) {
	let isCancelled = false;
	
	const wrappedFn = async (...args) => {
	  if (isCancelled) return;
	  await subscriptionFn(...args);
	};
	
	return {
	  execute: wrappedFn,
	  cancel: () => { isCancelled = true; }
	};
  }
  


  async function processRoutesForTracking(todayServices, timestampId, currentGenId) {
	// Add these variables at the top of the function
	const isFirstRun = !window._processedGenerators;
	window._processedGenerators = window._processedGenerators || {};
	
	console.log(`Processing routes for generator ${currentGenId}, first run: ${isFirstRun}`);
	console.log(`Current generator in state: ${generatorData.id}`);
	
	// Define unsubscribers array at the beginning of the function
	const unsubscribers = [];
	
	if (!todayServices || todayServices.length === 0) {
	  console.log(`No today services for generator ${currentGenId}`);
	  setIsLoadingTracking(false);
	  return [];
	}
	
	// Ensure we're still looking at the same generator
	if (generatorData.id !== currentGenId) {
	  console.log(`Generator changed, cancelling route tracking (current: ${generatorData.id}, expected: ${currentGenId})`);
	  setIsLoadingTracking(false);
	  return [];
	}
	
	try {
	  // Extract unique route IDs
	  const generatorRoutesForDay = [...new Set(todayServices.map((service) => service.routeId))];
	  
	  // Tracking for routes status
	  let anyRouteStarted = false;
	  let selectedService = null;
	  
	  console.log(`Processing ${generatorRoutesForDay.length} routes for generator ${currentGenId}`);
	  
	  // Process each route to find the active one
	  for (const routeId of generatorRoutesForDay) {
		if (!routeId) continue;
		
		console.log(`Checking route ${routeId} for generator ${currentGenId}`);
		
		const routeRef = doc(db, COLLECTIONS.routes, routeId);
		const dailyRouteRef = doc(routeRef, "dailyRoutes", timestampId);
		
		try {
		  const dailyRouteSnapshot = await getDoc(dailyRouteRef);
		  
		  if (!dailyRouteSnapshot.exists()) {
			console.log(`No daily route data for route ${routeId}`);
			continue;
		  }
		  
		  const routeData = dailyRouteSnapshot.data();
		  
		  // Check if route is started (has assigned driver and vehicle)
		  const isRouteStarted = !!(routeData.assignedDriverId && routeData.assignedServiceVehicleId);
		  
		  console.log(`Route ${routeId} isRouteStarted: ${isRouteStarted}`);
		  
		  if (isRouteStarted) {
			// Find any active service for this generator in this route
			const relatedServices = todayServices.filter((s) => s.routeId === routeId);
			
			console.log(`Found ${relatedServices.length} related services for route ${routeId}`);
			
			for (const service of relatedServices) {
			  // Double-check we're still on the right generator before making DB calls
			  if (generatorData.id !== currentGenId) {
				console.log(`Generator changed during service processing (current: ${generatorData.id}, expected: ${currentGenId})`);
				return unsubscribers;
			  }
			  
			  const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, service.id));
			  if (serviceDoc.exists()) {
				const serviceData = serviceDoc.data();
				console.log(`Service ${service.id} status: ${serviceData.status}`);
				
				// Consider any non-cancelled/deleted service as valid for route started
				if (serviceData.status !== "CANCELLED" && serviceData.status !== "DELETED") {
				  selectedService = service;
				  anyRouteStarted = true;
				  
				  // If we find a PENDING or INPROGRESS service, prioritize it
				  if (serviceData.status === "PENDING" || serviceData.status === "INPROGRESS") {
					console.log(`Found active service ${service.id} with status ${serviceData.status}`);
					break;
				  }
				}
			  }
			}
			
			console.log(`Selected service for generator ${currentGenId}:`, selectedService ? selectedService.id : 'none');
			
			// If we found an active service, set up tracking for it
			if (selectedService) {
			  // CRITICAL: Mark this generator as processed to prevent duplicate processing
			  window._processedGenerators[currentGenId] = true;
			  
			  console.log(`Selected service found for generator ${currentGenId}, setting routeStarted to TRUE`);
			  
			  // IMPORTANT: Use flushSync to ensure state updates happen immediately
			  flushSync(() => {
				setTodayStartedRoute(selectedService);
				setRouteStarted(true);
			  });
			  
			  // Set up a clean subscription to this route's data - with proper generator ID checks
			  const selectedDailyRouteRef = doc(routeRef, "dailyRoutes", timestampId);
			  
			  const dailyRouteUnsubscribe = onSnapshot(selectedDailyRouteRef, async (snapshot) => {
				console.log(`Route update received for generator ${currentGenId}`);
				console.log(`Current generator in state: ${generatorData.id}`);
				
				// Check if we're still processing the same generator
				if (generatorData.id !== currentGenId) {
				  console.log(`Ignoring route update for different generator (current: ${generatorData.id}, expected: ${currentGenId})`);
				  return;
				}
				
				if (!snapshot.exists()) return;
				
				// Capture important snapshot data for debugging
				const routeData = snapshot.data();
				console.log(`Processing route data for generator ${currentGenId}:`, {
				  hasWaypoints: !!routeData.waypoints,
				  waypointCount: routeData.waypoints?.length || 0,
				  assignedDriver: !!routeData.assignedDriverId,
				  assignedVehicle: !!routeData.assignedServiceVehicleId
				});
				
				try {
				  await processSelectedRouteData(selectedService, routeData, generatorRoutesForDay, currentGenId);
				} catch (error) {
				  console.error(`Error in onSnapshot handler for generator ${currentGenId}:`, error);
				}
				
				// Check if service is completed
				try {
				  // Final generator check before additional DB queries
				  if (generatorData.id !== currentGenId) {
					console.log(`Generator changed during service status check (current: ${generatorData.id}, expected: ${currentGenId})`);
					return;
				  }
				  
				  const currentServiceDoc = await getDoc(
					doc(db, COLLECTIONS.scheduledServices, selectedService.id)
				  );
				  
				  if (currentServiceDoc.exists()) {
					const status = currentServiceDoc.data().status;
					console.log(`Service ${selectedService.id} status for generator ${currentGenId}: ${status}`);
					
					if (status === "COMPLETE") {
					  console.log(`Service is COMPLETE for generator ${currentGenId}`);
					  
					  // IMPORTANT: Only update completion state, don't touch route started state
					  if (generatorData.id === currentGenId) {
						setGeneratorWaypointCompleted(true);
					  }
					  
					}
				  }
				} catch (error) {
				  console.error(`Error checking service status for generator ${currentGenId}:`, error);
				}
			  });
			  
			  // Store the unsubscribe function
			  unsubscribers.push(dailyRouteUnsubscribe);
			  break; // Exit after finding the first active service
			}
		  }
		} catch (error) {
		  console.error(`Error processing route ${routeId} for generator ${currentGenId}:`, error);
		}
	  }
	  
	  // If no active routes found, update the UI accordingly
	  if (!anyRouteStarted) {
		console.log(`No active routes found for generator ${currentGenId}, setting routeStarted to false`);
		
		// CRITICAL: Only set routeStarted to false if we haven't processed this generator before
		// or if we've never found a route for it
		if (!window._processedGenerators[currentGenId]) {
		  flushSync(() => {
			setRouteStarted(false);
		  });
		} else {
		  console.log(`Skipping setRouteStarted(false) for generator ${currentGenId} as it was processed before`);
		}
	  }
	  
	  // Calculate service stats regardless of route status - with generator check
	  if (generatorData.id === currentGenId) {
		await calculateServiceCompletionStats(currentGenId, timestampId, generatorRoutesForDay);
	  }
	  
	  // Return unsubscribers array
	  return unsubscribers;
	  
	} catch (error) {
	  console.error(`Error in processRoutesForTracking for generator ${currentGenId}:`, error);
	  return unsubscribers;
	} finally {
	  // Always ensure we remove the loading state
	  setIsLoadingTracking(false);
	}
  }

  async function processSelectedRouteData(selectedService, routeData, generatorRoutesForDay, currentGenId) {
	if (!selectedService || !routeData || !routeData.waypoints) {
	  return;
	}
	
	console.log(`Processing selected route data for generator ${currentGenId}`);
	console.log(`Current generator in state: ${generatorData.id}`);
	
	// Ensure we're still processing the same generator
	if (generatorData.id !== currentGenId) {
	  console.log(`Ignoring route data for different generator (current: ${generatorData.id}, expected: ${currentGenId})`);
	  return;
	}
	
	try {
	  const date = new Date();
	  const todayUTC = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0));
	  const timestampId = todayUTC.toISOString();
	  
	  // Find all waypoints for this generator
	  let generatorWaypointIndex = -1;
	  let inProgressIndex = -1;
	  let firstOccurrenceIndex = -1;
	  
	  console.log(`Current generator ID: ${generatorData.id}, waypoints count: ${routeData.waypoints.length}`);
	  
	  // Filter waypoints for this specific generator for better debugging
	  const generatorWaypoints = routeData.waypoints.filter(wp => wp.id === generatorData.id);
	  console.log(`Found ${generatorWaypoints.length} waypoints for generator ${currentGenId}`);
	  
	  // Analyze waypoints to find the relevant one for this generator
	  for (let index = 0; index < routeData.waypoints.length; index++) {
		const waypoint = routeData.waypoints[index];
		
		if (waypoint.id === generatorData.id) {
		  console.log(`Found waypoint for current generator at index: ${index}, serviceId: ${waypoint.serviceId}`);
		  
		  if (firstOccurrenceIndex === -1) {
			firstOccurrenceIndex = index;
		  }
		  
		  try {
			// Check if we're still on the same generator before making DB calls
			if (generatorData.id !== currentGenId) {
			  console.log(`Generator changed during waypoint processing (current: ${generatorData.id}, expected: ${currentGenId})`);
			  return;
			}
			
			const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, waypoint.serviceId));
			
			if (!serviceDoc.exists()) continue;
			
			const serviceData = serviceDoc.data();
			console.log(`Service ${waypoint.serviceId} status: ${serviceData.status}`);
			
			if (serviceData.status === "INPROGRESS") {
			  inProgressIndex = index;
			  console.log(`Found INPROGRESS service at index ${index}`);
			} else if (serviceData.status === "PENDING" && generatorWaypointIndex === -1) {
			  generatorWaypointIndex = index;
			  console.log(`Found PENDING service at index ${index}`);
			} else if (serviceData.status === "COMPLETE") {
			  console.log(`Found COMPLETE service at index ${index}`);
			}
		  } catch (error) {
			console.error(`Error getting service data for waypoint at index ${index}:`, error);
		  }
		}
	  }
	  
	  // Determine which waypoint to use for tracking
	  if (inProgressIndex !== -1) {
		generatorWaypointIndex = inProgressIndex;
		console.log(`Using INPROGRESS waypoint at index ${inProgressIndex}`);
	  } else if (generatorWaypointIndex === -1) {
		generatorWaypointIndex = firstOccurrenceIndex;
		console.log(`Using first occurrence at index ${firstOccurrenceIndex}`);
	  }
	  
	  if (generatorWaypointIndex === -1) {
		console.log(`No valid waypoint index found for generator ${currentGenId}`);
		return;
	  }
	  
	  // Calculate progress based on the selected waypoint
	  const serviceIds = routeData.waypoints
		.slice(0, generatorWaypointIndex + 1)
		.map((waypoint) => waypoint.serviceId)
		.filter((id) => id);
	  
	  console.log(`Calculating progress based on ${serviceIds.length} services up to waypoint ${generatorWaypointIndex}`);
	  
	  let pendingCount = 0;
	  let currentGenStatus = null;
	  
	  // Check the status of all services up to this waypoint
	  for (const serviceId of serviceIds) {
		try {
		  // Check if we're still on the same generator before making DB calls
		  if (generatorData.id !== currentGenId) {
			console.log(`Generator changed during service status check (current: ${generatorData.id}, expected: ${currentGenId})`);
			return;
		  }
		  
		  const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, serviceId));
		  
		  if (!serviceDoc.exists()) continue;
		  
		  const serviceData = serviceDoc.data();
		  
		  if (serviceData?.status === "PENDING") {
			pendingCount++;
		  }
		  
		  if (serviceId === routeData.waypoints[generatorWaypointIndex].serviceId) {
			currentGenStatus = serviceDoc;
			console.log(`Found current generator's service: ${serviceId}, status: ${serviceData.status}`);
		  }
		} catch (error) {
		  console.error(`Error checking service status for ${serviceId}:`, error);
		}
	  }
	  
	  // If we didn't find the current generator's status, get it directly
	  if (!currentGenStatus) {
		try {
		  // Check if we're still on the same generator before making DB calls
		  if (generatorData.id !== currentGenId) {
			console.log(`Generator changed during direct status check (current: ${generatorData.id}, expected: ${currentGenId})`);
			return;
		  }
		  
		  const serviceId = routeData.waypoints[generatorWaypointIndex].serviceId;
		  console.log(`Fetching current generator's service directly: ${serviceId}`);
		  
		  currentGenStatus = await getDoc(doc(db, COLLECTIONS.scheduledServices, serviceId));
		  
		  if (currentGenStatus && currentGenStatus.exists()) {
			console.log(`Direct fetch result: status=${currentGenStatus.data().status}`);
		  } else {
			console.log(`Direct fetch: service document does not exist`);
		  }
		} catch (error) {
		  console.error(`Error getting current generator status directly:`, error);
		}
	  }
	  
	  // Calculate progress percentage
	  let progress = firstOccurrenceIndex > 0
		? ((generatorWaypointIndex + 1 - pendingCount) / (generatorWaypointIndex + 1)) * 100
		: 0;
	  
	  console.log(`Progress calculation: ${progress}%, pendingCount: ${pendingCount}`);
	  
	  // Set appropriate progress bar value based on status
	  let progressbarValue = progress;
	  let shouldSetCompleted = false;
	  
	  if (currentGenStatus && currentGenStatus.exists()) {
		const status = currentGenStatus.data().status;
		
		console.log(`Current generator service status: ${status}`);
		
		// Check if THIS specific generator's service is complete
		if (status === "COMPLETE") {
		  shouldSetCompleted = true;
		  progressbarValue = 100;
		  console.log(`Service is COMPLETE, setting progress to 100%`);
		} else if (status === "INPROGRESS" || pendingCount === 0) {
		  progressbarValue = 90;
		  console.log(`Service is INPROGRESS or no pending services, setting progress to 90%`);
		} else {
		  progressbarValue = progress === 100 ? 90 : progress;
		  console.log(`Setting progress to ${progressbarValue}%`);
		}
	  }
	  
	  // CRITICAL: Before setting ANY state, verify we're still on the same generator
	  if (generatorData.id === currentGenId) {
		console.log(`Updating UI for generator ${currentGenId}`);
		
		// Update UI with calculated values - all wrapped in a flushSync to ensure atomicity
		flushSync(() => {
		  setProgressbar(progressbarValue);
		  setStopsRemaining(pendingCount);
		  setWaypointsRemaining(pendingCount === 0 || (currentGenStatus && currentGenStatus.exists() && 
			  (currentGenStatus.data().status === "INPROGRESS" || 
			   generatorWaypointIndex !== firstOccurrenceIndex)) ? "Arriving Next" : "Stops Remaining");
		  
		  // IMPORTANT: Set waypoint completion state based on service status
		  if (shouldSetCompleted) {
			setGeneratorWaypointCompleted(true);
		  }
		});
	  } else {
		console.log(`Skipping UI updates - generator changed (current: ${generatorData.id}, expected: ${currentGenId})`);
		return;
	  }
	  
	  // Get all waypoints for this specific generator
	  const allGeneratorWaypoints = routeData.waypoints.filter(wp => wp.id === generatorData.id);
	  console.log(`All waypoints for this generator: ${allGeneratorWaypoints.length}`);
	  
	  // Check all services for this generator to determine overall completion
	  let allComplete = true;
	  
	  if (allGeneratorWaypoints.length > 0) {
		for (const waypoint of allGeneratorWaypoints) {
		  if (!waypoint.serviceId) continue;
		  
		  try {
			// Check if we're still on the same generator before making DB calls
			if (generatorData.id !== currentGenId) {
			  console.log(`Generator changed during waypoint completion check (current: ${generatorData.id}, expected: ${currentGenId})`);
			  return;
			}
			
			const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, waypoint.serviceId));
			
			if (serviceDoc.exists()) {
			  const status = serviceDoc.data().status;
			  console.log(`Waypoint service ${waypoint.serviceId} status: ${status}`);
			  
			  if (status !== "COMPLETE") {
				allComplete = false;
				console.log(`Found non-complete service, setting allComplete to false`);
				break;
			  }
			} else {
			  allComplete = false;
			  console.log(`Service document does not exist, setting allComplete to false`);
			  break;
			}
		  } catch (error) {
			console.error(`Error checking waypoint service status:`, error);
			allComplete = false;
			break;
		  }
		}
	  } else {
		allComplete = false;
		console.log(`No waypoints found for this generator, setting allComplete to false`);
	  }
	  
	  // If all services for this generator are complete, update the UI accordingly
	  if (allComplete && generatorData.id === currentGenId) {
		console.log(`All services complete for generator ${currentGenId}, updating UI`);
		flushSync(() => {
		  setGeneratorWaypointCompleted(true);
		});
	  }
	  
	  // Calculate service stats specifically for this generator - with generator check
	  if (generatorData.id === currentGenId) {
		console.log(`Calculating service stats for generator ${currentGenId}`);
		await calculateServiceCompletionStats(currentGenId, timestampId, generatorRoutesForDay);
	  } else {
		console.log(`Skipping service stats calculation - generator changed (current: ${generatorData.id}, expected: ${currentGenId})`);
	  }
	  
	} catch (error) {
	  console.error(`Error processing route data for generator ${currentGenId}:`, error);
	}
  }

  async function calculateServiceCompletionStats(generatorId, timestampId, generatorRoutesForDay) {
	if (!generatorId) return { total: 0, completed: 0, allComplete: false };
	
	console.log(`Calculating service stats for generator ${generatorId}`);
	console.log(`Current generator in state: ${generatorData.id}`);
	
	// Ensure we're still processing the right generator
	if (generatorData.id !== generatorId) {
	  console.log(`Ignoring service stats for different generator (current: ${generatorData.id}, expected: ${generatorId})`);
	  return { total: 0, completed: 0, allComplete: false };
	}
	
	try {
	  let totalServicesCount = 0;
	  let completedServicesCount = 0;
	  
	  // Get all services for today
	  const todayStart = new Date(timestampId);
	  const todayEnd = new Date(todayStart);
	  todayEnd.setHours(23, 59, 59, 999);
	  
	  const todayStartTimestamp = Timestamp.fromDate(todayStart);
	  const todayEndTimestamp = Timestamp.fromDate(todayEnd);
	  
	  // CRITICAL: Ensure we're ONLY retrieving services for THIS specific generator
	  const servicesQuery = query(
		collection(db, COLLECTIONS.scheduledServices),
		where("generatorId", "==", generatorId),
		where("date", ">=", todayStartTimestamp),
		where("date", "<=", todayEndTimestamp),
		where("status", "not-in", [SERVICE_STATUS.CANCELLED, SERVICE_STATUS.DELETED])
	  );
	  
	  const servicesSnapshot = await getDocs(servicesQuery);
	  
	  // Debug logging to ensure we're getting the right data
	  console.log(`Found ${servicesSnapshot.docs.length} services for generator ${generatorId}`);
	  
	  totalServicesCount = servicesSnapshot.docs.length;
	  
	  // Count completed services
	  completedServicesCount = servicesSnapshot.docs.filter(
		(doc) => doc.data().status === SERVICE_STATUS.COMPLETE
	  ).length;
	  
	  console.log(`Direct query results - Generator ${generatorId}: ${completedServicesCount} of ${totalServicesCount} completed`);
	  
	  // If no services found in the direct query, check all route waypoints
	  if (totalServicesCount === 0 && generatorRoutesForDay && generatorRoutesForDay.length > 0) {
		console.log(`Checking route waypoints for generator ${generatorId}`);
		
		for (const routeId of generatorRoutesForDay) {
		  if (!routeId) continue;
		  
		  // Check if we're still on the same generator before making DB calls
		  if (generatorData.id !== generatorId) {
			console.log(`Generator changed during route checking (current: ${generatorData.id}, expected: ${generatorId})`);
			return { total: 0, completed: 0, allComplete: false };
		  }
		  
		  try {
			const routeDocRef = doc(db, COLLECTIONS.routes, routeId);
			const dailyRouteRef = doc(routeDocRef, "dailyRoutes", timestampId);
			const dailyRouteData = await getDoc(dailyRouteRef);
			
			if (!dailyRouteData.exists()) {
			  console.log(`No daily route data for route ${routeId}`);
			  continue;
			}
			
			const routeWaypoints = dailyRouteData.data().waypoints || [];
			
			// CRITICAL: Filter waypoints to ONLY include those for THIS generator
			const generatorWaypoints = routeWaypoints.filter((wp) => wp.id === generatorId);
			
			console.log(`Route ${routeId}: Found ${generatorWaypoints.length} waypoints for generator ${generatorId}`);
			
			totalServicesCount += generatorWaypoints.length;
			
			// Check each service's status
			for (const waypoint of generatorWaypoints) {
			  if (!waypoint.serviceId) continue;
			  
			  // Check if we're still on the same generator before making DB calls
			  if (generatorData.id !== generatorId) {
				console.log(`Generator changed during service checking (current: ${generatorData.id}, expected: ${generatorId})`);
				return { total: 0, completed: 0, allComplete: false };
			  }
			  
			  try {
				const serviceDoc = await getDoc(doc(db, COLLECTIONS.scheduledServices, waypoint.serviceId));
				
				if (serviceDoc.exists()) {
				  const status = serviceDoc.data().status;
				  console.log(`Service ${waypoint.serviceId} for generator ${generatorId}: status=${status}`);
				  
				  if (status === SERVICE_STATUS.COMPLETE) {
					completedServicesCount++;
				  }
				}
			  } catch (error) {
				console.error(`Error checking service status for generator ${generatorId}:`, error);
			  }
			}
		  } catch (error) {
			console.error(`Error getting daily route data for route ${routeId}:`, error);
		  }
		}
	  }
	  
	  console.log(`Final counts for generator ${generatorId}: ${completedServicesCount} of ${totalServicesCount} completed`);
	  
	  // Calculate completion flag based ONLY on services for THIS generator
	  const allComplete = totalServicesCount > 0 && completedServicesCount === totalServicesCount;
	  
	  // IMPORTANT: Before updating ANY state, verify we're still on the same generator
	  if (generatorData.id === generatorId) {
		console.log(`Setting service completion text and state for generator ${generatorId}`);
		
		const completionText = `${completedServicesCount} of ${totalServicesCount} services completed`;
		
		// Use flushSync to make state updates atomic
		flushSync(() => {
		  setServiceCompletionText(completionText);
		  setGeneratorWaypointCompleted(allComplete);
		  
		  // CRITICAL: Do NOT update routeStarted state here
		  // Let the route started state be managed separately
		});
	  } else {
		console.log(`Skipping service stats updates - generator changed (current: ${generatorData.id}, expected: ${generatorId})`);
	  }
	  
	  return {
		total: totalServicesCount,
		completed: completedServicesCount,
		allComplete,
	  };
	} catch (error) {
	  console.error(`Error calculating service stats for generator ${generatorId}:`, error);
	  return { total: 0, completed: 0, allComplete: false };
	}
  }

	useEffect(() => {
		if (childrenData && childrenData.length > 0 && !generatorData.parentAccount) {
			setSelectedValue("");
		} else {
			setSelectedValue(generatorData?.id || "");
		}
	}, [generatorData, childrenData]);

	useEffect(() => {
		if (!generatorData?.id) return;
        const currentDate = new Date();  
		const currentYear = currentDate.getFullYear();  
		const startOfYear = new Date(Date.UTC(currentYear, 0, 1, 0, 0, 0, 0)); 
		const endOfYear = new Date(Date.UTC(currentYear, 11, 31, 23, 59, 59, 999));
		const unsubscribe = onSnapshot(
			query(
				collection(db, COLLECTIONS.scheduledServices),
				where("generatorId", "==", generatorData.id),
				where("status", "not-in", ["DELETED", "CANCELLED"]),
				where("date", ">=", Timestamp.fromDate(startOfYear)),
				where("date", "<=", Timestamp.fromDate(endOfYear)),
				orderBy("date", "asc")
			),
			async (snap) => {
				try {
					console.log("Snapshot received:", snap);
					const tempServices = [];
					const jobs = snap.docs.map(async (el) => {
						if (el.exists()) {
							console.log("Document data:", el.data());
							const serviceData = el.data();
							const scheduleRes = await getDoc(doc(db, COLLECTIONS.serviceSchedules, serviceData.serviceScheduleId));
							if (scheduleRes.exists()) {
								serviceData.scheduleData = { ...scheduleRes.data(), id: scheduleRes.id };
							}
							tempServices.push({ ...serviceData, id: el.id });
						}
					});
					await Promise.all(jobs);
					console.log("tempService", tempServices);
					setAllServices(tempServices);
				} catch (error) {
					console.error("Error processing snapshot:", error);
				}
			}
		);

		return () => {
			console.log("Unsubscribing from snapshot listener");
			unsubscribe();
		};
	}, [generatorData?.id]);

	useEffect(() => {
		if (!allServices.length) return;
		const today = new Date();
		today.setHours(0, 0, 0, 0);
		allServices.forEach((el) => console.log(el.date.toDate().toISOString()));
		const filteredDate = allServices.filter((el) => el.date.toDate() > today);
		const filteredCompleted = allServices.filter((el) => el.status === SERVICE_STATUS.COMPLETE);
		if (filteredCompleted.length) {
			//setLastCompleted(filteredCompleted[filteredCompleted.length - 1]);
		}
		console.log({ filteredDate });
		filteredDate.forEach((el) => console.log(el.date.toDate().toISOString()));
		if (filteredDate.length) {
			//setNextService(filteredDate[0]);
		}
	}, [allServices]);

	const renderWorkHours = () => {
		if (!generatorData?.workingHours) return "N/A";

		if (nextService?.length > 0 && nextService[0]?.date) {
			const serviceDate = nextService[0].date?.toDate?.();
			if (!serviceDate) return "N/A"; // Ensure serviceDate is valid
			const serviceDateUTC = formatUtcDateString(serviceDate.toISOString());
			const dayOfWeek = daysOfWeek[new Date(serviceDateUTC).getDay()];
			const todaysWorkHours = generatorData.workingHours?.[dayOfWeek];

			if (!todaysWorkHours) return "N/A";

			console.log("todayWH", todaysWorkHours, dayOfWeek);

			return todaysWorkHours.closed ? "Closed" : `${todaysWorkHours.open ?? "N/A"} - ${todaysWorkHours.close ?? "N/A"}`;
		}

		return "N/A";
	};

	function formatUtcDateString(utcDateString) {
		const date = new Date(utcDateString);
		const formatter = new Intl.DateTimeFormat("en-US", {
			weekday: "short",
			month: "2-digit",
			day: "2-digit",
			year: "numeric",
			timeZone: "UTC",
		});

		return formatter.format(date);
	}

	if (authLoading || !user || !generatorData) {
		return <Loader />;
	}
	const isParentWithChildren = !data?.parentAccount && childrenData && childrenData.length > 0;

	return (
		<div className="bg-bgDefaultColor px-32 py-5 flex flex-col gap-5 ">
			<div className="grid grid-cols-3 gap-5 items-center ">
				<ParentDropdown
					//  isParent={isparent}
					generatorData={generatorData}
					parentGenerator={parentGenerator}
					// handleChildChange={handleChildChange}
				/>

				<ChildDropdown
					selectedValue={selectedValue}
					setSelectedValue={setSelectedValue}
					isParentWithChildren={isParentWithChildren}
					isparent={!parentGenerator?.parentAccount}
					generatorData={generatorData}
					parentGenerator={parentGenerator}
					childrenData={childrenData}
					sameParentGenerators={sameParentGenerators}
					getGeneratorById={getGeneratorById}
					setGeneratorData={setGeneratorData}
				/>

				{/* <button className="bg-lightBlue hover:bg-cardTextBlue text-white rounded-full py-3 px-4 shadow-lg transition-all duration-300 flex justify-between items-center space-x-2">
					<span>Add Service Location</span>
					<span>
						<Plus />
					</span>
				</button> */}
				<div className="fixed top-4 right-8 z-50">
                 <GeneratorUserAccBtn />
                </div>
			</div>

			<div className="bg-white w-full rounded-xl flex flex-col items-start justify-evenly p-5 shadow-sm">
				<p className="font-semibold">{generatorData.generatorName}</p>
				<p className="font-semibold">{generatorData.octoNumber}</p>
				<p className="font-semibold">{renderAddress(generatorData.serviceAddress)}</p>
			</div>

			<div className="flex justify-between gap-5">
				<div className="bg-white p-10 flex items-center gap-5 flex-col w-full text-center rounded-xl shadow-md">
					<h1 className="font-bold text-3xl">Service</h1>

					<div className="">
						<h2 className="font-semibold text-lg">Next Service</h2>
						<h1 className="text-[#4CD964] text-xl">
							{nextService?.length > 0 && nextService[0]?.date
								? formatUtcDateString(nextService[0].date.toDate())
								: "N/A"}
						</h1>
					</div>

					<div className="grid gap-2 w-full max-w-80">
						<button
							className="w-full  bg-thatblue hover:bg-blue-500 rounded-full text-white p-3"
							onClick={() => {
								navigate("/generator-dashboard/service-reports");
							}}
						>
							Manage Service History
						</button>
						<button
							className="w-full  bg-white hover:bg-[#DEDEDE] rounded-full text-[#666666] border border-[#DEDEDE] p-3"
							onClick={() => {
								navigate(`/generator-dashboard/service-calendar?child=${generatorData?.id}`);
							}}
						>
							Manage Future Services
						</button>
					</div>

					<div className="w-full bg-thatblue text-white  rounded-xl p-5 grid  gap-2">
						<h1 className="font-semibold text-center">Service Summary</h1>
						<hr className="" />

						<div className="grid gap-1">
							<div className="grid grid-cols-2">
								<span className="text-left">Service Address:</span>
								<span className="text-left">{renderAddress(generatorData.serviceAddress)}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Next Service:</span>

								<span className="text-left">
									{nextService?.length > 0 && nextService[0]?.date
										? formatUtcDateString(nextService[0].date.toDate())
										: "N/A"}
								</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Office Hours:</span>
								<span className="text-left">{renderWorkHours() ? renderWorkHours() : "N/A"}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Service Type:</span>
								<span className="text-left">{value ? value : "N/A"}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Last Completed Service:</span>
								<span className="text-left">
									{lastCompleted?.[0]?.completedAt
										? (lastCompleted[0].completedAt.toDate?.().toLocaleDateString() ?? new Date())
										: "N/A"}
								</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Service Frequency:</span>
								<span className="text-left">
									{Array.isArray(serviceFrequency) && serviceFrequency.length > 0
										? serviceFrequency
												.map((service) => allServiceFrequencies?.find((el) => el.value === service)?.label ?? "N/A")
												.join(", ")
										: "N/A"}
								</span>
							</div>
						</div>
					</div>
				</div>

				<div className="bg-white p-10 flex items-center gap-5 flex-col w-full text-center rounded-xl shadow-md">
					<h1 className="font-bold text-3xl">Billing</h1>

					<div className="">
						<h2 className="font-semibold text-lg">Open balance</h2>
						<h1 className="text-[#4CD964] text-xl">{dummyBillingData.openBalance}</h1>
					</div>

					<div className="grid gap-2 w-full max-w-80">
						<button
							className="w-full p-3 bg-thatblue hover:bg-blue-500 rounded-full text-white"
							onClick={() => {
								generatorData.id == data.id
									? navigate("/generator-dashboard/invoices-and-payments")
									: navigate(`/generator-dashboard/invoices-and-payments?child=${generatorData.id}`);
							}}
						>
							Manage Invoices
						</button>
						<button
							className="w-full p-3 bg-white hover:bg-[#DEDEDE] rounded-full text-[#666666] border border-[#DEDEDE]"
							onClick={() => {
								generatorData.id == data.id
									? navigate("/generator-dashboard/saved-payment-methods")
									: navigate(`/generator-dashboard/saved-payment-methods?child=${generatorData.id}`);
							}}
						>
							Manage Payment Options
						</button>
					</div>

					<div className="w-full bg-thatblue text-white  rounded-xl p-5 grid  gap-2">
						<h1 className="font-semibold text-center">Billing Summary</h1>

						<hr />

						<div className="grid gap-1">
							<div className="grid grid-cols-2">
								<span className="text-left">Billing Address:</span>
								<span className="text-left">{renderAddress(generatorData.billingAddress)}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Last Payment:</span>
								<span className="text-left">{dummyBillingData.lastPayment}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Overdue Balance:</span>
								<span className="text-left">{dummyBillingData.overdueBalance}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Unpaid Invoices:</span>
								<span className="text-left">{dummyBillingData.unpaidInvoices}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Billing Frequency:</span>
								<span className="text-left">{dummyBillingData.billingFrequency}</span>
							</div>
							<div className="grid grid-cols-2">
								<span className="text-left">Payment Type</span>
								<span className="text-left">{dummyBillingData.paymentType}</span>
							</div>
						</div>
					</div>
				</div>
			</div>

			<div className="w-full grid grid-cols-2 gap-5 ">
				<div className="bg-white rounded-cardRadii shadow-md p-5 grid grid-cols-1 gap-2">
					<h2 className="text-lg font-bold text-left">Upcoming Service Schedules</h2>
					<div className="grid grid-cols-3 gap-2">
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 border-red-500 bg-white  rounded-none border-[3px] mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Today's Date</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 bg-red-500 rounded-full mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Medical Waste</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 bg-green-500 rounded-full mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Paper Shredding Schedule</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="flex w-6 h-6 col-span-2">
								<div className="w-3 h-6 bg-green-500 rounded-r-full rotate-180"></div>
								<div className="w-3 h-6 bg-red-500 rounded-l-full rotate-180"></div>
							</div>
							<span className="text-gray-700 col-span-6">Medical Waste & Paper Shredding</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 bg-yellow-500 rounded-full mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Holiday (No services on this day)</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 bg-gray-500 rounded-full mr-2 col-span-2" />
							<span className="text-gray-700 col-span-6">Completed (Past) Service dates</span>
						</div>
						<div className="grid grid-cols-8 items-center">
							<div className="w-6 h-6 col-span-2 rounded-full bg-white border border-gray-500 mr-2" />
							<span className="text-gray-700 col-span-6">Unlogged (Past) Service dates</span>
						</div>
					</div>
				</div>
				<div className="bg-white rounded-xl shadow-md flex flex-col gap-5 relative p-5 justify-center h-full">
				{console.log("all datats",serviceCompletionText,completed,generatorWaypointCompleted,waypointsRemaining,routeStarted,progressBar,stopsRemaining)}
					<div className="absolute top-0 right-0 text-sm">
						<p className="p-5">{serviceCompletionText}</p>
					</div>
					<div>
						<h2 className="text-lg font-bold text-left">Live Track</h2>
					</div>
					<div className="text-lg font-bold h-1/2 mt-auto flex items-end">
						{todayService?.[0]?.date &&
						nextService?.[0]?.date &&
						formatUtcDateString(todayService[0].date.toDate()) === formatUtcDateString(nextService[0].date.toDate())
							? "Tracking "
							: "Check Back On: "}
						(
						{nextService?.[0]?.date && nextService[0].date.toDate() instanceof Date
							? formatUtcDateString(nextService[0].date.toDate())
							: "N/A"}
						)
					</div>

					<div className="h-1/2">
						<div className="relative w-full bg-gray-200 rounded-full h-3 ">
							<div
								className={`${!completed ? "bg-blue-500" : "bg-green-500"} h-3 rounded-full`}
								style={{
									width: generatorWaypointCompleted
										? "100%"
										: waypointsRemaining === "Arriving Next"
										? "90%"
										: routeStarted
										? `${progressBar}%`
										: "0%",
								}}
							/>
							<div className="flex justify-between items-center absolute w-full top-4 -translate-y-1/2">
								{/* Route Started Icon */}
								<div className="flex flex-col ">
									<CheckCircleIcon
										className={`w-7 h-7 ${
											routeStarted || generatorWaypointCompleted
												? "bg-blue-500 text-white"
												: "text-gray-300 bg-gray-200"
										} rounded-full `}
									/>
									<span
										className={`${routeStarted || generatorWaypointCompleted ? "text-blue-500" : "text-gray-700"}  `}
									>
										Route Started
									</span>
								</div>
								{/* Waypoints Remaining Circle */}
								<div className="flex flex-col items-center">
									<div
										className={`w-7 h-7 ${
											routeStarted || generatorWaypointCompleted ? "bg-blue-500" : "bg-gray-200"
										} rounded-full flex items-center justify-center text-white`}
									>
										{routeStarted && waypointsRemaining !== "Arriving Next" && !generatorWaypointCompleted && (
											<p>{stopsRemaining}</p>
										)}
									</div>
									<span
										className={`${
											routeStarted || waypointsRemaining == "Arriving Next" ? "text-blue-500" : "text-gray-700"
										}`}
									>
										{waypointsRemaining}
									</span>
								</div>
								{/* Service Completed Icon */}
								<div className="flex flex-col items-end ">
									<div
										className={`w-7 h-7 ${generatorWaypointCompleted ? "bg-blue-500" : "bg-gray-200"} rounded-full`}
									></div>
									<span className={`${generatorWaypointCompleted ? "text-blue-500" : "text-gray-700"}`}>
										Service Completed
									</span>
								</div>
							</div>
						</div>
					</div>
				</div>
			</div>

			<div className="w-full grid grid-cols-2 gap-5">
				<div className="bg-white p-3 rounded-cardRadii shadow-md flex-1 flex flex-col">
					<h2 className="font-bold text-lg ml-1 pb-2">Service Calendar</h2>
					<CalendarWithTimeSlots allServices={allServices} wholeCalender={true} />
					<p
						className="text-thatblue text-md py-2 text-end hover:cursor-pointer"
						onClick={() => {
							navigate(`/generator-dashboard/service-calendar?child=${generatorData.id}`);
						}}
					>
						View Service Calendar
					</p>
				</div>

				<div className="shadow-sm w-full  bg-white rounded-xl">
					<AzureMapsProvider>
						{generatorData?.serviceAddCoordinates?.lat &&
						generatorData?.serviceAddCoordinates?.lng &&
						randomCoordinates?.lat &&
						randomCoordinates?.lng ? (
							<CustomAzureGeneratorDashboardMap generatorData={generatorData} randomCoordinates={randomCoordinates} />
						) : (
							<p>Generator Data not flow</p>
						)}
					</AzureMapsProvider>
				</div>
			</div>

			<GeneratorDetailsForm
				billingAddress={generatorData.billingAddress}
				serviceAddress={generatorData.serviceAddress}
				name={generatorData.generatorName}
				changeRequestHandler={() => {
					contactFormRef.current.scrollIntoView({ behavior: "smooth" });
				}}
			/>
			<GeneratorOfficeHours workingHours={generatorData.workingHours} />
			<div ref={contactFormRef}>
				<ContactUsForm />
			</div>
		</div>
	);
};

export default GeneratorDashboard;

const dummyBillingData = {
	openBalance: "N/A",
	billingAddress: "N/A",
	lastPayment: "N/A",
	overdueBalance: "N/A",
	unpaidInvoices: "N/A",
	billingFrequency: "N/A",
	paymentType: "N/A",
};
